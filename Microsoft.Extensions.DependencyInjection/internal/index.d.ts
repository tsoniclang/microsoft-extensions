// Generated by tsbindgen - Architecture
// Namespace: Microsoft.Extensions.DependencyInjection
// Assembly: Microsoft.Extensions.Caching.Memory, Microsoft.Extensions.DependencyInjection, Microsoft.Extensions.DependencyInjection.Abstractions, Microsoft.Extensions.Diagnostics, Microsoft.Extensions.Diagnostics.HealthChecks, Microsoft.Extensions.Hosting.Abstractions, Microsoft.Extensions.Http, Microsoft.Extensions.Localization, Microsoft.Extensions.Logging, Microsoft.Extensions.Options, Microsoft.Extensions.Options.ConfigurationExtensions, Microsoft.Extensions.Options.DataAnnotations, Microsoft.Extensions.Validation, Microsoft.Extensions.WebEncoders

// Primitive type aliases from @tsonic/core
import type { sbyte, byte, short, ushort, int, uint, long, ulong, int128, uint128, half, float, double, decimal, nint, nuint, char } from '@tsonic/core/types.js';

// Import types from other namespaces
import type { MemoryCacheOptions, MemoryDistributedCacheOptions } from "../../Microsoft.Extensions.Caching.Memory/internal/index.js";
import type { BinderOptions, IConfiguration } from "../../Microsoft.Extensions.Configuration/internal/index.js";
import type { HealthCheckRegistration, HealthCheckResult, HealthStatus, IHealthCheck } from "../../Microsoft.Extensions.Diagnostics.HealthChecks/internal/index.js";
import type { IMetricsBuilder } from "../../Microsoft.Extensions.Diagnostics.Metrics/internal/index.js";
import type { IHostedService } from "../../Microsoft.Extensions.Hosting/internal/index.js";
import type { IHttpClientLogger } from "../../Microsoft.Extensions.Http.Logging/internal/index.js";
import type { HttpMessageHandlerBuilder } from "../../Microsoft.Extensions.Http/internal/index.js";
import type { LocalizationOptions } from "../../Microsoft.Extensions.Localization/internal/index.js";
import type { ILoggingBuilder } from "../../Microsoft.Extensions.Logging/internal/index.js";
import type { OptionsBuilder_1 } from "../../Microsoft.Extensions.Options/internal/index.js";
import type { ValidationOptions } from "../../Microsoft.Extensions.Validation/internal/index.js";
import type { WebEncoderOptions } from "../../Microsoft.Extensions.WebEncoders/internal/index.js";
import * as System_Collections_Generic_Internal from "@tsonic/dotnet/System.Collections.Generic.js";
import type { ICollection, IEnumerable as IEnumerable__System_Collections_Generic, IEnumerator, IList } from "@tsonic/dotnet/System.Collections.Generic.js";
import * as System_Collections_Internal from "@tsonic/dotnet/System.Collections.js";
import type { IEnumerable } from "@tsonic/dotnet/System.Collections.js";
import * as System_Internal from "@tsonic/dotnet/System.js";
import type { Action, AsyncCallback, Attribute, Boolean as ClrBoolean, Enum, Func, IAsyncDisposable, IAsyncResult, ICloneable, IComparable, IConvertible, IDisposable, IFormattable, Int32, IntPtr, IServiceProvider, ISpanFormattable, MulticastDelegate, Nullable, Object as ClrObject, String as ClrString, TimeSpan, Type, ValueType, Void } from "@tsonic/dotnet/System.js";
import type { DelegatingHandler, HttpClient, HttpMessageHandler, SocketsHttpHandler } from "@tsonic/dotnet/System.Net.Http.js";
import * as System_Runtime_Serialization_Internal from "@tsonic/dotnet/System.Runtime.Serialization.js";
import type { ISerializable } from "@tsonic/dotnet/System.Runtime.Serialization.js";
import type { CancellationToken } from "@tsonic/dotnet/System.Threading.js";
import type { Task, ValueTask } from "@tsonic/dotnet/System.Threading.Tasks.js";

export enum ServiceKeyLookupMode {
    InheritKey = 0,
    NullKey = 1,
    ExplicitKey = 2
}


export enum ServiceLifetime {
    Singleton = 0,
    Scoped = 1,
    Transient = 2
}


export type ObjectFactory = (serviceProvider: IServiceProvider, arguments: unknown[]) => unknown;


export type ObjectFactory_1<T> = (serviceProvider: IServiceProvider, arguments: unknown[]) => T;


export interface IHealthChecksBuilder$instance {
    readonly Services: IServiceCollection;
    Add(registration: HealthCheckRegistration): IHealthChecksBuilder;
}


export type IHealthChecksBuilder = IHealthChecksBuilder$instance;

export interface IHttpClientBuilder$instance {
    readonly Name: string;
    readonly Services: IServiceCollection;
}


export type IHttpClientBuilder = IHttpClientBuilder$instance;

export interface IKeyedServiceProvider$instance extends IServiceProvider {
    GetKeyedService(serviceType: Type, serviceKey: unknown): unknown | undefined;
}


export type IKeyedServiceProvider = IKeyedServiceProvider$instance;

export interface IServiceCollection$instance extends IList<ServiceDescriptor>, ICollection<ServiceDescriptor>, IEnumerable__System_Collections_Generic<ServiceDescriptor>, IEnumerable {
}


export type IServiceCollection = IServiceCollection$instance;

export interface IServiceProviderFactory_1$instance<TContainerBuilder> {
    CreateBuilder(services: IServiceCollection): TContainerBuilder;
    CreateServiceProvider(containerBuilder: TContainerBuilder): IServiceProvider;
}


export type IServiceProviderFactory_1<TContainerBuilder> = IServiceProviderFactory_1$instance<TContainerBuilder>;

export interface IServiceProviderIsKeyedService$instance extends IServiceProviderIsService {
    IsKeyedService(serviceType: Type, serviceKey: unknown): boolean;
    IsService(serviceType: Type): boolean;
}


export interface IServiceProviderIsKeyedService$instance extends IServiceProviderIsService$instance {}

export type IServiceProviderIsKeyedService = IServiceProviderIsKeyedService$instance;

export interface IServiceProviderIsService$instance {
    IsService(serviceType: Type): boolean;
}


export type IServiceProviderIsService = IServiceProviderIsService$instance;

export interface IServiceScope$instance extends IDisposable {
    readonly ServiceProvider: IServiceProvider;
}


export type IServiceScope = IServiceScope$instance;

export interface IServiceScopeFactory$instance {
    CreateScope(): IServiceScope;
}


export type IServiceScopeFactory = IServiceScopeFactory$instance;

export interface ISocketsHttpHandlerBuilder$instance {
    readonly Name: string;
    readonly Services: IServiceCollection;
}


export type ISocketsHttpHandlerBuilder = ISocketsHttpHandlerBuilder$instance;

export interface ISupportRequiredService$instance {
    GetRequiredService(serviceType: Type): unknown;
}


export type ISupportRequiredService = ISupportRequiredService$instance;

export interface AsyncServiceScope$instance {
    readonly ServiceProvider: IServiceProvider;
    Dispose(): void;
    DisposeAsync(): ValueTask;
}


export const AsyncServiceScope: {
    new(serviceScope: IServiceScope): AsyncServiceScope;
};


export interface __AsyncServiceScope$views {
    As_IServiceScope(): IServiceScope$instance;
}

export interface AsyncServiceScope$instance extends IServiceScope$instance {}

export type AsyncServiceScope = AsyncServiceScope$instance & __AsyncServiceScope$views;


export interface ActivatorUtilitiesConstructorAttribute$instance extends Attribute {
}


export const ActivatorUtilitiesConstructorAttribute: {
    new(): ActivatorUtilitiesConstructorAttribute;
};


export type ActivatorUtilitiesConstructorAttribute = ActivatorUtilitiesConstructorAttribute$instance;

export interface DefaultServiceProviderFactory$instance {
    CreateBuilder(services: IServiceCollection): IServiceCollection;
    CreateServiceProvider(containerBuilder: IServiceCollection): IServiceProvider;
}


export const DefaultServiceProviderFactory: {
    new(): DefaultServiceProviderFactory;
    new(options: ServiceProviderOptions): DefaultServiceProviderFactory;
};


export interface __DefaultServiceProviderFactory$views {
    As_IServiceProviderFactory_1(): IServiceProviderFactory_1$instance<IServiceCollection>;
}

export interface DefaultServiceProviderFactory$instance extends IServiceProviderFactory_1$instance<IServiceCollection> {}

export type DefaultServiceProviderFactory = DefaultServiceProviderFactory$instance & __DefaultServiceProviderFactory$views;


export interface FromKeyedServicesAttribute$instance extends Attribute {
    readonly Key: unknown | undefined;
    readonly LookupMode: ServiceKeyLookupMode;
}


export const FromKeyedServicesAttribute: {
    new(key: unknown): FromKeyedServicesAttribute;
    new(): FromKeyedServicesAttribute;
};


export type FromKeyedServicesAttribute = FromKeyedServicesAttribute$instance;

export interface ServiceCollection$instance extends IServiceCollection {
    readonly Count: int;
    readonly IsReadOnly: boolean;
    Item: ServiceDescriptor;
    Clear(): void;
    Contains(item: ServiceDescriptor): boolean;
    CopyTo(array: ServiceDescriptor[], arrayIndex: int): void;
    GetEnumerator(): IEnumerator<ServiceDescriptor>;
    IndexOf(item: ServiceDescriptor): int;
    Insert(index: int, item: ServiceDescriptor): void;
    MakeReadOnly(): void;
    Remove(item: ServiceDescriptor): boolean;
    RemoveAt(index: int): void;
}


export const ServiceCollection: {
    new(): ServiceCollection;
};


export type ServiceCollection = ServiceCollection$instance;

export interface ServiceDescriptor$instance {
    readonly ImplementationFactory: Func<IServiceProvider, unknown> | undefined;
    readonly ImplementationInstance: unknown | undefined;
    readonly ImplementationType: Type | undefined;
    readonly IsKeyedService: boolean;
    readonly KeyedImplementationFactory: Func<IServiceProvider, unknown | undefined, unknown> | undefined;
    readonly KeyedImplementationInstance: unknown | undefined;
    readonly KeyedImplementationType: Type | undefined;
    readonly Lifetime: ServiceLifetime;
    readonly ServiceKey: unknown | undefined;
    readonly ServiceType: Type;
    ToString(): string;
}


export const ServiceDescriptor: {
    new(serviceType: Type, implementationType: Type, lifetime: ServiceLifetime): ServiceDescriptor;
    new(serviceType: Type, serviceKey: unknown, implementationType: Type, lifetime: ServiceLifetime): ServiceDescriptor;
    new(serviceType: Type, instance: unknown): ServiceDescriptor;
    new(serviceType: Type, serviceKey: unknown, instance: unknown): ServiceDescriptor;
    new(serviceType: Type, factory: Func<IServiceProvider, unknown>, lifetime: ServiceLifetime): ServiceDescriptor;
    new(serviceType: Type, serviceKey: unknown, factory: Func<IServiceProvider, unknown, unknown>, lifetime: ServiceLifetime): ServiceDescriptor;
    Describe(serviceType: Type, implementationFactory: Func<IServiceProvider, unknown>, lifetime: ServiceLifetime): ServiceDescriptor;
    Describe(serviceType: Type, implementationType: Type, lifetime: ServiceLifetime): ServiceDescriptor;
    DescribeKeyed(serviceType: Type, serviceKey: unknown, implementationFactory: Func<IServiceProvider, unknown, unknown>, lifetime: ServiceLifetime): ServiceDescriptor;
    DescribeKeyed(serviceType: Type, serviceKey: unknown, implementationType: Type, lifetime: ServiceLifetime): ServiceDescriptor;
    KeyedScoped<TService, TImplementation extends TService>(serviceKey: unknown, implementationFactory: Func<IServiceProvider, unknown, TImplementation>): ServiceDescriptor;
    KeyedScoped<TService, TImplementation extends TService>(serviceKey: unknown): ServiceDescriptor;
    KeyedScoped(service: Type, serviceKey: unknown, implementationFactory: Func<IServiceProvider, unknown, unknown>): ServiceDescriptor;
    KeyedScoped(service: Type, serviceKey: unknown, implementationType: Type): ServiceDescriptor;
    KeyedSingleton<TService, TImplementation extends TService>(serviceKey: unknown, implementationFactory: Func<IServiceProvider, unknown, TImplementation>): ServiceDescriptor;
    KeyedSingleton<TService>(serviceKey: unknown, implementationInstance: TService): ServiceDescriptor;
    KeyedSingleton<TService, TImplementation extends TService>(serviceKey: unknown): ServiceDescriptor;
    KeyedSingleton(serviceType: Type, serviceKey: unknown, implementationFactory: Func<IServiceProvider, unknown, unknown>): ServiceDescriptor;
    KeyedSingleton(serviceType: Type, serviceKey: unknown, implementationInstance: unknown): ServiceDescriptor;
    KeyedSingleton(service: Type, serviceKey: unknown, implementationType: Type): ServiceDescriptor;
    KeyedTransient<TService, TImplementation extends TService>(serviceKey: unknown, implementationFactory: Func<IServiceProvider, unknown, TImplementation>): ServiceDescriptor;
    KeyedTransient<TService, TImplementation extends TService>(serviceKey: unknown): ServiceDescriptor;
    KeyedTransient(service: Type, serviceKey: unknown, implementationFactory: Func<IServiceProvider, unknown, unknown>): ServiceDescriptor;
    KeyedTransient(service: Type, serviceKey: unknown, implementationType: Type): ServiceDescriptor;
    Scoped<TService, TImplementation extends TService>(): ServiceDescriptor;
    Scoped<TService, TImplementation extends TService>(implementationFactory: Func<IServiceProvider, TImplementation>): ServiceDescriptor;
    Scoped(service: Type, implementationFactory: Func<IServiceProvider, unknown>): ServiceDescriptor;
    Scoped(service: Type, implementationType: Type): ServiceDescriptor;
    Singleton<TService, TImplementation extends TService>(): ServiceDescriptor;
    Singleton<TService, TImplementation extends TService>(implementationFactory: Func<IServiceProvider, TImplementation>): ServiceDescriptor;
    Singleton(serviceType: Type, implementationFactory: Func<IServiceProvider, unknown>): ServiceDescriptor;
    Singleton(serviceType: Type, implementationInstance: unknown): ServiceDescriptor;
    Singleton(service: Type, implementationType: Type): ServiceDescriptor;
    Singleton<TService>(implementationInstance: TService): ServiceDescriptor;
    Transient<TService, TImplementation extends TService>(): ServiceDescriptor;
    Transient<TService, TImplementation extends TService>(implementationFactory: Func<IServiceProvider, TImplementation>): ServiceDescriptor;
    Transient(service: Type, implementationFactory: Func<IServiceProvider, unknown>): ServiceDescriptor;
    Transient(service: Type, implementationType: Type): ServiceDescriptor;
};


export type ServiceDescriptor = ServiceDescriptor$instance;

export interface ServiceKeyAttribute$instance extends Attribute {
}


export const ServiceKeyAttribute: {
    new(): ServiceKeyAttribute;
};


export type ServiceKeyAttribute = ServiceKeyAttribute$instance;

export interface ServiceProvider$instance {
    Dispose(): void;
    DisposeAsync(): ValueTask;
    GetKeyedService(serviceType: Type, serviceKey: unknown): unknown | undefined;
    GetRequiredKeyedService(serviceType: Type, serviceKey: unknown): unknown;
    GetService(serviceType: Type): unknown | undefined;
}


export const ServiceProvider: {
    new(): ServiceProvider;
};


export interface __ServiceProvider$views {
    As_IKeyedServiceProvider(): IKeyedServiceProvider$instance;
}

export interface ServiceProvider$instance extends IKeyedServiceProvider$instance {}

export type ServiceProvider = ServiceProvider$instance & __ServiceProvider$views;


export interface ServiceProviderOptions$instance {
    ValidateOnBuild: boolean;
    ValidateScopes: boolean;
}


export const ServiceProviderOptions: {
    new(): ServiceProviderOptions;
};


export type ServiceProviderOptions = ServiceProviderOptions$instance;

export abstract class ActivatorUtilities$instance {
    static CreateFactory(instanceType: Type, argumentTypes: Type[]): ObjectFactory;
    static CreateFactory<T>(argumentTypes: Type[]): ObjectFactory_1<T>;
    static CreateInstance<T>(provider: IServiceProvider, ...parameters: unknown[]): T;
    static CreateInstance(provider: IServiceProvider, instanceType: Type, ...parameters: unknown[]): unknown;
    static GetServiceOrCreateInstance(provider: IServiceProvider, type: Type): unknown;
    static GetServiceOrCreateInstance<T>(provider: IServiceProvider): T;
}


export type ActivatorUtilities = ActivatorUtilities$instance;

export abstract class EncoderServiceCollectionExtensions$instance {
    static AddWebEncoders(services: IServiceCollection, setupAction: Action<WebEncoderOptions>): IServiceCollection;
    static AddWebEncoders(services: IServiceCollection): IServiceCollection;
}


export type EncoderServiceCollectionExtensions = EncoderServiceCollectionExtensions$instance;

export abstract class HealthChecksBuilderAddCheckExtensions$instance {
    static AddCheck(builder: IHealthChecksBuilder, name: string, instance: IHealthCheck, failureStatus?: Nullable<HealthStatus>, tags?: IEnumerable__System_Collections_Generic<System_Internal.String>, timeout?: Nullable<TimeSpan>): IHealthChecksBuilder;
    static AddCheck(builder: IHealthChecksBuilder, name: string, instance: IHealthCheck, failureStatus: Nullable<HealthStatus>, tags: IEnumerable__System_Collections_Generic<System_Internal.String>): IHealthChecksBuilder;
    static AddCheck<T extends IHealthCheck>(builder: IHealthChecksBuilder, name: string, failureStatus?: Nullable<HealthStatus>, tags?: IEnumerable__System_Collections_Generic<System_Internal.String>, timeout?: Nullable<TimeSpan>): IHealthChecksBuilder;
    static AddCheck<T extends IHealthCheck>(builder: IHealthChecksBuilder, name: string, failureStatus: Nullable<HealthStatus>, tags: IEnumerable__System_Collections_Generic<System_Internal.String>): IHealthChecksBuilder;
    static AddTypeActivatedCheck<T extends IHealthCheck>(builder: IHealthChecksBuilder, name: string, failureStatus: Nullable<HealthStatus>, tags: IEnumerable__System_Collections_Generic<System_Internal.String>, ...args: unknown[]): IHealthChecksBuilder;
    static AddTypeActivatedCheck<T extends IHealthCheck>(builder: IHealthChecksBuilder, name: string, failureStatus: Nullable<HealthStatus>, tags: IEnumerable__System_Collections_Generic<System_Internal.String>, timeout: TimeSpan, ...args: unknown[]): IHealthChecksBuilder;
    static AddTypeActivatedCheck<T extends IHealthCheck>(builder: IHealthChecksBuilder, name: string, failureStatus: Nullable<HealthStatus>, ...args: unknown[]): IHealthChecksBuilder;
    static AddTypeActivatedCheck<T extends IHealthCheck>(builder: IHealthChecksBuilder, name: string, ...args: unknown[]): IHealthChecksBuilder;
}


export type HealthChecksBuilderAddCheckExtensions = HealthChecksBuilderAddCheckExtensions$instance;

export abstract class HealthChecksBuilderDelegateExtensions$instance {
    static AddAsyncCheck(builder: IHealthChecksBuilder, name: string, check: Func<Task<HealthCheckResult>>, tags?: IEnumerable__System_Collections_Generic<System_Internal.String>, timeout?: Nullable<TimeSpan>): IHealthChecksBuilder;
    static AddAsyncCheck(builder: IHealthChecksBuilder, name: string, check: Func<Task<HealthCheckResult>>, tags: IEnumerable__System_Collections_Generic<System_Internal.String>): IHealthChecksBuilder;
    static AddAsyncCheck(builder: IHealthChecksBuilder, name: string, check: Func<CancellationToken, Task<HealthCheckResult>>, tags?: IEnumerable__System_Collections_Generic<System_Internal.String>, timeout?: Nullable<TimeSpan>): IHealthChecksBuilder;
    static AddAsyncCheck(builder: IHealthChecksBuilder, name: string, check: Func<CancellationToken, Task<HealthCheckResult>>, tags: IEnumerable__System_Collections_Generic<System_Internal.String>): IHealthChecksBuilder;
    static AddCheck(builder: IHealthChecksBuilder, name: string, check: Func<HealthCheckResult>, tags?: IEnumerable__System_Collections_Generic<System_Internal.String>, timeout?: Nullable<TimeSpan>): IHealthChecksBuilder;
    static AddCheck(builder: IHealthChecksBuilder, name: string, check: Func<HealthCheckResult>, tags: IEnumerable__System_Collections_Generic<System_Internal.String>): IHealthChecksBuilder;
    static AddCheck(builder: IHealthChecksBuilder, name: string, check: Func<CancellationToken, HealthCheckResult>, tags?: IEnumerable__System_Collections_Generic<System_Internal.String>, timeout?: Nullable<TimeSpan>): IHealthChecksBuilder;
    static AddCheck(builder: IHealthChecksBuilder, name: string, check: Func<CancellationToken, HealthCheckResult>, tags: IEnumerable__System_Collections_Generic<System_Internal.String>): IHealthChecksBuilder;
}


export type HealthChecksBuilderDelegateExtensions = HealthChecksBuilderDelegateExtensions$instance;

export abstract class HealthCheckServiceCollectionExtensions$instance {
    static AddHealthChecks(services: IServiceCollection): IHealthChecksBuilder;
}


export type HealthCheckServiceCollectionExtensions = HealthCheckServiceCollectionExtensions$instance;

export abstract class HttpClientBuilderExtensions$instance {
    static AddAsKeyed(builder: IHttpClientBuilder, lifetime?: ServiceLifetime): IHttpClientBuilder;
    static AddDefaultLogger(builder: IHttpClientBuilder): IHttpClientBuilder;
    static AddHttpMessageHandler(builder: IHttpClientBuilder, configureHandler: Func<DelegatingHandler>): IHttpClientBuilder;
    static AddHttpMessageHandler(builder: IHttpClientBuilder, configureHandler: Func<IServiceProvider, DelegatingHandler>): IHttpClientBuilder;
    static AddHttpMessageHandler<THandler extends DelegatingHandler>(builder: IHttpClientBuilder): IHttpClientBuilder;
    static AddLogger<TLogger extends IHttpClientLogger>(builder: IHttpClientBuilder, wrapHandlersPipeline?: boolean): IHttpClientBuilder;
    static AddLogger(builder: IHttpClientBuilder, httpClientLoggerFactory: Func<IServiceProvider, IHttpClientLogger>, wrapHandlersPipeline?: boolean): IHttpClientBuilder;
    static AddTypedClient<TClient>(builder: IHttpClientBuilder, factory: Func<HttpClient, TClient>): IHttpClientBuilder;
    static AddTypedClient<TClient>(builder: IHttpClientBuilder, factory: Func<HttpClient, IServiceProvider, TClient>): IHttpClientBuilder;
    static AddTypedClient<TClient>(builder: IHttpClientBuilder): IHttpClientBuilder;
    static ConfigureAdditionalHttpMessageHandlers(builder: IHttpClientBuilder, configureAdditionalHandlers: Action<IList<DelegatingHandler>, IServiceProvider>): IHttpClientBuilder;
    static ConfigureHttpClient(builder: IHttpClientBuilder, configureClient: Action<HttpClient>): IHttpClientBuilder;
    static ConfigureHttpClient(builder: IHttpClientBuilder, configureClient: Action<IServiceProvider, HttpClient>): IHttpClientBuilder;
    static ConfigureHttpMessageHandlerBuilder(builder: IHttpClientBuilder, configureBuilder: Action<HttpMessageHandlerBuilder>): IHttpClientBuilder;
    static ConfigurePrimaryHttpMessageHandler(builder: IHttpClientBuilder, configureHandler: Action<HttpMessageHandler, IServiceProvider>): IHttpClientBuilder;
    static ConfigurePrimaryHttpMessageHandler(builder: IHttpClientBuilder, configureHandler: Func<HttpMessageHandler>): IHttpClientBuilder;
    static ConfigurePrimaryHttpMessageHandler(builder: IHttpClientBuilder, configureHandler: Func<IServiceProvider, HttpMessageHandler>): IHttpClientBuilder;
    static ConfigurePrimaryHttpMessageHandler<THandler extends HttpMessageHandler>(builder: IHttpClientBuilder): IHttpClientBuilder;
    static RedactLoggedHeaders(builder: IHttpClientBuilder, redactedLoggedHeaderNames: IEnumerable__System_Collections_Generic<System_Internal.String>): IHttpClientBuilder;
    static RedactLoggedHeaders(builder: IHttpClientBuilder, shouldRedactHeaderValue: Func<System_Internal.String, System_Internal.Boolean>): IHttpClientBuilder;
    static RemoveAllLoggers(builder: IHttpClientBuilder): IHttpClientBuilder;
    static RemoveAsKeyed(builder: IHttpClientBuilder): IHttpClientBuilder;
    static SetHandlerLifetime(builder: IHttpClientBuilder, handlerLifetime: TimeSpan): IHttpClientBuilder;
    static UseSocketsHttpHandler(builder: IHttpClientBuilder, configureBuilder: Action<ISocketsHttpHandlerBuilder>): IHttpClientBuilder;
    static UseSocketsHttpHandler(builder: IHttpClientBuilder, configureHandler?: Action<SocketsHttpHandler, IServiceProvider>): IHttpClientBuilder;
}


export type HttpClientBuilderExtensions = HttpClientBuilderExtensions$instance;

export abstract class HttpClientFactoryServiceCollectionExtensions$instance {
    static AddHttpClient<TClient, TImplementation extends TClient>(services: IServiceCollection, factory: Func<HttpClient, TImplementation>): IHttpClientBuilder;
    static AddHttpClient<TClient, TImplementation extends TClient>(services: IServiceCollection, factory: Func<HttpClient, IServiceProvider, TImplementation>): IHttpClientBuilder;
    static AddHttpClient<TClient>(services: IServiceCollection, configureClient: Action<HttpClient>): IHttpClientBuilder;
    static AddHttpClient<TClient>(services: IServiceCollection, configureClient: Action<IServiceProvider, HttpClient>): IHttpClientBuilder;
    static AddHttpClient<TClient, TImplementation extends TClient>(services: IServiceCollection, name: string, factory: Func<HttpClient, TImplementation>): IHttpClientBuilder;
    static AddHttpClient<TClient, TImplementation extends TClient>(services: IServiceCollection, name: string, factory: Func<HttpClient, IServiceProvider, TImplementation>): IHttpClientBuilder;
    static AddHttpClient(services: IServiceCollection, name: string, configureClient: Action<HttpClient>): IHttpClientBuilder;
    static AddHttpClient(services: IServiceCollection, name: string, configureClient: Action<IServiceProvider, HttpClient>): IHttpClientBuilder;
    static AddHttpClient(services: IServiceCollection, name: string): IHttpClientBuilder;
    static AddHttpClient<TClient>(services: IServiceCollection): IHttpClientBuilder;
    static AddHttpClient(services: IServiceCollection): IServiceCollection;
    static ConfigureHttpClientDefaults(services: IServiceCollection, configure: Action<IHttpClientBuilder>): IServiceCollection;
}


export type HttpClientFactoryServiceCollectionExtensions = HttpClientFactoryServiceCollectionExtensions$instance;

export abstract class KeyedService$instance {
    static readonly AnyKey: unknown;
}


export type KeyedService = KeyedService$instance;

export abstract class LocalizationServiceCollectionExtensions$instance {
    static AddLocalization(services: IServiceCollection, setupAction: Action<LocalizationOptions>): IServiceCollection;
    static AddLocalization(services: IServiceCollection): IServiceCollection;
}


export type LocalizationServiceCollectionExtensions = LocalizationServiceCollectionExtensions$instance;

export abstract class LoggingServiceCollectionExtensions$instance {
    static AddLogging(services: IServiceCollection, configure: Action<ILoggingBuilder>): IServiceCollection;
    static AddLogging(services: IServiceCollection): IServiceCollection;
}


export type LoggingServiceCollectionExtensions = LoggingServiceCollectionExtensions$instance;

export abstract class MemoryCacheServiceCollectionExtensions$instance {
    static AddDistributedMemoryCache(services: IServiceCollection, setupAction: Action<MemoryDistributedCacheOptions>): IServiceCollection;
    static AddDistributedMemoryCache(services: IServiceCollection): IServiceCollection;
    static AddMemoryCache(services: IServiceCollection, setupAction: Action<MemoryCacheOptions>): IServiceCollection;
    static AddMemoryCache(services: IServiceCollection): IServiceCollection;
}


export type MemoryCacheServiceCollectionExtensions = MemoryCacheServiceCollectionExtensions$instance;

export abstract class MetricsServiceExtensions$instance {
    static AddMetrics(services: IServiceCollection, configure: Action<IMetricsBuilder>): IServiceCollection;
    static AddMetrics(services: IServiceCollection): IServiceCollection;
}


export type MetricsServiceExtensions = MetricsServiceExtensions$instance;

export abstract class OptionsBuilderConfigurationExtensions$instance {
    static Bind<TOptions>(optionsBuilder: OptionsBuilder_1<TOptions>, config: IConfiguration, configureBinder: Action<BinderOptions>): OptionsBuilder_1<TOptions>;
    static Bind<TOptions>(optionsBuilder: OptionsBuilder_1<TOptions>, config: IConfiguration): OptionsBuilder_1<TOptions>;
    static BindConfiguration<TOptions>(optionsBuilder: OptionsBuilder_1<TOptions>, configSectionPath: string, configureBinder?: Action<BinderOptions>): OptionsBuilder_1<TOptions>;
}


export type OptionsBuilderConfigurationExtensions = OptionsBuilderConfigurationExtensions$instance;

export abstract class OptionsBuilderDataAnnotationsExtensions$instance {
    static ValidateDataAnnotations<TOptions>(optionsBuilder: OptionsBuilder_1<TOptions>): OptionsBuilder_1<TOptions>;
}


export type OptionsBuilderDataAnnotationsExtensions = OptionsBuilderDataAnnotationsExtensions$instance;

export abstract class OptionsBuilderExtensions$instance {
    static ValidateOnStart<TOptions>(optionsBuilder: OptionsBuilder_1<TOptions>): OptionsBuilder_1<TOptions>;
}


export type OptionsBuilderExtensions = OptionsBuilderExtensions$instance;

export abstract class OptionsConfigurationServiceCollectionExtensions$instance {
    static Configure<TOptions>(services: IServiceCollection, config: IConfiguration, configureBinder: Action<BinderOptions>): IServiceCollection;
    static Configure<TOptions>(services: IServiceCollection, config: IConfiguration): IServiceCollection;
    static Configure<TOptions>(services: IServiceCollection, name: string, config: IConfiguration, configureBinder: Action<BinderOptions>): IServiceCollection;
    static Configure<TOptions>(services: IServiceCollection, name: string, config: IConfiguration): IServiceCollection;
}


export type OptionsConfigurationServiceCollectionExtensions = OptionsConfigurationServiceCollectionExtensions$instance;

export abstract class OptionsServiceCollectionExtensions$instance {
    static AddOptions<TOptions>(services: IServiceCollection, name: string): OptionsBuilder_1<TOptions>;
    static AddOptions(services: IServiceCollection): IServiceCollection;
    static AddOptions<TOptions>(services: IServiceCollection): OptionsBuilder_1<TOptions>;
    static AddOptionsWithValidateOnStart<TOptions>(services: IServiceCollection, name?: string): OptionsBuilder_1<TOptions>;
    static Configure<TOptions>(services: IServiceCollection, configureOptions: Action<TOptions>): IServiceCollection;
    static Configure<TOptions>(services: IServiceCollection, name: string, configureOptions: Action<TOptions>): IServiceCollection;
    static ConfigureAll<TOptions>(services: IServiceCollection, configureOptions: Action<TOptions>): IServiceCollection;
    static ConfigureOptions(services: IServiceCollection, configureInstance: unknown): IServiceCollection;
    static ConfigureOptions(services: IServiceCollection, configureType: Type): IServiceCollection;
    static ConfigureOptions<TConfigureOptions>(services: IServiceCollection): IServiceCollection;
    static PostConfigure<TOptions>(services: IServiceCollection, configureOptions: Action<TOptions>): IServiceCollection;
    static PostConfigure<TOptions>(services: IServiceCollection, name: string, configureOptions: Action<TOptions>): IServiceCollection;
    static PostConfigureAll<TOptions>(services: IServiceCollection, configureOptions: Action<TOptions>): IServiceCollection;
}


export type OptionsServiceCollectionExtensions = OptionsServiceCollectionExtensions$instance;

export abstract class ServiceCollectionContainerBuilderExtensions$instance {
    static BuildServiceProvider(services: IServiceCollection, options: ServiceProviderOptions): ServiceProvider;
    static BuildServiceProvider(services: IServiceCollection, validateScopes: boolean): ServiceProvider;
    static BuildServiceProvider(services: IServiceCollection): ServiceProvider;
}


export type ServiceCollectionContainerBuilderExtensions = ServiceCollectionContainerBuilderExtensions$instance;

export abstract class ServiceCollectionHostedServiceExtensions$instance {
    static AddHostedService<THostedService extends IHostedService>(services: IServiceCollection, implementationFactory: Func<IServiceProvider, THostedService>): IServiceCollection;
    static AddHostedService<THostedService extends IHostedService>(services: IServiceCollection): IServiceCollection;
}


export type ServiceCollectionHostedServiceExtensions = ServiceCollectionHostedServiceExtensions$instance;

export abstract class ServiceCollectionServiceExtensions$instance {
    static AddKeyedScoped<TService>(services: IServiceCollection, serviceKey: unknown, implementationFactory: Func<IServiceProvider, unknown, TService>): IServiceCollection;
    static AddKeyedScoped<TService, TImplementation extends TService>(services: IServiceCollection, serviceKey: unknown): IServiceCollection;
    static AddKeyedScoped(services: IServiceCollection, serviceType: Type, serviceKey: unknown, implementationFactory: Func<IServiceProvider, unknown, unknown>): IServiceCollection;
    static AddKeyedScoped(services: IServiceCollection, serviceType: Type, serviceKey: unknown, implementationType: Type): IServiceCollection;
    static AddKeyedScoped(services: IServiceCollection, serviceType: Type, serviceKey: unknown): IServiceCollection;
    static AddKeyedSingleton<TService>(services: IServiceCollection, serviceKey: unknown, implementationFactory: Func<IServiceProvider, unknown, TService>): IServiceCollection;
    static AddKeyedSingleton<TService>(services: IServiceCollection, serviceKey: unknown, implementationInstance: TService): IServiceCollection;
    static AddKeyedSingleton<TService, TImplementation extends TService>(services: IServiceCollection, serviceKey: unknown): IServiceCollection;
    static AddKeyedSingleton(services: IServiceCollection, serviceType: Type, serviceKey: unknown, implementationFactory: Func<IServiceProvider, unknown, unknown>): IServiceCollection;
    static AddKeyedSingleton(services: IServiceCollection, serviceType: Type, serviceKey: unknown, implementationInstance: unknown): IServiceCollection;
    static AddKeyedSingleton(services: IServiceCollection, serviceType: Type, serviceKey: unknown, implementationType: Type): IServiceCollection;
    static AddKeyedSingleton(services: IServiceCollection, serviceType: Type, serviceKey: unknown): IServiceCollection;
    static AddKeyedTransient<TService>(services: IServiceCollection, serviceKey: unknown, implementationFactory: Func<IServiceProvider, unknown, TService>): IServiceCollection;
    static AddKeyedTransient<TService, TImplementation extends TService>(services: IServiceCollection, serviceKey: unknown): IServiceCollection;
    static AddKeyedTransient(services: IServiceCollection, serviceType: Type, serviceKey: unknown, implementationFactory: Func<IServiceProvider, unknown, unknown>): IServiceCollection;
    static AddKeyedTransient(services: IServiceCollection, serviceType: Type, serviceKey: unknown, implementationType: Type): IServiceCollection;
    static AddKeyedTransient(services: IServiceCollection, serviceType: Type, serviceKey: unknown): IServiceCollection;
    static AddScoped<TService>(services: IServiceCollection, implementationFactory: Func<IServiceProvider, TService>): IServiceCollection;
    static AddScoped(services: IServiceCollection, serviceType: Type, implementationFactory: Func<IServiceProvider, unknown>): IServiceCollection;
    static AddScoped(services: IServiceCollection, serviceType: Type, implementationType: Type): IServiceCollection;
    static AddScoped(services: IServiceCollection, serviceType: Type): IServiceCollection;
    static AddScoped<TService, TImplementation extends TService>(services: IServiceCollection): IServiceCollection;
    static AddSingleton<TService>(services: IServiceCollection, implementationFactory: Func<IServiceProvider, TService>): IServiceCollection;
    static AddSingleton(services: IServiceCollection, serviceType: Type, implementationFactory: Func<IServiceProvider, unknown>): IServiceCollection;
    static AddSingleton(services: IServiceCollection, serviceType: Type, implementationInstance: unknown): IServiceCollection;
    static AddSingleton(services: IServiceCollection, serviceType: Type, implementationType: Type): IServiceCollection;
    static AddSingleton(services: IServiceCollection, serviceType: Type): IServiceCollection;
    static AddSingleton<TService>(services: IServiceCollection, implementationInstance: TService): IServiceCollection;
    static AddSingleton<TService, TImplementation extends TService>(services: IServiceCollection): IServiceCollection;
    static AddTransient<TService>(services: IServiceCollection, implementationFactory: Func<IServiceProvider, TService>): IServiceCollection;
    static AddTransient(services: IServiceCollection, serviceType: Type, implementationFactory: Func<IServiceProvider, unknown>): IServiceCollection;
    static AddTransient(services: IServiceCollection, serviceType: Type, implementationType: Type): IServiceCollection;
    static AddTransient(services: IServiceCollection, serviceType: Type): IServiceCollection;
    static AddTransient<TService, TImplementation extends TService>(services: IServiceCollection): IServiceCollection;
}


export type ServiceCollectionServiceExtensions = ServiceCollectionServiceExtensions$instance;

export abstract class ServiceProviderKeyedServiceExtensions$instance {
    static GetKeyedService<T>(provider: IServiceProvider, serviceKey: unknown): T | undefined;
    static GetKeyedService(provider: IServiceProvider, serviceType: Type, serviceKey: unknown): unknown | undefined;
    static GetKeyedServices<T>(provider: IServiceProvider, serviceKey: unknown): IEnumerable__System_Collections_Generic<T>;
    static GetKeyedServices(provider: IServiceProvider, serviceType: Type, serviceKey: unknown): IEnumerable__System_Collections_Generic<unknown | undefined>;
    static GetRequiredKeyedService<T>(provider: IServiceProvider, serviceKey: unknown): T;
    static GetRequiredKeyedService(provider: IServiceProvider, serviceType: Type, serviceKey: unknown): unknown;
}


export type ServiceProviderKeyedServiceExtensions = ServiceProviderKeyedServiceExtensions$instance;

export abstract class ServiceProviderServiceExtensions$instance {
    static CreateAsyncScope(serviceScopeFactory: IServiceScopeFactory): AsyncServiceScope;
    static CreateAsyncScope(provider: IServiceProvider): AsyncServiceScope;
    static CreateScope(provider: IServiceProvider): IServiceScope;
    static GetRequiredService(provider: IServiceProvider, serviceType: Type): unknown;
    static GetRequiredService<T>(provider: IServiceProvider): T;
    static GetService<T>(provider: IServiceProvider): T | undefined;
    static GetServices(provider: IServiceProvider, serviceType: Type): IEnumerable__System_Collections_Generic<unknown | undefined>;
    static GetServices<T>(provider: IServiceProvider): IEnumerable__System_Collections_Generic<T>;
}


export type ServiceProviderServiceExtensions = ServiceProviderServiceExtensions$instance;

export abstract class SocketsHttpHandlerBuilderExtensions$instance {
    static Configure(builder: ISocketsHttpHandlerBuilder, configuration: IConfiguration): ISocketsHttpHandlerBuilder;
    static Configure(builder: ISocketsHttpHandlerBuilder, configure: Action<SocketsHttpHandler, IServiceProvider>): ISocketsHttpHandlerBuilder;
}


export type SocketsHttpHandlerBuilderExtensions = SocketsHttpHandlerBuilderExtensions$instance;

export abstract class ValidationServiceCollectionExtensions$instance {
    static AddValidation(services: IServiceCollection, configureOptions?: Action<ValidationOptions>): IServiceCollection;
}


export type ValidationServiceCollectionExtensions = ValidationServiceCollectionExtensions$instance;

