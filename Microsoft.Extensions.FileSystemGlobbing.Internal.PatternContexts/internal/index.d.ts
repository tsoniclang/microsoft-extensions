// Generated by tsbindgen - Architecture
// Namespace: Microsoft.Extensions.FileSystemGlobbing.Internal.PatternContexts
// Assembly: Microsoft.Extensions.FileSystemGlobbing

// Primitive type aliases from @tsonic/core
import type { sbyte, byte, short, ushort, int, uint, long, ulong, int128, uint128, half, float, double, decimal, nint, nuint, char } from '@tsonic/core/types.js';

// Import types from other namespaces
import type { DirectoryInfoBase, FileInfoBase, FileSystemInfoBase } from "../../Microsoft.Extensions.FileSystemGlobbing.Abstractions/internal/index.js";
import * as Microsoft_Extensions_FileSystemGlobbing_Internal_Internal from "../../Microsoft.Extensions.FileSystemGlobbing.Internal/internal/index.js";
import type { ILinearPattern, IPathSegment, IPatternContext, IRaggedPattern, PatternTestResult } from "../../Microsoft.Extensions.FileSystemGlobbing.Internal/internal/index.js";
import type { IList } from "@tsonic/dotnet/System.Collections.Generic.js";
import * as System_Internal from "@tsonic/dotnet/System.js";
import type { Action, Boolean as ClrBoolean, Int32, Object as ClrObject, String as ClrString, ValueType, Void } from "@tsonic/dotnet/System.js";

export interface PatternContextLinear_FrameData$instance {
    IsNotApplicable: boolean;
    SegmentIndex: int;
    InStem: boolean;
    readonly Stem: string;
    readonly StemItems: IList<System_Internal.String>;
}


export const PatternContextLinear_FrameData: {
    new(): PatternContextLinear_FrameData;
};


export type PatternContextLinear_FrameData = PatternContextLinear_FrameData$instance;

export interface PatternContextRagged_FrameData$instance {
    IsNotApplicable: boolean;
    SegmentGroupIndex: int;
    SegmentGroup: IList<IPathSegment>;
    BacktrackAvailable: int;
    SegmentIndex: int;
    InStem: boolean;
    readonly Stem: string;
    readonly StemItems: IList<System_Internal.String>;
}


export const PatternContextRagged_FrameData: {
    new(): PatternContextRagged_FrameData;
};


export type PatternContextRagged_FrameData = PatternContextRagged_FrameData$instance;

export interface PatternContext_1$instance<TFrame extends unknown> {
    Declare(declare: Action<IPathSegment, System_Internal.Boolean>): void;
    PopDirectory(): void;
    PushDirectory(directory: DirectoryInfoBase): void;
    Test(file: FileInfoBase): PatternTestResult;
    Test(directory: DirectoryInfoBase): boolean;
}


export const PatternContext_1: {
    new<TFrame extends unknown>(): PatternContext_1<TFrame>;
};


export interface __PatternContext_1$views<TFrame extends unknown> {
    As_IPatternContext(): Microsoft_Extensions_FileSystemGlobbing_Internal_Internal.IPatternContext$instance;
}

export type PatternContext_1<TFrame> = PatternContext_1$instance<TFrame> & __PatternContext_1$views<TFrame>;


export interface PatternContextLinear$instance extends PatternContext_1$instance<PatternContextLinear_FrameData> {
    Declare(declare: Action<IPathSegment, System_Internal.Boolean>): void;
    PopDirectory(): void;
    PushDirectory(directory: DirectoryInfoBase): void;
    Test(file: FileInfoBase): PatternTestResult;
    Test(directory: DirectoryInfoBase): boolean;
}


export const PatternContextLinear: {
    new(pattern: ILinearPattern): PatternContextLinear;
};


export interface __PatternContextLinear$views {
    As_IPatternContext(): Microsoft_Extensions_FileSystemGlobbing_Internal_Internal.IPatternContext$instance;
}

export type PatternContextLinear = PatternContextLinear$instance & __PatternContextLinear$views;


export interface PatternContextLinearExclude$instance extends PatternContextLinear$instance {
    Declare(onDeclare: Action<IPathSegment, System_Internal.Boolean>): void;
    PopDirectory(): void;
    PushDirectory(directory: DirectoryInfoBase): void;
    Test(directory: DirectoryInfoBase): boolean;
    Test(file: FileInfoBase): PatternTestResult;
}


export const PatternContextLinearExclude: {
    new(pattern: ILinearPattern): PatternContextLinearExclude;
};


export interface __PatternContextLinearExclude$views {
    As_IPatternContext(): Microsoft_Extensions_FileSystemGlobbing_Internal_Internal.IPatternContext$instance;
}

export type PatternContextLinearExclude = PatternContextLinearExclude$instance & __PatternContextLinearExclude$views;


export interface PatternContextLinearInclude$instance extends PatternContextLinear$instance {
    Declare(onDeclare: Action<IPathSegment, System_Internal.Boolean>): void;
    Declare(onDeclare: Action<IPathSegment, System_Internal.Boolean>): void;
    PopDirectory(): void;
    PushDirectory(directory: DirectoryInfoBase): void;
    Test(directory: DirectoryInfoBase): boolean;
    Test(file: FileInfoBase): PatternTestResult;
}


export const PatternContextLinearInclude: {
    new(pattern: ILinearPattern): PatternContextLinearInclude;
};


export interface __PatternContextLinearInclude$views {
    As_IPatternContext(): Microsoft_Extensions_FileSystemGlobbing_Internal_Internal.IPatternContext$instance;
}

export type PatternContextLinearInclude = PatternContextLinearInclude$instance & __PatternContextLinearInclude$views;


export interface PatternContextRagged$instance extends PatternContext_1$instance<PatternContextRagged_FrameData> {
    Declare(declare: Action<IPathSegment, System_Internal.Boolean>): void;
    PopDirectory(): void;
    PushDirectory(directory: DirectoryInfoBase): void;
    Test(file: FileInfoBase): PatternTestResult;
    Test(directory: DirectoryInfoBase): boolean;
}


export const PatternContextRagged: {
    new(pattern: IRaggedPattern): PatternContextRagged;
};


export interface __PatternContextRagged$views {
    As_IPatternContext(): Microsoft_Extensions_FileSystemGlobbing_Internal_Internal.IPatternContext$instance;
}

export type PatternContextRagged = PatternContextRagged$instance & __PatternContextRagged$views;


export interface PatternContextRaggedExclude$instance extends PatternContextRagged$instance {
    Declare(onDeclare: Action<IPathSegment, System_Internal.Boolean>): void;
    PopDirectory(): void;
    PushDirectory(directory: DirectoryInfoBase): void;
    Test(directory: DirectoryInfoBase): boolean;
    Test(file: FileInfoBase): PatternTestResult;
}


export const PatternContextRaggedExclude: {
    new(pattern: IRaggedPattern): PatternContextRaggedExclude;
};


export interface __PatternContextRaggedExclude$views {
    As_IPatternContext(): Microsoft_Extensions_FileSystemGlobbing_Internal_Internal.IPatternContext$instance;
}

export type PatternContextRaggedExclude = PatternContextRaggedExclude$instance & __PatternContextRaggedExclude$views;


export interface PatternContextRaggedInclude$instance extends PatternContextRagged$instance {
    Declare(onDeclare: Action<IPathSegment, System_Internal.Boolean>): void;
    Declare(onDeclare: Action<IPathSegment, System_Internal.Boolean>): void;
    PopDirectory(): void;
    PushDirectory(directory: DirectoryInfoBase): void;
    Test(directory: DirectoryInfoBase): boolean;
    Test(file: FileInfoBase): PatternTestResult;
}


export const PatternContextRaggedInclude: {
    new(pattern: IRaggedPattern): PatternContextRaggedInclude;
};


export interface __PatternContextRaggedInclude$views {
    As_IPatternContext(): Microsoft_Extensions_FileSystemGlobbing_Internal_Internal.IPatternContext$instance;
}

export type PatternContextRaggedInclude = PatternContextRaggedInclude$instance & __PatternContextRaggedInclude$views;


