// Generated by tsbindgen - Architecture
// Namespace: Microsoft.Extensions.Caching.Memory
// Assembly: Microsoft.Extensions.Caching.Abstractions, Microsoft.Extensions.Caching.Memory

// Primitive type aliases from @tsonic/core
import type { sbyte, byte, short, ushort, int, uint, long, ulong, int128, uint128, half, float, double, decimal, nint, nuint, char } from '@tsonic/core/types.js';

// Import support types from @tsonic/core
import type { ptr } from "@tsonic/core/types.js";

// Import types from other namespaces
import type { ISystemClock } from "../../Microsoft.Extensions.Internal/internal/index.js";
import type { ILoggerFactory } from "../../Microsoft.Extensions.Logging/internal/index.js";
import * as Microsoft_Extensions_Options_Internal from "../../Microsoft.Extensions.Options/internal/index.js";
import type { IOptions_1 } from "../../Microsoft.Extensions.Options/internal/index.js";
import type { IChangeToken } from "../../Microsoft.Extensions.Primitives/internal/index.js";
import type { IEnumerable, IList } from "@tsonic/dotnet/System.Collections.Generic.js";
import * as System_Internal from "@tsonic/dotnet/System.js";
import type { AsyncCallback, Boolean as ClrBoolean, Char, DateTimeOffset, Double, Enum, Func, IAsyncResult, ICloneable, IComparable, IConvertible, IDisposable, IFormattable, Int32, Int64, IntPtr, ISpanFormattable, MulticastDelegate, Nullable, Object as ClrObject, ReadOnlySpan, TimeSpan, Void } from "@tsonic/dotnet/System.js";
import * as System_Runtime_Serialization_Internal from "@tsonic/dotnet/System.Runtime.Serialization.js";
import type { ISerializable } from "@tsonic/dotnet/System.Runtime.Serialization.js";
import type { Task } from "@tsonic/dotnet/System.Threading.Tasks.js";

export enum CacheItemPriority {
    low = 0,
    normal = 1,
    high = 2,
    neverRemove = 3
}


export enum EvictionReason {
    none = 0,
    removed = 1,
    replaced = 2,
    expired = 3,
    tokenExpired = 4,
    capacity = 5
}


export type PostEvictionDelegate = (key: unknown, value: unknown, reason: EvictionReason, state: unknown) => void;


export interface ICacheEntry$instance extends IDisposable {
    readonly key: unknown;
    get value(): unknown | undefined;
    set value(value: unknown);
    absoluteExpiration: Nullable<DateTimeOffset>;
    absoluteExpirationRelativeToNow: Nullable<TimeSpan>;
    slidingExpiration: Nullable<TimeSpan>;
    readonly expirationTokens: IList<IChangeToken>;
    readonly postEvictionCallbacks: IList<PostEvictionCallbackRegistration>;
    priority: CacheItemPriority;
    size: Nullable<System_Internal.Int64>;
}


export type ICacheEntry = ICacheEntry$instance;

export interface IMemoryCache$instance extends IDisposable {
    createEntry(key: unknown): ICacheEntry;
    getCurrentStatistics(): MemoryCacheStatistics | undefined;
    remove(key: unknown): void;
    tryGetValue(key: unknown, value: unknown): boolean;
}


export type IMemoryCache = IMemoryCache$instance;

export interface MemoryCache$instance {
    readonly count: int;
    readonly keys: IEnumerable<unknown>;
    clear(): void;
    compact(percentage: double): void;
    createEntry(key: unknown): ICacheEntry;
    dispose(): void;
    getCurrentStatistics(): MemoryCacheStatistics | undefined;
    remove(key: unknown): void;
    tryGetValue(key: unknown, result: unknown): boolean;
    tryGetValue(key: ReadOnlySpan<System_Internal.Char>, value: unknown): boolean;
    tryGetValue<TItem>(key: ReadOnlySpan<System_Internal.Char>, value: TItem): boolean;
}


export const MemoryCache: {
    new(optionsAccessor: IOptions_1<MemoryCacheOptions>): MemoryCache;
    new(optionsAccessor: IOptions_1<MemoryCacheOptions>, loggerFactory: ILoggerFactory): MemoryCache;
};


export interface __MemoryCache$views {
    As_IMemoryCache(): IMemoryCache$instance;
}

export type MemoryCache = MemoryCache$instance & __MemoryCache$views;


export interface MemoryCacheEntryOptions$instance {
    absoluteExpiration: Nullable<DateTimeOffset>;
    absoluteExpirationRelativeToNow: Nullable<TimeSpan>;
    readonly expirationTokens: IList<IChangeToken>;
    readonly postEvictionCallbacks: IList<PostEvictionCallbackRegistration>;
    priority: CacheItemPriority;
    size: Nullable<System_Internal.Int64>;
    slidingExpiration: Nullable<TimeSpan>;
}


export const MemoryCacheEntryOptions: {
    new(): MemoryCacheEntryOptions;
};


export type MemoryCacheEntryOptions = MemoryCacheEntryOptions$instance;

export interface MemoryCacheOptions$instance {
    get clock(): ISystemClock | undefined;
    set clock(value: ISystemClock);
    compactionPercentage: double;
    compactOnMemoryPressure: boolean;
    expirationScanFrequency: TimeSpan;
    sizeLimit: Nullable<System_Internal.Int64>;
    trackLinkedCacheEntries: boolean;
    trackStatistics: boolean;
}


export const MemoryCacheOptions: {
    new(): MemoryCacheOptions;
};


export interface __MemoryCacheOptions$views {
    As_IOptions_1(): Microsoft_Extensions_Options_Internal.IOptions_1$instance<MemoryCacheOptions>;
}

export interface MemoryCacheOptions$instance extends Microsoft_Extensions_Options_Internal.IOptions_1$instance<MemoryCacheOptions> {}

export type MemoryCacheOptions = MemoryCacheOptions$instance & __MemoryCacheOptions$views;


export interface MemoryCacheStatistics$instance {
    currentEntryCount: long;
    currentEstimatedSize: Nullable<System_Internal.Int64>;
    totalHits: long;
    totalMisses: long;
}


export const MemoryCacheStatistics: {
    new(): MemoryCacheStatistics;
};


export type MemoryCacheStatistics = MemoryCacheStatistics$instance;

export interface MemoryDistributedCacheOptions$instance extends MemoryCacheOptions$instance {
}


export const MemoryDistributedCacheOptions: {
    new(): MemoryDistributedCacheOptions;
};


export interface __MemoryDistributedCacheOptions$views {
    As_IOptions_1(): Microsoft_Extensions_Options_Internal.IOptions_1$instance<MemoryCacheOptions>;
}

export interface MemoryDistributedCacheOptions$instance extends Microsoft_Extensions_Options_Internal.IOptions_1$instance<MemoryCacheOptions> {}

export type MemoryDistributedCacheOptions = MemoryDistributedCacheOptions$instance & __MemoryDistributedCacheOptions$views;


export interface PostEvictionCallbackRegistration$instance {
    get evictionCallback(): PostEvictionDelegate | undefined;
    set evictionCallback(value: PostEvictionDelegate);
    get state(): unknown | undefined;
    set state(value: unknown);
}


export const PostEvictionCallbackRegistration: {
    new(): PostEvictionCallbackRegistration;
};


export type PostEvictionCallbackRegistration = PostEvictionCallbackRegistration$instance;

export abstract class CacheEntryExtensions$instance {
    static addExpirationToken(entry: ICacheEntry, expirationToken: IChangeToken): ICacheEntry;
    static registerPostEvictionCallback(entry: ICacheEntry, callback: PostEvictionDelegate, state: unknown): ICacheEntry;
    static registerPostEvictionCallback(entry: ICacheEntry, callback: PostEvictionDelegate): ICacheEntry;
    static setAbsoluteExpiration(entry: ICacheEntry, absolute: DateTimeOffset): ICacheEntry;
    static setAbsoluteExpiration(entry: ICacheEntry, relative: TimeSpan): ICacheEntry;
    static setOptions(entry: ICacheEntry, options: MemoryCacheEntryOptions): ICacheEntry;
    static setPriority(entry: ICacheEntry, priority: CacheItemPriority): ICacheEntry;
    static setSize(entry: ICacheEntry, size: long): ICacheEntry;
    static setSlidingExpiration(entry: ICacheEntry, offset: TimeSpan): ICacheEntry;
    static setValue(entry: ICacheEntry, value: unknown): ICacheEntry;
}


export type CacheEntryExtensions = CacheEntryExtensions$instance;

export abstract class CacheExtensions$instance {
    static get(cache: IMemoryCache, key: unknown): unknown | undefined;
    static get<TItem>(cache: IMemoryCache, key: unknown): TItem | undefined;
    static getOrCreate<TItem>(cache: IMemoryCache, key: unknown, factory: Func<ICacheEntry, TItem>, createOptions: MemoryCacheEntryOptions): TItem | undefined;
    static getOrCreate<TItem>(cache: IMemoryCache, key: unknown, factory: Func<ICacheEntry, TItem>): TItem | undefined;
    static getOrCreateAsync<TItem>(cache: IMemoryCache, key: unknown, factory: Func<ICacheEntry, Task<TItem>>, createOptions: MemoryCacheEntryOptions): Task<TItem | undefined>;
    static getOrCreateAsync<TItem>(cache: IMemoryCache, key: unknown, factory: Func<ICacheEntry, Task<TItem>>): Task<TItem | undefined>;
    static set<TItem>(cache: IMemoryCache, key: unknown, value: TItem, options: MemoryCacheEntryOptions): TItem;
    static set<TItem>(cache: IMemoryCache, key: unknown, value: TItem, expirationToken: IChangeToken): TItem;
    static set<TItem>(cache: IMemoryCache, key: unknown, value: TItem, absoluteExpiration: DateTimeOffset): TItem;
    static set<TItem>(cache: IMemoryCache, key: unknown, value: TItem, absoluteExpirationRelativeToNow: TimeSpan): TItem;
    static set<TItem>(cache: IMemoryCache, key: unknown, value: TItem): TItem;
    static tryGetValue<TItem>(cache: IMemoryCache, key: unknown, value: TItem): boolean;
}


export type CacheExtensions = CacheExtensions$instance;

export abstract class MemoryCacheEntryExtensions$instance {
    static addExpirationToken(options: MemoryCacheEntryOptions, expirationToken: IChangeToken): MemoryCacheEntryOptions;
    static registerPostEvictionCallback(options: MemoryCacheEntryOptions, callback: PostEvictionDelegate, state: unknown): MemoryCacheEntryOptions;
    static registerPostEvictionCallback(options: MemoryCacheEntryOptions, callback: PostEvictionDelegate): MemoryCacheEntryOptions;
    static setAbsoluteExpiration(options: MemoryCacheEntryOptions, absolute: DateTimeOffset): MemoryCacheEntryOptions;
    static setAbsoluteExpiration(options: MemoryCacheEntryOptions, relative: TimeSpan): MemoryCacheEntryOptions;
    static setPriority(options: MemoryCacheEntryOptions, priority: CacheItemPriority): MemoryCacheEntryOptions;
    static setSize(options: MemoryCacheEntryOptions, size: long): MemoryCacheEntryOptions;
    static setSlidingExpiration(options: MemoryCacheEntryOptions, offset: TimeSpan): MemoryCacheEntryOptions;
}


export type MemoryCacheEntryExtensions = MemoryCacheEntryExtensions$instance;

