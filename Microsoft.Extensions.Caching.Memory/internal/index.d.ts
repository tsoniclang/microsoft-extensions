// Generated by tsbindgen - Architecture
// Namespace: Microsoft.Extensions.Caching.Memory
// Assembly: Microsoft.Extensions.Caching.Abstractions, Microsoft.Extensions.Caching.Memory

// Primitive type aliases from @tsonic/core
import type { sbyte, byte, short, ushort, int, uint, long, ulong, int128, uint128, half, float, double, decimal, nint, nuint, char } from '@tsonic/core/types.js';

// Import support types from @tsonic/core
import type { ptr } from "@tsonic/core/types.js";

// Import types from other namespaces
import type { ISystemClock } from "../../Microsoft.Extensions.Internal/internal/index.js";
import type { ILoggerFactory } from "../../Microsoft.Extensions.Logging/internal/index.js";
import * as Microsoft_Extensions_Options_Internal from "../../Microsoft.Extensions.Options/internal/index.js";
import type { IOptions_1 } from "../../Microsoft.Extensions.Options/internal/index.js";
import type { IChangeToken } from "../../Microsoft.Extensions.Primitives/internal/index.js";
import type { IEnumerable, IList } from "@tsonic/dotnet/System.Collections.Generic.js";
import * as System_Internal from "@tsonic/dotnet/System.js";
import type { AsyncCallback, Boolean as ClrBoolean, Char, DateTimeOffset, Double, Enum, Func, IAsyncResult, ICloneable, IComparable, IConvertible, IDisposable, IFormattable, Int32, Int64, IntPtr, ISpanFormattable, MulticastDelegate, Nullable, Object as ClrObject, ReadOnlySpan, TimeSpan, Void } from "@tsonic/dotnet/System.js";
import * as System_Runtime_Serialization_Internal from "@tsonic/dotnet/System.Runtime.Serialization.js";
import type { ISerializable } from "@tsonic/dotnet/System.Runtime.Serialization.js";
import type { Task } from "@tsonic/dotnet/System.Threading.Tasks.js";

export enum CacheItemPriority {
    Low = 0,
    Normal = 1,
    High = 2,
    NeverRemove = 3
}


export enum EvictionReason {
    None = 0,
    Removed = 1,
    Replaced = 2,
    Expired = 3,
    TokenExpired = 4,
    Capacity = 5
}


export type PostEvictionDelegate = (key: unknown, value: unknown, reason: EvictionReason, state: unknown) => void;


export interface ICacheEntry$instance extends IDisposable {
    readonly Key: unknown;
    get Value(): unknown | undefined;
    set Value(value: unknown);
    AbsoluteExpiration: Nullable<DateTimeOffset>;
    AbsoluteExpirationRelativeToNow: Nullable<TimeSpan>;
    SlidingExpiration: Nullable<TimeSpan>;
    readonly ExpirationTokens: IList<IChangeToken>;
    readonly PostEvictionCallbacks: IList<PostEvictionCallbackRegistration>;
    Priority: CacheItemPriority;
    Size: Nullable<System_Internal.Int64>;
}


export type ICacheEntry = ICacheEntry$instance;

export interface IMemoryCache$instance extends IDisposable {
    CreateEntry(key: unknown): ICacheEntry;
    GetCurrentStatistics(): MemoryCacheStatistics | undefined;
    Remove(key: unknown): void;
    TryGetValue(key: unknown, value: unknown): boolean;
}


export type IMemoryCache = IMemoryCache$instance;

export abstract class MemoryCache$protected {
    protected Dispose(disposing: boolean): void;
    protected Finalize(): void;
}


export interface MemoryCache$instance extends MemoryCache$protected {
    readonly Count: int;
    readonly Keys: IEnumerable<unknown>;
    Clear(): void;
    Compact(percentage: double): void;
    CreateEntry(key: unknown): ICacheEntry;
    Dispose(): void;
    GetCurrentStatistics(): MemoryCacheStatistics | undefined;
    Remove(key: unknown): void;
    TryGetValue(key: unknown, result: unknown): boolean;
    TryGetValue(key: ReadOnlySpan<System_Internal.Char>, value: unknown): boolean;
    TryGetValue<TItem>(key: ReadOnlySpan<System_Internal.Char>, value: TItem): boolean;
}


export const MemoryCache: {
    new(optionsAccessor: IOptions_1<MemoryCacheOptions>): MemoryCache;
    new(optionsAccessor: IOptions_1<MemoryCacheOptions>, loggerFactory: ILoggerFactory): MemoryCache;
};


export interface __MemoryCache$views {
    As_IMemoryCache(): IMemoryCache$instance;
}

export type MemoryCache = MemoryCache$instance & __MemoryCache$views;


export interface MemoryCacheEntryOptions$instance {
    AbsoluteExpiration: Nullable<DateTimeOffset>;
    AbsoluteExpirationRelativeToNow: Nullable<TimeSpan>;
    readonly ExpirationTokens: IList<IChangeToken>;
    readonly PostEvictionCallbacks: IList<PostEvictionCallbackRegistration>;
    Priority: CacheItemPriority;
    Size: Nullable<System_Internal.Int64>;
    SlidingExpiration: Nullable<TimeSpan>;
}


export const MemoryCacheEntryOptions: {
    new(): MemoryCacheEntryOptions;
};


export type MemoryCacheEntryOptions = MemoryCacheEntryOptions$instance;

export interface MemoryCacheOptions$instance {
    get Clock(): ISystemClock | undefined;
    set Clock(value: ISystemClock);
    CompactionPercentage: double;
    CompactOnMemoryPressure: boolean;
    ExpirationScanFrequency: TimeSpan;
    SizeLimit: Nullable<System_Internal.Int64>;
    TrackLinkedCacheEntries: boolean;
    TrackStatistics: boolean;
}


export const MemoryCacheOptions: {
    new(): MemoryCacheOptions;
};


export interface __MemoryCacheOptions$views {
    As_IOptions_1(): Microsoft_Extensions_Options_Internal.IOptions_1$instance<MemoryCacheOptions>;
}

export interface MemoryCacheOptions$instance extends Microsoft_Extensions_Options_Internal.IOptions_1$instance<MemoryCacheOptions> {}

export type MemoryCacheOptions = MemoryCacheOptions$instance & __MemoryCacheOptions$views;


export interface MemoryCacheStatistics$instance {
    CurrentEntryCount: long;
    CurrentEstimatedSize: Nullable<System_Internal.Int64>;
    TotalHits: long;
    TotalMisses: long;
}


export const MemoryCacheStatistics: {
    new(): MemoryCacheStatistics;
};


export type MemoryCacheStatistics = MemoryCacheStatistics$instance;

export interface MemoryDistributedCacheOptions$instance extends MemoryCacheOptions$instance {
}


export const MemoryDistributedCacheOptions: {
    new(): MemoryDistributedCacheOptions;
};


export interface __MemoryDistributedCacheOptions$views {
    As_IOptions_1(): Microsoft_Extensions_Options_Internal.IOptions_1$instance<MemoryCacheOptions>;
}

export interface MemoryDistributedCacheOptions$instance extends Microsoft_Extensions_Options_Internal.IOptions_1$instance<MemoryCacheOptions> {}

export type MemoryDistributedCacheOptions = MemoryDistributedCacheOptions$instance & __MemoryDistributedCacheOptions$views;


export interface PostEvictionCallbackRegistration$instance {
    get EvictionCallback(): PostEvictionDelegate | undefined;
    set EvictionCallback(value: PostEvictionDelegate);
    get State(): unknown | undefined;
    set State(value: unknown);
}


export const PostEvictionCallbackRegistration: {
    new(): PostEvictionCallbackRegistration;
};


export type PostEvictionCallbackRegistration = PostEvictionCallbackRegistration$instance;

export abstract class CacheEntryExtensions$instance {
    static AddExpirationToken(entry: ICacheEntry, expirationToken: IChangeToken): ICacheEntry;
    static RegisterPostEvictionCallback(entry: ICacheEntry, callback: PostEvictionDelegate, state: unknown): ICacheEntry;
    static RegisterPostEvictionCallback(entry: ICacheEntry, callback: PostEvictionDelegate): ICacheEntry;
    static SetAbsoluteExpiration(entry: ICacheEntry, absolute: DateTimeOffset): ICacheEntry;
    static SetAbsoluteExpiration(entry: ICacheEntry, relative: TimeSpan): ICacheEntry;
    static SetOptions(entry: ICacheEntry, options: MemoryCacheEntryOptions): ICacheEntry;
    static SetPriority(entry: ICacheEntry, priority: CacheItemPriority): ICacheEntry;
    static SetSize(entry: ICacheEntry, size: long): ICacheEntry;
    static SetSlidingExpiration(entry: ICacheEntry, offset: TimeSpan): ICacheEntry;
    static SetValue(entry: ICacheEntry, value: unknown): ICacheEntry;
}


export type CacheEntryExtensions = CacheEntryExtensions$instance;

export abstract class CacheExtensions$instance {
    static Get(cache: IMemoryCache, key: unknown): unknown | undefined;
    static Get<TItem>(cache: IMemoryCache, key: unknown): TItem | undefined;
    static GetOrCreate<TItem>(cache: IMemoryCache, key: unknown, factory: Func<ICacheEntry, TItem>, createOptions: MemoryCacheEntryOptions): TItem | undefined;
    static GetOrCreate<TItem>(cache: IMemoryCache, key: unknown, factory: Func<ICacheEntry, TItem>): TItem | undefined;
    static GetOrCreateAsync<TItem>(cache: IMemoryCache, key: unknown, factory: Func<ICacheEntry, Task<TItem>>, createOptions: MemoryCacheEntryOptions): Task<TItem | undefined>;
    static GetOrCreateAsync<TItem>(cache: IMemoryCache, key: unknown, factory: Func<ICacheEntry, Task<TItem>>): Task<TItem | undefined>;
    static Set<TItem>(cache: IMemoryCache, key: unknown, value: TItem, options: MemoryCacheEntryOptions): TItem;
    static Set<TItem>(cache: IMemoryCache, key: unknown, value: TItem, expirationToken: IChangeToken): TItem;
    static Set<TItem>(cache: IMemoryCache, key: unknown, value: TItem, absoluteExpiration: DateTimeOffset): TItem;
    static Set<TItem>(cache: IMemoryCache, key: unknown, value: TItem, absoluteExpirationRelativeToNow: TimeSpan): TItem;
    static Set<TItem>(cache: IMemoryCache, key: unknown, value: TItem): TItem;
    static TryGetValue<TItem>(cache: IMemoryCache, key: unknown, value: TItem): boolean;
}


export type CacheExtensions = CacheExtensions$instance;

export abstract class MemoryCacheEntryExtensions$instance {
    static AddExpirationToken(options: MemoryCacheEntryOptions, expirationToken: IChangeToken): MemoryCacheEntryOptions;
    static RegisterPostEvictionCallback(options: MemoryCacheEntryOptions, callback: PostEvictionDelegate, state: unknown): MemoryCacheEntryOptions;
    static RegisterPostEvictionCallback(options: MemoryCacheEntryOptions, callback: PostEvictionDelegate): MemoryCacheEntryOptions;
    static SetAbsoluteExpiration(options: MemoryCacheEntryOptions, absolute: DateTimeOffset): MemoryCacheEntryOptions;
    static SetAbsoluteExpiration(options: MemoryCacheEntryOptions, relative: TimeSpan): MemoryCacheEntryOptions;
    static SetPriority(options: MemoryCacheEntryOptions, priority: CacheItemPriority): MemoryCacheEntryOptions;
    static SetSize(options: MemoryCacheEntryOptions, size: long): MemoryCacheEntryOptions;
    static SetSlidingExpiration(options: MemoryCacheEntryOptions, offset: TimeSpan): MemoryCacheEntryOptions;
}


export type MemoryCacheEntryExtensions = MemoryCacheEntryExtensions$instance;

