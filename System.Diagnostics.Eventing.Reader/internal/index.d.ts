// Generated by tsbindgen - Architecture
// Namespace: System.Diagnostics.Eventing.Reader
// Assembly: System.Diagnostics.EventLog

// Primitive type aliases from @tsonic/core
import type { sbyte, byte, short, ushort, int, uint, long, ulong, int128, uint128, half, float, double, decimal, nint, nuint, char } from '@tsonic/core/types.js';

// Import types from other namespaces
import type { IEnumerable, IList } from "@tsonic/dotnet/System.Collections.Generic.js";
import type { CultureInfo } from "@tsonic/dotnet/System.Globalization.js";
import type { SeekOrigin } from "@tsonic/dotnet/System.IO.js";
import * as System_Internal from "@tsonic/dotnet/System.js";
import type { Boolean as ClrBoolean, Byte, DateTime, Enum, EventArgs, EventHandler, Exception, Guid, IComparable, IConvertible, IDisposable, IFormattable, Int16, Int32, Int64, ISpanFormattable, Nullable, Object as ClrObject, String as ClrString, TimeSpan, Uri, Void } from "@tsonic/dotnet/System.js";
import * as System_Runtime_Serialization_Internal from "@tsonic/dotnet/System.Runtime.Serialization.js";
import type { ISerializable, SerializationInfo, StreamingContext } from "@tsonic/dotnet/System.Runtime.Serialization.js";
import type { SecureString } from "@tsonic/dotnet/System.Security.js";
import type { SecurityIdentifier } from "@tsonic/dotnet/System.Security.Principal.js";

export enum EventLogIsolation {
    Application = 0,
    System = 1,
    Custom = 2
}


export enum EventLogMode {
    Circular = 0,
    AutoBackup = 1,
    Retain = 2
}


export enum EventLogType {
    Administrative = 0,
    Operational = 1,
    Analytical = 2,
    Debug = 3
}


export enum PathType {
    LogName = 1,
    FilePath = 2
}


export enum SessionAuthentication {
    Default = 0,
    Negotiate = 1,
    Kerberos = 2,
    Ntlm = 3
}


export enum StandardEventKeywords {
    None = 0,
    ResponseTime = 281474976710656,
    WdiContext = 562949953421312,
    WdiDiagnostic = 1125899906842624,
    Sqm = 2251799813685248,
    AuditFailure = 4503599627370496,
    CorrelationHint = 4503599627370496,
    AuditSuccess = 9007199254740992,
    CorrelationHint2 = 18014398509481984,
    EventLogClassic = 36028797018963968
}


export enum StandardEventLevel {
    LogAlways = 0,
    Critical = 1,
    Error = 2,
    Warning = 3,
    Informational = 4,
    Verbose = 5
}


export enum StandardEventOpcode {
    Info = 0,
    Start = 1,
    Stop = 2,
    DataCollectionStart = 3,
    DataCollectionStop = 4,
    Extension = 5,
    Reply = 6,
    Resume = 7,
    Suspend = 8,
    Send = 9,
    Receive = 240
}


export enum StandardEventTask {
    None = 0
}


export interface EventBookmark$instance {
    readonly BookmarkXml: string;
}


export const EventBookmark: {
    new(bookmarkXml: string): EventBookmark;
};


export type EventBookmark = EventBookmark$instance;

export interface EventKeyword$instance {
    readonly DisplayName: string;
    readonly Name: string;
    readonly Value: long;
}


export const EventKeyword: {
    new(): EventKeyword;
};


export type EventKeyword = EventKeyword$instance;

export interface EventLevel$instance {
    readonly DisplayName: string;
    readonly Name: string;
    readonly Value: int;
}


export const EventLevel: {
    new(): EventLevel;
};


export type EventLevel = EventLevel$instance;

export abstract class EventLogConfiguration$protected {
    protected Dispose(disposing: boolean): void;
}


export interface EventLogConfiguration$instance extends EventLogConfiguration$protected {
    readonly IsClassicLog: boolean;
    IsEnabled: boolean;
    LogFilePath: string;
    readonly LogIsolation: EventLogIsolation;
    LogMode: EventLogMode;
    readonly LogName: string | undefined;
    readonly LogType: EventLogType;
    MaximumSizeInBytes: long;
    readonly OwningProviderName: string;
    readonly ProviderBufferSize: Nullable<System_Internal.Int32>;
    readonly ProviderControlGuid: Nullable<Guid>;
    ProviderKeywords: Nullable<System_Internal.Int64>;
    readonly ProviderLatency: Nullable<System_Internal.Int32>;
    ProviderLevel: Nullable<System_Internal.Int32>;
    readonly ProviderMaximumNumberOfBuffers: Nullable<System_Internal.Int32>;
    readonly ProviderMinimumNumberOfBuffers: Nullable<System_Internal.Int32>;
    readonly ProviderNames: IEnumerable<System_Internal.String>;
    SecurityDescriptor: string;
    Dispose(): void;
    SaveChanges(): void;
}


export const EventLogConfiguration: {
    new(logName: string): EventLogConfiguration;
    new(logName: string, session: EventLogSession): EventLogConfiguration;
};


export type EventLogConfiguration = EventLogConfiguration$instance;

export interface EventLogException$instance extends Exception {
    readonly Message: string;
    GetObjectData(info: SerializationInfo, context: StreamingContext): void;
}


export const EventLogException: {
    new(): EventLogException;
    new(errorCode: int): EventLogException;
    new(serializationInfo: SerializationInfo, streamingContext: StreamingContext): EventLogException;
    new(message: string): EventLogException;
    new(message: string, innerException: Exception): EventLogException;
};


export type EventLogException = EventLogException$instance;

export interface EventLogInformation$instance {
    readonly Attributes: Nullable<System_Internal.Int32>;
    readonly CreationTime: Nullable<DateTime>;
    readonly FileSize: Nullable<System_Internal.Int64>;
    readonly IsLogFull: Nullable<System_Internal.Boolean>;
    readonly LastAccessTime: Nullable<DateTime>;
    readonly LastWriteTime: Nullable<DateTime>;
    readonly OldestRecordNumber: Nullable<System_Internal.Int64>;
    readonly RecordCount: Nullable<System_Internal.Int64>;
}


export const EventLogInformation: {
    new(): EventLogInformation;
};


export type EventLogInformation = EventLogInformation$instance;

export interface EventLogInvalidDataException$instance extends EventLogException {
}


export const EventLogInvalidDataException: {
    new(): EventLogInvalidDataException;
    new(serializationInfo: SerializationInfo, streamingContext: StreamingContext): EventLogInvalidDataException;
    new(message: string): EventLogInvalidDataException;
    new(message: string, innerException: Exception): EventLogInvalidDataException;
};


export type EventLogInvalidDataException = EventLogInvalidDataException$instance;

export interface EventLogLink$instance {
    readonly DisplayName: string;
    readonly IsImported: boolean;
    readonly LogName: string | undefined;
}


export const EventLogLink: {
    new(): EventLogLink;
};


export type EventLogLink = EventLogLink$instance;

export interface EventLogNotFoundException$instance extends EventLogException {
}


export const EventLogNotFoundException: {
    new(): EventLogNotFoundException;
    new(serializationInfo: SerializationInfo, streamingContext: StreamingContext): EventLogNotFoundException;
    new(message: string): EventLogNotFoundException;
    new(message: string, innerException: Exception): EventLogNotFoundException;
};


export type EventLogNotFoundException = EventLogNotFoundException$instance;

export abstract class EventLogPropertySelector$protected {
    protected Dispose(disposing: boolean): void;
}


export interface EventLogPropertySelector$instance extends EventLogPropertySelector$protected {
    Dispose(): void;
}


export const EventLogPropertySelector: {
    new(propertyQueries: IEnumerable<System_Internal.String>): EventLogPropertySelector;
};


export type EventLogPropertySelector = EventLogPropertySelector$instance;

export interface EventLogProviderDisabledException$instance extends EventLogException {
}


export const EventLogProviderDisabledException: {
    new(): EventLogProviderDisabledException;
    new(serializationInfo: SerializationInfo, streamingContext: StreamingContext): EventLogProviderDisabledException;
    new(message: string): EventLogProviderDisabledException;
    new(message: string, innerException: Exception): EventLogProviderDisabledException;
};


export type EventLogProviderDisabledException = EventLogProviderDisabledException$instance;

export interface EventLogQuery$instance {
    ReverseDirection: boolean;
    Session: EventLogSession;
    TolerateQueryErrors: boolean;
}


export const EventLogQuery: {
    new(path: string, pathType: PathType): EventLogQuery;
    new(path: string, pathType: PathType, query: string): EventLogQuery;
};


export type EventLogQuery = EventLogQuery$instance;

export abstract class EventLogReader$protected {
    protected Dispose(disposing: boolean): void;
}


export interface EventLogReader$instance extends EventLogReader$protected {
    BatchSize: int;
    readonly LogStatus: IList<EventLogStatus>;
    CancelReading(): void;
    Dispose(): void;
    ReadEvent(): EventRecord;
    ReadEvent(timeout: TimeSpan): EventRecord;
    Seek(bookmark: EventBookmark): void;
    Seek(bookmark: EventBookmark, offset: long): void;
    Seek(origin: SeekOrigin, offset: long): void;
}


export const EventLogReader: {
    new(eventQuery: EventLogQuery): EventLogReader;
    new(eventQuery: EventLogQuery, bookmark: EventBookmark): EventLogReader;
    new(path: string): EventLogReader;
    new(path: string, pathType: PathType): EventLogReader;
};


export type EventLogReader = EventLogReader$instance;

export interface EventLogReadingException$instance extends EventLogException {
}


export const EventLogReadingException: {
    new(): EventLogReadingException;
    new(serializationInfo: SerializationInfo, streamingContext: StreamingContext): EventLogReadingException;
    new(message: string): EventLogReadingException;
    new(message: string, innerException: Exception): EventLogReadingException;
};


export type EventLogReadingException = EventLogReadingException$instance;

export abstract class EventLogRecord$protected {
    protected Dispose2(disposing: boolean): void;
}


export interface EventLogRecord$instance extends EventLogRecord$protected, EventRecord {
    readonly ActivityId: Nullable<Guid>;
    readonly Bookmark: EventBookmark;
    readonly ContainerLog: string;
    readonly Id: int;
    readonly Keywords: Nullable<System_Internal.Int64>;
    readonly KeywordsDisplayNames: IEnumerable<System_Internal.String>;
    readonly Level: Nullable<System_Internal.Byte>;
    readonly LevelDisplayName: string;
    readonly LogName: string | undefined;
    readonly MachineName: string | undefined;
    readonly MatchedQueryIds: IEnumerable<System_Internal.Int32>;
    readonly Opcode: Nullable<System_Internal.Int16>;
    readonly OpcodeDisplayName: string;
    readonly ProcessId: Nullable<System_Internal.Int32>;
    readonly Properties: IList<EventProperty>;
    readonly ProviderId: Nullable<Guid>;
    readonly ProviderName: string | undefined;
    readonly Qualifiers: Nullable<System_Internal.Int32>;
    readonly RecordId: Nullable<System_Internal.Int64>;
    readonly RelatedActivityId: Nullable<Guid>;
    readonly Task: Nullable<System_Internal.Int32>;
    readonly TaskDisplayName: string;
    readonly ThreadId: Nullable<System_Internal.Int32>;
    readonly TimeCreated: Nullable<DateTime>;
    readonly UserId: SecurityIdentifier;
    readonly Version: Nullable<System_Internal.Byte>;
    Dispose(): void;
    FormatDescription(): string;
    FormatDescription(values: IEnumerable<unknown>): string;
    GetPropertyValues(propertySelector: EventLogPropertySelector): IList<unknown>;
    ToXml(): string;
}


export const EventLogRecord: {
    new(): EventLogRecord;
};


export type EventLogRecord = EventLogRecord$instance;

export abstract class EventLogSession$protected {
    protected Dispose(disposing: boolean): void;
}


export interface EventLogSession$instance extends EventLogSession$protected {
    CancelCurrentOperations(): void;
    ClearLog(logName: string): void;
    ClearLog(logName: string, backupPath: string): void;
    Dispose(): void;
    ExportLog(path: string, pathType: PathType, query: string, targetFilePath: string): void;
    ExportLog(path: string, pathType: PathType, query: string, targetFilePath: string, tolerateQueryErrors: boolean): void;
    ExportLogAndMessages(path: string, pathType: PathType, query: string, targetFilePath: string): void;
    ExportLogAndMessages(path: string, pathType: PathType, query: string, targetFilePath: string, tolerateQueryErrors: boolean, targetCultureInfo: CultureInfo): void;
    GetLogInformation(logName: string, pathType: PathType): EventLogInformation;
    GetLogNames(): IEnumerable<System_Internal.String>;
    GetProviderNames(): IEnumerable<System_Internal.String>;
}


export const EventLogSession: {
    new(): EventLogSession;
    new(server: string): EventLogSession;
    new(server: string, domain: string, user: string, password: SecureString, logOnType: SessionAuthentication): EventLogSession;
    readonly GlobalSession: EventLogSession;
};


export type EventLogSession = EventLogSession$instance;

export interface EventLogStatus$instance {
    readonly LogName: string | undefined;
    readonly StatusCode: int;
}


export const EventLogStatus: {
    new(): EventLogStatus;
};


export type EventLogStatus = EventLogStatus$instance;

export abstract class EventLogWatcher$protected {
    protected Dispose(disposing: boolean): void;
}


export interface EventLogWatcher$instance extends EventLogWatcher$protected {
    Enabled: boolean;
    Dispose(): void;
}


export const EventLogWatcher: {
    new(eventQuery: EventLogQuery): EventLogWatcher;
    new(eventQuery: EventLogQuery, bookmark: EventBookmark): EventLogWatcher;
    new(eventQuery: EventLogQuery, bookmark: EventBookmark, readExistingEvents: boolean): EventLogWatcher;
    new(path: string): EventLogWatcher;
};


export type EventLogWatcher = EventLogWatcher$instance;

export interface EventMetadata$instance {
    readonly Description: string;
    readonly Id: long;
    readonly Keywords: IEnumerable<EventKeyword>;
    readonly Level: EventLevel;
    readonly LogLink: EventLogLink;
    readonly Opcode: EventOpcode;
    readonly Task: EventTask;
    readonly Template: string;
    readonly Version: byte;
}


export const EventMetadata: {
    new(): EventMetadata;
};


export type EventMetadata = EventMetadata$instance;

export interface EventOpcode$instance {
    readonly DisplayName: string;
    readonly Name: string;
    readonly Value: int;
}


export const EventOpcode: {
    new(): EventOpcode;
};


export type EventOpcode = EventOpcode$instance;

export interface EventProperty$instance {
    readonly Value: unknown;
}


export const EventProperty: {
    new(): EventProperty;
};


export type EventProperty = EventProperty$instance;

export abstract class EventRecord$protected {
    protected Dispose(disposing: boolean): void;
}


export interface EventRecord$instance extends EventRecord$protected {
    readonly ActivityId: Nullable<Guid>;
    readonly Bookmark: EventBookmark;
    readonly Id: int;
    readonly Keywords: Nullable<System_Internal.Int64>;
    readonly KeywordsDisplayNames: IEnumerable<System_Internal.String>;
    readonly Level: Nullable<System_Internal.Byte>;
    readonly LevelDisplayName: string;
    readonly LogName: string | undefined;
    readonly MachineName: string | undefined;
    readonly Opcode: Nullable<System_Internal.Int16>;
    readonly OpcodeDisplayName: string;
    readonly ProcessId: Nullable<System_Internal.Int32>;
    readonly Properties: IList<EventProperty>;
    readonly ProviderId: Nullable<Guid>;
    readonly ProviderName: string | undefined;
    readonly Qualifiers: Nullable<System_Internal.Int32>;
    readonly RecordId: Nullable<System_Internal.Int64>;
    readonly RelatedActivityId: Nullable<Guid>;
    readonly Task: Nullable<System_Internal.Int32>;
    readonly TaskDisplayName: string;
    readonly ThreadId: Nullable<System_Internal.Int32>;
    readonly TimeCreated: Nullable<DateTime>;
    readonly UserId: SecurityIdentifier;
    readonly Version: Nullable<System_Internal.Byte>;
    Dispose(): void;
    FormatDescription(): string;
    FormatDescription(values: IEnumerable<unknown>): string;
    ToXml(): string;
}


export const EventRecord: {
    new(): EventRecord;
};


export type EventRecord = EventRecord$instance;

export interface EventRecordWrittenEventArgs$instance extends EventArgs {
    readonly EventException: Exception;
    readonly EventRecord: EventRecord;
}


export const EventRecordWrittenEventArgs: {
    new(): EventRecordWrittenEventArgs;
};


export type EventRecordWrittenEventArgs = EventRecordWrittenEventArgs$instance;

export interface EventTask$instance {
    readonly DisplayName: string;
    readonly EventGuid: Guid;
    readonly Name: string;
    readonly Value: int;
}


export const EventTask: {
    new(): EventTask;
};


export type EventTask = EventTask$instance;

export abstract class ProviderMetadata$protected {
    protected Dispose(disposing: boolean): void;
}


export interface ProviderMetadata$instance extends ProviderMetadata$protected {
    readonly DisplayName: string;
    readonly Events: IEnumerable<EventMetadata>;
    readonly HelpLink: Uri;
    readonly Id: Guid;
    readonly Keywords: IList<EventKeyword>;
    readonly Levels: IList<EventLevel>;
    readonly LogLinks: IList<EventLogLink>;
    readonly MessageFilePath: string;
    readonly Name: string;
    readonly Opcodes: IList<EventOpcode>;
    readonly ParameterFilePath: string;
    readonly ResourceFilePath: string;
    readonly Tasks: IList<EventTask>;
    Dispose(): void;
}


export const ProviderMetadata: {
    new(providerName: string): ProviderMetadata;
    new(providerName: string, session: EventLogSession, targetCultureInfo: CultureInfo): ProviderMetadata;
};


export type ProviderMetadata = ProviderMetadata$instance;

