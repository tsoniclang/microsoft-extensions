// Generated by tsbindgen - Architecture
// Namespace: System.Diagnostics.Eventing.Reader
// Assembly: System.Diagnostics.EventLog

// Primitive type aliases from @tsonic/core
import type { sbyte, byte, short, ushort, int, uint, long, ulong, int128, uint128, half, float, double, decimal, nint, nuint, char } from '@tsonic/core/types.js';

// Import types from other namespaces
import type { IEnumerable, IList } from "@tsonic/dotnet/System.Collections.Generic.js";
import type { CultureInfo } from "@tsonic/dotnet/System.Globalization.js";
import type { SeekOrigin } from "@tsonic/dotnet/System.IO.js";
import * as System_Internal from "@tsonic/dotnet/System.js";
import type { Boolean as ClrBoolean, Byte, DateTime, Enum, EventArgs, EventHandler, Exception, Guid, IComparable, IConvertible, IDisposable, IFormattable, Int16, Int32, Int64, ISpanFormattable, Nullable, Object as ClrObject, String as ClrString, TimeSpan, Uri, Void } from "@tsonic/dotnet/System.js";
import * as System_Runtime_Serialization_Internal from "@tsonic/dotnet/System.Runtime.Serialization.js";
import type { ISerializable, SerializationInfo, StreamingContext } from "@tsonic/dotnet/System.Runtime.Serialization.js";
import type { SecureString } from "@tsonic/dotnet/System.Security.js";
import type { SecurityIdentifier } from "@tsonic/dotnet/System.Security.Principal.js";

export enum EventLogIsolation {
    application = 0,
    system = 1,
    custom = 2
}


export enum EventLogMode {
    circular = 0,
    autoBackup = 1,
    retain = 2
}


export enum EventLogType {
    administrative = 0,
    operational = 1,
    analytical = 2,
    debug = 3
}


export enum PathType {
    logName = 1,
    filePath = 2
}


export enum SessionAuthentication {
    default_ = 0,
    negotiate = 1,
    kerberos = 2,
    ntlm = 3
}


export enum StandardEventKeywords {
    none = 0,
    responseTime = 281474976710656,
    wdiContext = 562949953421312,
    wdiDiagnostic = 1125899906842624,
    sqm = 2251799813685248,
    auditFailure = 4503599627370496,
    correlationHint = 4503599627370496,
    auditSuccess = 9007199254740992,
    correlationHint2 = 18014398509481984,
    eventLogClassic = 36028797018963968
}


export enum StandardEventLevel {
    logAlways = 0,
    critical = 1,
    error = 2,
    warning = 3,
    informational = 4,
    verbose = 5
}


export enum StandardEventOpcode {
    info = 0,
    start = 1,
    stop = 2,
    dataCollectionStart = 3,
    dataCollectionStop = 4,
    extension = 5,
    reply = 6,
    resume = 7,
    suspend = 8,
    send = 9,
    receive = 240
}


export enum StandardEventTask {
    none = 0
}


export interface EventBookmark$instance {
    readonly bookmarkXml: string;
}


export const EventBookmark: {
    new(bookmarkXml: string): EventBookmark;
};


export type EventBookmark = EventBookmark$instance;

export interface EventKeyword$instance {
    readonly displayName: string;
    readonly name: string;
    readonly value: long;
}


export const EventKeyword: {
    new(): EventKeyword;
};


export type EventKeyword = EventKeyword$instance;

export interface EventLevel$instance {
    readonly displayName: string;
    readonly name: string;
    readonly value: int;
}


export const EventLevel: {
    new(): EventLevel;
};


export type EventLevel = EventLevel$instance;

export interface EventLogConfiguration$instance {
    readonly isClassicLog: boolean;
    isEnabled: boolean;
    logFilePath: string;
    readonly logIsolation: EventLogIsolation;
    logMode: EventLogMode;
    readonly logName: string | undefined;
    readonly logType: EventLogType;
    maximumSizeInBytes: long;
    readonly owningProviderName: string;
    readonly providerBufferSize: Nullable<System_Internal.Int32>;
    readonly providerControlGuid: Nullable<Guid>;
    providerKeywords: Nullable<System_Internal.Int64>;
    readonly providerLatency: Nullable<System_Internal.Int32>;
    providerLevel: Nullable<System_Internal.Int32>;
    readonly providerMaximumNumberOfBuffers: Nullable<System_Internal.Int32>;
    readonly providerMinimumNumberOfBuffers: Nullable<System_Internal.Int32>;
    readonly providerNames: IEnumerable<System_Internal.String>;
    securityDescriptor: string;
    dispose(): void;
    saveChanges(): void;
}


export const EventLogConfiguration: {
    new(logName: string): EventLogConfiguration;
    new(logName: string, session: EventLogSession): EventLogConfiguration;
};


export type EventLogConfiguration = EventLogConfiguration$instance;

export interface EventLogException$instance extends Exception {
    readonly message: string;
    getObjectData(info: SerializationInfo, context: StreamingContext): void;
}


export const EventLogException: {
    new(): EventLogException;
    new(message: string): EventLogException;
    new(message: string, innerException: Exception): EventLogException;
};


export type EventLogException = EventLogException$instance;

export interface EventLogInformation$instance {
    readonly attributes: Nullable<System_Internal.Int32>;
    readonly creationTime: Nullable<DateTime>;
    readonly fileSize: Nullable<System_Internal.Int64>;
    readonly isLogFull: Nullable<System_Internal.Boolean>;
    readonly lastAccessTime: Nullable<DateTime>;
    readonly lastWriteTime: Nullable<DateTime>;
    readonly oldestRecordNumber: Nullable<System_Internal.Int64>;
    readonly recordCount: Nullable<System_Internal.Int64>;
}


export const EventLogInformation: {
    new(): EventLogInformation;
};


export type EventLogInformation = EventLogInformation$instance;

export interface EventLogInvalidDataException$instance extends EventLogException {
}


export const EventLogInvalidDataException: {
    new(): EventLogInvalidDataException;
    new(message: string): EventLogInvalidDataException;
    new(message: string, innerException: Exception): EventLogInvalidDataException;
};


export type EventLogInvalidDataException = EventLogInvalidDataException$instance;

export interface EventLogLink$instance {
    readonly displayName: string;
    readonly isImported: boolean;
    readonly logName: string | undefined;
}


export const EventLogLink: {
    new(): EventLogLink;
};


export type EventLogLink = EventLogLink$instance;

export interface EventLogNotFoundException$instance extends EventLogException {
}


export const EventLogNotFoundException: {
    new(): EventLogNotFoundException;
    new(message: string): EventLogNotFoundException;
    new(message: string, innerException: Exception): EventLogNotFoundException;
};


export type EventLogNotFoundException = EventLogNotFoundException$instance;

export interface EventLogPropertySelector$instance {
    dispose(): void;
}


export const EventLogPropertySelector: {
    new(propertyQueries: IEnumerable<System_Internal.String>): EventLogPropertySelector;
};


export type EventLogPropertySelector = EventLogPropertySelector$instance;

export interface EventLogProviderDisabledException$instance extends EventLogException {
}


export const EventLogProviderDisabledException: {
    new(): EventLogProviderDisabledException;
    new(message: string): EventLogProviderDisabledException;
    new(message: string, innerException: Exception): EventLogProviderDisabledException;
};


export type EventLogProviderDisabledException = EventLogProviderDisabledException$instance;

export interface EventLogQuery$instance {
    reverseDirection: boolean;
    session: EventLogSession;
    tolerateQueryErrors: boolean;
}


export const EventLogQuery: {
    new(path: string, pathType: PathType): EventLogQuery;
    new(path: string, pathType: PathType, query: string): EventLogQuery;
};


export type EventLogQuery = EventLogQuery$instance;

export interface EventLogReader$instance {
    batchSize: int;
    readonly logStatus: IList<EventLogStatus>;
    cancelReading(): void;
    dispose(): void;
    readEvent(): EventRecord;
    readEvent(timeout: TimeSpan): EventRecord;
    seek(bookmark: EventBookmark): void;
    seek(bookmark: EventBookmark, offset: long): void;
    seek(origin: SeekOrigin, offset: long): void;
}


export const EventLogReader: {
    new(eventQuery: EventLogQuery): EventLogReader;
    new(eventQuery: EventLogQuery, bookmark: EventBookmark): EventLogReader;
    new(path: string): EventLogReader;
    new(path: string, pathType: PathType): EventLogReader;
};


export type EventLogReader = EventLogReader$instance;

export interface EventLogReadingException$instance extends EventLogException {
}


export const EventLogReadingException: {
    new(): EventLogReadingException;
    new(message: string): EventLogReadingException;
    new(message: string, innerException: Exception): EventLogReadingException;
};


export type EventLogReadingException = EventLogReadingException$instance;

export interface EventLogRecord$instance extends EventRecord {
    readonly activityId: Nullable<Guid>;
    readonly bookmark: EventBookmark;
    readonly containerLog: string;
    readonly id: int;
    readonly keywords: Nullable<System_Internal.Int64>;
    readonly keywordsDisplayNames: IEnumerable<System_Internal.String>;
    readonly level: Nullable<System_Internal.Byte>;
    readonly levelDisplayName: string;
    readonly logName: string | undefined;
    readonly machineName: string | undefined;
    readonly matchedQueryIds: IEnumerable<System_Internal.Int32>;
    readonly opcode: Nullable<System_Internal.Int16>;
    readonly opcodeDisplayName: string;
    readonly processId: Nullable<System_Internal.Int32>;
    readonly properties: IList<EventProperty>;
    readonly providerId: Nullable<Guid>;
    readonly providerName: string | undefined;
    readonly qualifiers: Nullable<System_Internal.Int32>;
    readonly recordId: Nullable<System_Internal.Int64>;
    readonly relatedActivityId: Nullable<Guid>;
    readonly task: Nullable<System_Internal.Int32>;
    readonly taskDisplayName: string;
    readonly threadId: Nullable<System_Internal.Int32>;
    readonly timeCreated: Nullable<DateTime>;
    readonly userId: SecurityIdentifier;
    readonly version: Nullable<System_Internal.Byte>;
    formatDescription(): string;
    formatDescription(values: IEnumerable<unknown>): string;
    getPropertyValues(propertySelector: EventLogPropertySelector): IList<unknown>;
    toXml(): string;
}


export const EventLogRecord: {
    new(): EventLogRecord;
};


export type EventLogRecord = EventLogRecord$instance;

export interface EventLogSession$instance {
    cancelCurrentOperations(): void;
    clearLog(logName: string): void;
    clearLog(logName: string, backupPath: string): void;
    dispose(): void;
    exportLog(path: string, pathType: PathType, query: string, targetFilePath: string): void;
    exportLog(path: string, pathType: PathType, query: string, targetFilePath: string, tolerateQueryErrors: boolean): void;
    exportLogAndMessages(path: string, pathType: PathType, query: string, targetFilePath: string): void;
    exportLogAndMessages(path: string, pathType: PathType, query: string, targetFilePath: string, tolerateQueryErrors: boolean, targetCultureInfo: CultureInfo): void;
    getLogInformation(logName: string, pathType: PathType): EventLogInformation;
    getLogNames(): IEnumerable<System_Internal.String>;
    getProviderNames(): IEnumerable<System_Internal.String>;
}


export const EventLogSession: {
    new(): EventLogSession;
    new(server: string): EventLogSession;
    new(server: string, domain: string, user: string, password: SecureString, logOnType: SessionAuthentication): EventLogSession;
    readonly globalSession: EventLogSession;
};


export type EventLogSession = EventLogSession$instance;

export interface EventLogStatus$instance {
    readonly logName: string | undefined;
    readonly statusCode: int;
}


export const EventLogStatus: {
    new(): EventLogStatus;
};


export type EventLogStatus = EventLogStatus$instance;

export interface EventLogWatcher$instance {
    enabled: boolean;
    dispose(): void;
}


export const EventLogWatcher: {
    new(eventQuery: EventLogQuery): EventLogWatcher;
    new(eventQuery: EventLogQuery, bookmark: EventBookmark): EventLogWatcher;
    new(eventQuery: EventLogQuery, bookmark: EventBookmark, readExistingEvents: boolean): EventLogWatcher;
    new(path: string): EventLogWatcher;
};


export type EventLogWatcher = EventLogWatcher$instance;

export interface EventMetadata$instance {
    readonly description: string;
    readonly id: long;
    readonly keywords: IEnumerable<EventKeyword>;
    readonly level: EventLevel;
    readonly logLink: EventLogLink;
    readonly opcode: EventOpcode;
    readonly task: EventTask;
    readonly template: string;
    readonly version: byte;
}


export const EventMetadata: {
    new(): EventMetadata;
};


export type EventMetadata = EventMetadata$instance;

export interface EventOpcode$instance {
    readonly displayName: string;
    readonly name: string;
    readonly value: int;
}


export const EventOpcode: {
    new(): EventOpcode;
};


export type EventOpcode = EventOpcode$instance;

export interface EventProperty$instance {
    readonly value: unknown;
}


export const EventProperty: {
    new(): EventProperty;
};


export type EventProperty = EventProperty$instance;

export interface EventRecord$instance {
    readonly activityId: Nullable<Guid>;
    readonly bookmark: EventBookmark;
    readonly id: int;
    readonly keywords: Nullable<System_Internal.Int64>;
    readonly keywordsDisplayNames: IEnumerable<System_Internal.String>;
    readonly level: Nullable<System_Internal.Byte>;
    readonly levelDisplayName: string;
    readonly logName: string | undefined;
    readonly machineName: string | undefined;
    readonly opcode: Nullable<System_Internal.Int16>;
    readonly opcodeDisplayName: string;
    readonly processId: Nullable<System_Internal.Int32>;
    readonly properties: IList<EventProperty>;
    readonly providerId: Nullable<Guid>;
    readonly providerName: string | undefined;
    readonly qualifiers: Nullable<System_Internal.Int32>;
    readonly recordId: Nullable<System_Internal.Int64>;
    readonly relatedActivityId: Nullable<Guid>;
    readonly task: Nullable<System_Internal.Int32>;
    readonly taskDisplayName: string;
    readonly threadId: Nullable<System_Internal.Int32>;
    readonly timeCreated: Nullable<DateTime>;
    readonly userId: SecurityIdentifier;
    readonly version: Nullable<System_Internal.Byte>;
    dispose(): void;
    formatDescription(): string;
    formatDescription(values: IEnumerable<unknown>): string;
    toXml(): string;
}


export const EventRecord: {
};


export type EventRecord = EventRecord$instance;

export interface EventRecordWrittenEventArgs$instance extends EventArgs {
    readonly eventException: Exception;
    readonly eventRecord: EventRecord;
}


export const EventRecordWrittenEventArgs: {
    new(): EventRecordWrittenEventArgs;
};


export type EventRecordWrittenEventArgs = EventRecordWrittenEventArgs$instance;

export interface EventTask$instance {
    readonly displayName: string;
    readonly eventGuid: Guid;
    readonly name: string;
    readonly value: int;
}


export const EventTask: {
    new(): EventTask;
};


export type EventTask = EventTask$instance;

export interface ProviderMetadata$instance {
    readonly displayName: string;
    readonly events: IEnumerable<EventMetadata>;
    readonly helpLink: Uri;
    readonly id: Guid;
    readonly keywords: IList<EventKeyword>;
    readonly levels: IList<EventLevel>;
    readonly logLinks: IList<EventLogLink>;
    readonly messageFilePath: string;
    readonly name: string;
    readonly opcodes: IList<EventOpcode>;
    readonly parameterFilePath: string;
    readonly resourceFilePath: string;
    readonly tasks: IList<EventTask>;
    dispose(): void;
}


export const ProviderMetadata: {
    new(providerName: string): ProviderMetadata;
    new(providerName: string, session: EventLogSession, targetCultureInfo: CultureInfo): ProviderMetadata;
};


export type ProviderMetadata = ProviderMetadata$instance;

