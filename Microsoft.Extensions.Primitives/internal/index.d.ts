// Generated by tsbindgen - Architecture
// Namespace: Microsoft.Extensions.Primitives
// Assembly: Microsoft.Extensions.Primitives

// Primitive type aliases from @tsonic/core
import type { sbyte, byte, short, ushort, int, uint, long, ulong, int128, uint128, half, float, double, decimal, nint, nuint, char } from '@tsonic/core/types.js';

// Import support types from @tsonic/core
import type { ptr } from "@tsonic/core/types.js";

// Import types from other namespaces
import * as System_Collections_Generic_Internal from "@tsonic/dotnet/System.Collections.Generic.js";
import type { ICollection, IComparer, IEnumerable as IEnumerable__System_Collections_Generic, IEnumerator as IEnumerator__System_Collections_Generic, IEqualityComparer, IList, IReadOnlyCollection, IReadOnlyList } from "@tsonic/dotnet/System.Collections.Generic.js";
import * as System_Collections_Internal from "@tsonic/dotnet/System.Collections.js";
import type { IEnumerable, IEnumerator } from "@tsonic/dotnet/System.Collections.js";
import * as System_Internal from "@tsonic/dotnet/System.js";
import type { Action, Boolean as ClrBoolean, Char, Func, IDisposable, IEquatable, Int32, Object as ClrObject, ReadOnlyMemory, ReadOnlySpan, String as ClrString, StringComparison, ValueType, Void } from "@tsonic/dotnet/System.js";
import type { StringBuilder } from "@tsonic/dotnet/System.Text.js";
import type { CancellationToken } from "@tsonic/dotnet/System.Threading.js";

export interface IChangeToken$instance {
    readonly HasChanged: boolean;
    readonly ActiveChangeCallbacks: boolean;
    RegisterChangeCallback(callback: Action<unknown>, state: unknown): IDisposable;
}


export type IChangeToken = IChangeToken$instance;

export interface InplaceStringBuilder$instance {
    Capacity: int;
    Append(value: string): void;
    Append(segment: StringSegment): void;
    Append(value: string, offset: int, count: int): void;
    Append(c: char): void;
    ToString(): string | undefined;
}


export const InplaceStringBuilder: {
    new(capacity: int): InplaceStringBuilder;
};


export type InplaceStringBuilder = InplaceStringBuilder$instance;

export interface StringSegment$instance {
    readonly Buffer: string | undefined;
    readonly HasValue: boolean;
    readonly Item: char;
    readonly Length: int;
    readonly Offset: int;
    readonly Value: string | undefined;
    AsMemory(): ReadOnlyMemory<System_Internal.Char>;
    AsSpan(): ReadOnlySpan<System_Internal.Char>;
    AsSpan(start: int): ReadOnlySpan<System_Internal.Char>;
    AsSpan(start: int, length: int): ReadOnlySpan<System_Internal.Char>;
    EndsWith(text: string, comparisonType: StringComparison): boolean;
    Equals(obj: unknown): boolean;
    Equals(other: StringSegment): boolean;
    Equals(other: StringSegment, comparisonType: StringComparison): boolean;
    Equals(text: string): boolean;
    Equals(text: string, comparisonType: StringComparison): boolean;
    GetHashCode(): int;
    IndexOf(c: char, start: int, count: int): int;
    IndexOf(c: char, start: int): int;
    IndexOf(c: char): int;
    IndexOfAny(anyOf: char[], startIndex: int, count: int): int;
    IndexOfAny(anyOf: char[], startIndex: int): int;
    IndexOfAny(anyOf: char[]): int;
    LastIndexOf(value: char): int;
    Split(chars: char[]): StringTokenizer;
    StartsWith(text: string, comparisonType: StringComparison): boolean;
    Subsegment(offset: int): StringSegment;
    Subsegment(offset: int, length: int): StringSegment;
    Substring(offset: int): string;
    Substring(offset: int, length: int): string;
    ToString(): string;
    Trim(): StringSegment;
    TrimEnd(): StringSegment;
    TrimStart(): StringSegment;
}


export const StringSegment: {
    new(buffer: string): StringSegment;
    new(buffer: string, offset: int, length: int): StringSegment;
    readonly Empty: StringSegment;
    Compare(a: StringSegment, b: StringSegment, comparisonType: StringComparison): int;
    Equals(a: StringSegment, b: StringSegment, comparisonType: StringComparison): boolean;
    IsNullOrEmpty(value: StringSegment): boolean;
};


export type StringSegment = StringSegment$instance;

export interface StringTokenizer$instance {
    GetEnumerator(): StringTokenizer_Enumerator;
}


export const StringTokenizer: {
    new(value: string, separators: char[]): StringTokenizer;
    new(value: StringSegment, separators: char[]): StringTokenizer;
};


export type StringTokenizer = StringTokenizer$instance;

export interface StringTokenizer_Enumerator$instance {
    Current: StringSegment;
    Dispose(): void;
    MoveNext(): boolean;
    Reset(): void;
}


export const StringTokenizer_Enumerator: {
    new(tokenizer: StringTokenizer): StringTokenizer_Enumerator;
};


export type StringTokenizer_Enumerator = StringTokenizer_Enumerator$instance;

export interface StringValues$instance {
    readonly Count: int;
    readonly Item: string;
    Equals(other: StringValues): boolean;
    Equals(other: string): boolean;
    Equals(other: string[]): boolean;
    Equals(obj: unknown): boolean;
    GetEnumerator(): StringValues_Enumerator;
    GetHashCode(): int;
    ToArray(): (string | undefined)[];
    ToString(): string;
}


export const StringValues: {
    new(value: string): StringValues;
    new(values: string[]): StringValues;
    readonly Empty: StringValues;
    Concat(values1: StringValues, values2: StringValues): StringValues;
    Concat(values: StringValues, value: string): StringValues;
    Concat(value: string, values: StringValues): StringValues;
    Equals(left: StringValues, right: StringValues): boolean;
    Equals(left: StringValues, right: string): boolean;
    Equals(left: StringValues, right: string[]): boolean;
    Equals(left: string, right: StringValues): boolean;
    Equals(left: string[], right: StringValues): boolean;
    IsNullOrEmpty(value: StringValues): boolean;
};


export type StringValues = StringValues$instance;

export interface StringValues_Enumerator$instance {
    readonly Current: string;
    Dispose(): void;
    MoveNext(): boolean;
    Reset(): void;
}


export const StringValues_Enumerator: {
    new(values: StringValues): StringValues_Enumerator;
};


export type StringValues_Enumerator = StringValues_Enumerator$instance;

export interface CancellationChangeToken$instance {
    ActiveChangeCallbacks: boolean;
    readonly HasChanged: boolean;
    RegisterChangeCallback(callback: Action<unknown>, state: unknown): IDisposable;
}


export const CancellationChangeToken: {
    new(cancellationToken: CancellationToken): CancellationChangeToken;
};


export interface __CancellationChangeToken$views {
    As_IChangeToken(): IChangeToken$instance;
}

export type CancellationChangeToken = CancellationChangeToken$instance & __CancellationChangeToken$views;


export interface CompositeChangeToken$instance {
    readonly ActiveChangeCallbacks: boolean;
    readonly ChangeTokens: IReadOnlyList<IChangeToken>;
    readonly HasChanged: boolean;
    RegisterChangeCallback(callback: Action<unknown>, state: unknown): IDisposable;
}


export const CompositeChangeToken: {
    new(changeTokens: IReadOnlyList<IChangeToken>): CompositeChangeToken;
};


export interface __CompositeChangeToken$views {
    As_IChangeToken(): IChangeToken$instance;
}

export interface CompositeChangeToken$instance extends IChangeToken$instance {}

export type CompositeChangeToken = CompositeChangeToken$instance & __CompositeChangeToken$views;


export interface StringSegmentComparer$instance {
    Compare(x: StringSegment, y: StringSegment): int;
    Equals(x: StringSegment, y: StringSegment): boolean;
    GetHashCode(obj: StringSegment): int;
}


export const StringSegmentComparer: {
    new(): StringSegmentComparer;
    readonly Ordinal: StringSegmentComparer;
    readonly OrdinalIgnoreCase: StringSegmentComparer;
};


export type StringSegmentComparer = StringSegmentComparer$instance;

export abstract class ChangeToken$instance {
    static OnChange<TState>(changeTokenProducer: Func<IChangeToken>, changeTokenConsumer: Action<TState>, state: TState): IDisposable;
    static OnChange(changeTokenProducer: Func<IChangeToken>, changeTokenConsumer: Action): IDisposable;
}


export type ChangeToken = ChangeToken$instance;

export abstract class Extensions$instance {
    static Append(builder: StringBuilder, segment: StringSegment): StringBuilder;
}


export type Extensions = Extensions$instance;

