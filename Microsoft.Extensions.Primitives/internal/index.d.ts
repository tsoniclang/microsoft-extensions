// Generated by tsbindgen - Architecture
// Namespace: Microsoft.Extensions.Primitives
// Assembly: Microsoft.Extensions.Primitives

// Primitive type aliases from @tsonic/core
import type { sbyte, byte, short, ushort, int, uint, long, ulong, int128, uint128, half, float, double, decimal, nint, nuint, char } from '@tsonic/core/types.js';

// Import support types from @tsonic/core
import type { ptr } from "@tsonic/core/types.js";

// Import types from other namespaces
import * as System_Collections_Generic_Internal from "@tsonic/dotnet/System.Collections.Generic.js";
import type { ICollection, IComparer, IEnumerable as IEnumerable__System_Collections_Generic, IEnumerator as IEnumerator__System_Collections_Generic, IEqualityComparer, IList, IReadOnlyCollection, IReadOnlyList } from "@tsonic/dotnet/System.Collections.Generic.js";
import * as System_Collections_Internal from "@tsonic/dotnet/System.Collections.js";
import type { IEnumerable, IEnumerator } from "@tsonic/dotnet/System.Collections.js";
import * as System_Internal from "@tsonic/dotnet/System.js";
import type { Action, Boolean as ClrBoolean, Char, Func, IDisposable, IEquatable, Int32, Object as ClrObject, ReadOnlyMemory, ReadOnlySpan, String as ClrString, StringComparison, ValueType, Void } from "@tsonic/dotnet/System.js";
import type { StringBuilder } from "@tsonic/dotnet/System.Text.js";
import type { CancellationToken } from "@tsonic/dotnet/System.Threading.js";

export interface IChangeToken$instance {
    readonly hasChanged: boolean;
    readonly activeChangeCallbacks: boolean;
    registerChangeCallback(callback: Action<unknown>, state: unknown): IDisposable;
}


export type IChangeToken = IChangeToken$instance;

export interface InplaceStringBuilder$instance {
    capacity: int;
    append(value: string): void;
    append(segment: StringSegment): void;
    append(value: string, offset: int, count: int): void;
    append(c: char): void;
    toString(): string | undefined;
}


export const InplaceStringBuilder: {
    new(capacity: int): InplaceStringBuilder;
};


export type InplaceStringBuilder = InplaceStringBuilder$instance;

export interface StringSegment$instance {
    readonly buffer: string | undefined;
    readonly hasValue: boolean;
    readonly item: char;
    readonly length: int;
    readonly offset: int;
    readonly value: string | undefined;
    asMemory(): ReadOnlyMemory<System_Internal.Char>;
    asSpan(): ReadOnlySpan<System_Internal.Char>;
    asSpan(start: int): ReadOnlySpan<System_Internal.Char>;
    asSpan(start: int, length: int): ReadOnlySpan<System_Internal.Char>;
    endsWith(text: string, comparisonType: StringComparison): boolean;
    equals(obj: unknown): boolean;
    equals(other: StringSegment): boolean;
    equals(other: StringSegment, comparisonType: StringComparison): boolean;
    equals(text: string): boolean;
    equals(text: string, comparisonType: StringComparison): boolean;
    getHashCode(): int;
    indexOf(c: char, start: int, count: int): int;
    indexOf(c: char, start: int): int;
    indexOf(c: char): int;
    indexOfAny(anyOf: char[], startIndex: int, count: int): int;
    indexOfAny(anyOf: char[], startIndex: int): int;
    indexOfAny(anyOf: char[]): int;
    lastIndexOf(value: char): int;
    split(chars: char[]): StringTokenizer;
    startsWith(text: string, comparisonType: StringComparison): boolean;
    subsegment(offset: int): StringSegment;
    subsegment(offset: int, length: int): StringSegment;
    substring(offset: int): string;
    substring(offset: int, length: int): string;
    toString(): string;
    trim(): StringSegment;
    trimEnd(): StringSegment;
    trimStart(): StringSegment;
}


export const StringSegment: {
    new(buffer: string): StringSegment;
    new(buffer: string, offset: int, length: int): StringSegment;
    readonly empty: StringSegment;
    compare(a: StringSegment, b: StringSegment, comparisonType: StringComparison): int;
    equals(a: StringSegment, b: StringSegment, comparisonType: StringComparison): boolean;
    isNullOrEmpty(value: StringSegment): boolean;
};


export type StringSegment = StringSegment$instance;

export interface StringTokenizer$instance {
    getEnumerator(): StringTokenizer_Enumerator;
}


export const StringTokenizer: {
    new(value: string, separators: char[]): StringTokenizer;
    new(value: StringSegment, separators: char[]): StringTokenizer;
};


export type StringTokenizer = StringTokenizer$instance;

export interface StringTokenizer_Enumerator$instance {
    readonly current: StringSegment;
    dispose(): void;
    moveNext(): boolean;
    reset(): void;
}


export const StringTokenizer_Enumerator: {
    new(tokenizer: StringTokenizer): StringTokenizer_Enumerator;
};


export type StringTokenizer_Enumerator = StringTokenizer_Enumerator$instance;

export interface StringValues$instance {
    readonly count: int;
    readonly item: string;
    equals(other: StringValues): boolean;
    equals(other: string): boolean;
    equals(other: string[]): boolean;
    equals(obj: unknown): boolean;
    getEnumerator(): StringValues_Enumerator;
    getHashCode(): int;
    toArray(): (string | undefined)[];
    toString(): string;
}


export const StringValues: {
    new(value: string): StringValues;
    new(values: string[]): StringValues;
    readonly empty: StringValues;
    concat(values1: StringValues, values2: StringValues): StringValues;
    concat(values: StringValues, value: string): StringValues;
    concat(value: string, values: StringValues): StringValues;
    equals(left: StringValues, right: StringValues): boolean;
    equals(left: StringValues, right: string): boolean;
    equals(left: StringValues, right: string[]): boolean;
    equals(left: string, right: StringValues): boolean;
    equals(left: string[], right: StringValues): boolean;
    isNullOrEmpty(value: StringValues): boolean;
};


export type StringValues = StringValues$instance;

export interface StringValues_Enumerator$instance {
    readonly current: string | undefined;
    dispose(): void;
    moveNext(): boolean;
    reset(): void;
}


export const StringValues_Enumerator: {
    new(values: StringValues): StringValues_Enumerator;
};


export type StringValues_Enumerator = StringValues_Enumerator$instance;

export interface CancellationChangeToken$instance {
    readonly activeChangeCallbacks: boolean;
    readonly hasChanged: boolean;
    registerChangeCallback(callback: Action<unknown>, state: unknown): IDisposable;
}


export const CancellationChangeToken: {
    new(cancellationToken: CancellationToken): CancellationChangeToken;
};


export interface __CancellationChangeToken$views {
    As_IChangeToken(): IChangeToken$instance;
}

export interface CancellationChangeToken$instance extends IChangeToken$instance {}

export type CancellationChangeToken = CancellationChangeToken$instance & __CancellationChangeToken$views;


export interface CompositeChangeToken$instance {
    readonly activeChangeCallbacks: boolean;
    readonly changeTokens: IReadOnlyList<IChangeToken>;
    readonly hasChanged: boolean;
    registerChangeCallback(callback: Action<unknown>, state: unknown): IDisposable;
}


export const CompositeChangeToken: {
    new(changeTokens: IReadOnlyList<IChangeToken>): CompositeChangeToken;
};


export interface __CompositeChangeToken$views {
    As_IChangeToken(): IChangeToken$instance;
}

export interface CompositeChangeToken$instance extends IChangeToken$instance {}

export type CompositeChangeToken = CompositeChangeToken$instance & __CompositeChangeToken$views;


export interface StringSegmentComparer$instance {
    compare(x: StringSegment, y: StringSegment): int;
    equals(x: StringSegment, y: StringSegment): boolean;
    getHashCode(obj: StringSegment): int;
}


export const StringSegmentComparer: {
    new(): StringSegmentComparer;
    readonly ordinal: StringSegmentComparer;
    readonly ordinalIgnoreCase: StringSegmentComparer;
};


export type StringSegmentComparer = StringSegmentComparer$instance;

export abstract class ChangeToken$instance {
    static onChange<TState>(changeTokenProducer: Func<IChangeToken>, changeTokenConsumer: Action<TState>, state: TState): IDisposable;
    static onChange(changeTokenProducer: Func<IChangeToken>, changeTokenConsumer: Action): IDisposable;
}


export type ChangeToken = ChangeToken$instance;

export abstract class Extensions$instance {
    static append(builder: StringBuilder, segment: StringSegment): StringBuilder;
}


export type Extensions = Extensions$instance;

