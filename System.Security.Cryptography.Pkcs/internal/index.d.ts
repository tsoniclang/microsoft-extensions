// Generated by tsbindgen - Architecture
// Namespace: System.Security.Cryptography.Pkcs
// Assembly: System.Security.Cryptography.Pkcs

// Primitive type aliases from @tsonic/core
import type { sbyte, byte, short, ushort, int, uint, long, ulong, int128, uint128, half, float, double, decimal, nint, nuint, char } from '@tsonic/core/types.js';

// Import support types from @tsonic/core
import type { ptr } from "@tsonic/core/types.js";

// Import types from other namespaces
import type { CryptographicAttributeObject, CryptographicAttributeObjectCollection } from "../../System.Security.Cryptography/internal/index.js";
import type { IEnumerable as IEnumerable__System_Collections_Generic } from "@tsonic/dotnet/System.Collections.Generic.js";
import * as System_Collections_Internal from "@tsonic/dotnet/System.Collections.js";
import type { ICollection, IEnumerable, IEnumerator } from "@tsonic/dotnet/System.Collections.js";
import type { ReadOnlyCollection } from "@tsonic/dotnet/System.Collections.ObjectModel.js";
import * as System_Internal from "@tsonic/dotnet/System.js";
import type { Array as ClrArray, Boolean as ClrBoolean, Byte, Char, DateTime, DateTimeOffset, Enum, IComparable, IConvertible, IFormattable, Int32, Int64, ISpanFormattable, Nullable, Object as ClrObject, ReadOnlyMemory, ReadOnlySpan, Span, String as ClrString, Void } from "@tsonic/dotnet/System.js";
import * as System_Security_Cryptography_Lib from "@tsonic/dotnet/System.Security.Cryptography.js";
import type { AsnEncodedData, AsymmetricAlgorithm, CompositeMLDsa, CspParameters, HashAlgorithmName, MLDsa, Oid, PbeParameters, RSA, RSAEncryptionPadding, RSASignaturePadding, SlhDsa } from "@tsonic/dotnet/System.Security.Cryptography.js";
import type { X509Certificate2, X509Certificate2Collection, X509ExtensionCollection, X509IncludeOption } from "@tsonic/dotnet/System.Security.Cryptography.X509Certificates.js";

export enum Pkcs12ConfidentialityMode {
    Unknown = 0,
    None = 1,
    Password = 2,
    PublicKey = 3
}


export enum Pkcs12IntegrityMode {
    Unknown = 0,
    None = 1,
    Password = 2,
    PublicKey = 3
}


export enum RecipientInfoType {
    Unknown = 0,
    KeyTransport = 1,
    KeyAgreement = 2
}


export enum SubjectIdentifierOrKeyType {
    Unknown = 0,
    IssuerAndSerialNumber = 1,
    SubjectKeyIdentifier = 2,
    PublicKeyInfo = 3
}


export enum SubjectIdentifierType {
    Unknown = 0,
    IssuerAndSerialNumber = 1,
    SubjectKeyIdentifier = 2,
    NoSignature = 3
}


export interface AlgorithmIdentifier$instance {
    KeyLength: int;
    Oid: Oid;
    Parameters: byte[];
}


export const AlgorithmIdentifier: {
    new(): AlgorithmIdentifier;
    new(oid: Oid): AlgorithmIdentifier;
    new(oid: Oid, keyLength: int): AlgorithmIdentifier;
};


export type AlgorithmIdentifier = AlgorithmIdentifier$instance;

export interface CmsRecipient$instance {
    readonly Certificate: X509Certificate2;
    readonly RecipientIdentifierType: SubjectIdentifierType;
    readonly RSAEncryptionPadding: RSAEncryptionPadding | undefined;
}


export const CmsRecipient: {
    new(certificate: X509Certificate2): CmsRecipient;
    new(certificate: X509Certificate2, rsaEncryptionPadding: RSAEncryptionPadding): CmsRecipient;
    new(recipientIdentifierType: SubjectIdentifierType, certificate: X509Certificate2, rsaEncryptionPadding: RSAEncryptionPadding): CmsRecipient;
    new(recipientIdentifierType: SubjectIdentifierType, certificate: X509Certificate2): CmsRecipient;
};


export type CmsRecipient = CmsRecipient$instance;

export interface CmsRecipientCollection$instance {
    readonly Count: int;
    readonly IsSynchronized: boolean;
    readonly Item: CmsRecipient;
    readonly SyncRoot: unknown;
    Add(recipient: CmsRecipient): int;
    CopyTo(array: ClrArray, index: int): void;
    CopyTo(array: CmsRecipient[], index: int): void;
    GetEnumerator(): CmsRecipientEnumerator;
    Remove(recipient: CmsRecipient): void;
}


export const CmsRecipientCollection: {
    new(): CmsRecipientCollection;
    new(recipient: CmsRecipient): CmsRecipientCollection;
    new(recipientIdentifierType: SubjectIdentifierType, certificates: X509Certificate2Collection): CmsRecipientCollection;
};


export type CmsRecipientCollection = CmsRecipientCollection$instance;

export interface CmsRecipientEnumerator$instance {
    readonly Current: CmsRecipient;
    MoveNext(): boolean;
    Reset(): void;
}


export const CmsRecipientEnumerator: {
    new(): CmsRecipientEnumerator;
};


export type CmsRecipientEnumerator = CmsRecipientEnumerator$instance;

export interface CmsSigner$instance {
    Certificate: X509Certificate2;
    readonly Certificates: X509Certificate2Collection;
    DigestAlgorithm: Oid;
    IncludeOption: X509IncludeOption;
    get PrivateKey(): AsymmetricAlgorithm | undefined;
    set PrivateKey(value: AsymmetricAlgorithm);
    get SignaturePadding(): RSASignaturePadding | undefined;
    set SignaturePadding(value: RSASignaturePadding);
    readonly SignedAttributes: CryptographicAttributeObjectCollection;
    SignerIdentifierType: SubjectIdentifierType;
    readonly UnsignedAttributes: CryptographicAttributeObjectCollection;
}


export const CmsSigner: {
    new(): CmsSigner;
    new(signerIdentifierType: SubjectIdentifierType): CmsSigner;
    new(certificate: X509Certificate2): CmsSigner;
    new(parameters: CspParameters): CmsSigner;
    new(signerIdentifierType: SubjectIdentifierType, certificate: X509Certificate2): CmsSigner;
    new(signerIdentifierType: SubjectIdentifierType, certificate: X509Certificate2, privateKey: AsymmetricAlgorithm): CmsSigner;
    new(signerIdentifierType: SubjectIdentifierType, certificate: X509Certificate2, privateKey: MLDsa): CmsSigner;
    new(signerIdentifierType: SubjectIdentifierType, certificate: X509Certificate2, privateKey: SlhDsa): CmsSigner;
    new(signerIdentifierType: SubjectIdentifierType, certificate: X509Certificate2, privateKey: CompositeMLDsa): CmsSigner;
    new(signerIdentifierType: SubjectIdentifierType, certificate: X509Certificate2, privateKey: RSA, signaturePadding: RSASignaturePadding): CmsSigner;
};


export type CmsSigner = CmsSigner$instance;

export interface ContentInfo$instance {
    readonly Content: byte[];
    readonly ContentType: Oid;
}


export const ContentInfo: {
    new(content: byte[]): ContentInfo;
    new(contentType: Oid, content: byte[]): ContentInfo;
    GetContentType(encodedMessage: byte[]): Oid;
    GetContentType(encodedMessage: ReadOnlySpan<System_Internal.Byte>): Oid;
};


export type ContentInfo = ContentInfo$instance;

export interface EnvelopedCms$instance {
    readonly Certificates: X509Certificate2Collection;
    readonly ContentEncryptionAlgorithm: AlgorithmIdentifier;
    readonly ContentInfo: ContentInfo;
    readonly RecipientInfos: RecipientInfoCollection;
    readonly UnprotectedAttributes: CryptographicAttributeObjectCollection;
    readonly Version: int;
    Decode(encodedMessage: byte[]): void;
    Decode(encodedMessage: ReadOnlySpan<System_Internal.Byte>): void;
    Decrypt(): void;
    Decrypt(recipientInfo: RecipientInfo): void;
    Decrypt(recipientInfo: RecipientInfo, extraStore: X509Certificate2Collection): void;
    Decrypt(extraStore: X509Certificate2Collection): void;
    Decrypt(recipientInfo: RecipientInfo, privateKey: AsymmetricAlgorithm): void;
    Encode(): byte[];
    Encrypt(recipient: CmsRecipient): void;
    Encrypt(recipients: CmsRecipientCollection): void;
}


export const EnvelopedCms: {
    new(): EnvelopedCms;
    new(contentInfo: ContentInfo): EnvelopedCms;
    new(contentInfo: ContentInfo, encryptionAlgorithm: AlgorithmIdentifier): EnvelopedCms;
};


export type EnvelopedCms = EnvelopedCms$instance;

export interface KeyAgreeRecipientInfo$instance extends RecipientInfo {
    readonly Date: DateTime;
    readonly EncryptedKey: byte[];
    readonly KeyEncryptionAlgorithm: AlgorithmIdentifier;
    readonly OriginatorIdentifierOrKey: SubjectIdentifierOrKey;
    readonly OtherKeyAttribute: CryptographicAttributeObject | undefined;
    readonly RecipientIdentifier: SubjectIdentifier;
    readonly Version: int;
}


export const KeyAgreeRecipientInfo: {
    new(): KeyAgreeRecipientInfo;
};


export type KeyAgreeRecipientInfo = KeyAgreeRecipientInfo$instance;

export interface KeyTransRecipientInfo$instance extends RecipientInfo {
    readonly EncryptedKey: byte[];
    readonly KeyEncryptionAlgorithm: AlgorithmIdentifier;
    readonly RecipientIdentifier: SubjectIdentifier;
    readonly Version: int;
}


export const KeyTransRecipientInfo: {
    new(): KeyTransRecipientInfo;
};


export type KeyTransRecipientInfo = KeyTransRecipientInfo$instance;

export interface Pkcs12Builder$instance {
    readonly IsSealed: boolean;
    AddSafeContentsEncrypted(safeContents: Pkcs12SafeContents, passwordBytes: byte[], pbeParameters: PbeParameters): void;
    AddSafeContentsEncrypted(safeContents: Pkcs12SafeContents, passwordBytes: ReadOnlySpan<System_Internal.Byte>, pbeParameters: PbeParameters): void;
    AddSafeContentsEncrypted(safeContents: Pkcs12SafeContents, password: string, pbeParameters: PbeParameters): void;
    AddSafeContentsEncrypted(safeContents: Pkcs12SafeContents, password: ReadOnlySpan<System_Internal.Char>, pbeParameters: PbeParameters): void;
    AddSafeContentsUnencrypted(safeContents: Pkcs12SafeContents): void;
    Encode(): byte[];
    SealWithMac(password: string, hashAlgorithm: HashAlgorithmName, iterationCount: int): void;
    SealWithMac(password: ReadOnlySpan<System_Internal.Char>, hashAlgorithm: HashAlgorithmName, iterationCount: int): void;
    SealWithoutIntegrity(): void;
    TryEncode(destination: Span<System_Internal.Byte>, bytesWritten: int): boolean;
}


export const Pkcs12Builder: {
    new(): Pkcs12Builder;
};


export type Pkcs12Builder = Pkcs12Builder$instance;

export interface Pkcs12CertBag$instance extends Pkcs12SafeBag {
    readonly EncodedCertificate: ReadOnlyMemory<System_Internal.Byte>;
    readonly IsX509Certificate: boolean;
    GetCertificate(): X509Certificate2;
    GetCertificateType(): Oid;
}


export const Pkcs12CertBag: {
    new(certificateType: Oid, encodedCertificate: ReadOnlyMemory<System_Internal.Byte>): Pkcs12CertBag;
};


export type Pkcs12CertBag = Pkcs12CertBag$instance;

export interface Pkcs12Info$instance {
    readonly AuthenticatedSafe: ReadOnlyCollection<Pkcs12SafeContents>;
    readonly IntegrityMode: Pkcs12IntegrityMode;
    VerifyMac(password: string): boolean;
    VerifyMac(password: ReadOnlySpan<System_Internal.Char>): boolean;
}


export const Pkcs12Info: {
    new(): Pkcs12Info;
    Decode(encodedBytes: ReadOnlyMemory<System_Internal.Byte>, bytesConsumed: int, skipCopy?: boolean): Pkcs12Info;
};


export type Pkcs12Info = Pkcs12Info$instance;

export interface Pkcs12KeyBag$instance extends Pkcs12SafeBag {
    readonly Pkcs8PrivateKey: ReadOnlyMemory<System_Internal.Byte>;
}


export const Pkcs12KeyBag: {
    new(pkcs8PrivateKey: ReadOnlyMemory<System_Internal.Byte>, skipCopy: boolean): Pkcs12KeyBag;
};


export type Pkcs12KeyBag = Pkcs12KeyBag$instance;

export interface Pkcs12SafeBag$instance {
    readonly Attributes: CryptographicAttributeObjectCollection;
    readonly EncodedBagValue: ReadOnlyMemory<System_Internal.Byte>;
    Encode(): byte[];
    GetBagId(): Oid;
    TryEncode(destination: Span<System_Internal.Byte>, bytesWritten: int): boolean;
}


export const Pkcs12SafeBag: {
};


export type Pkcs12SafeBag = Pkcs12SafeBag$instance;

export interface Pkcs12SafeContents$instance {
    readonly ConfidentialityMode: Pkcs12ConfidentialityMode;
    readonly IsReadOnly: boolean;
    AddCertificate(certificate: X509Certificate2): Pkcs12CertBag;
    AddKeyUnencrypted(key: AsymmetricAlgorithm): Pkcs12KeyBag;
    AddNestedContents(safeContents: Pkcs12SafeContents): Pkcs12SafeContentsBag;
    AddSafeBag(safeBag: Pkcs12SafeBag): void;
    AddSecret(secretType: Oid, secretValue: ReadOnlyMemory<System_Internal.Byte>): Pkcs12SecretBag;
    AddShroudedKey(key: AsymmetricAlgorithm, passwordBytes: byte[], pbeParameters: PbeParameters): Pkcs12ShroudedKeyBag;
    AddShroudedKey(key: AsymmetricAlgorithm, passwordBytes: ReadOnlySpan<System_Internal.Byte>, pbeParameters: PbeParameters): Pkcs12ShroudedKeyBag;
    AddShroudedKey(key: AsymmetricAlgorithm, password: string, pbeParameters: PbeParameters): Pkcs12ShroudedKeyBag;
    AddShroudedKey(key: AsymmetricAlgorithm, password: ReadOnlySpan<System_Internal.Char>, pbeParameters: PbeParameters): Pkcs12ShroudedKeyBag;
    Decrypt(passwordBytes: byte[]): void;
    Decrypt(passwordBytes: ReadOnlySpan<System_Internal.Byte>): void;
    Decrypt(password: string): void;
    Decrypt(password: ReadOnlySpan<System_Internal.Char>): void;
    GetBags(): IEnumerable__System_Collections_Generic<Pkcs12SafeBag>;
}


export const Pkcs12SafeContents: {
    new(): Pkcs12SafeContents;
};


export type Pkcs12SafeContents = Pkcs12SafeContents$instance;

export interface Pkcs12SafeContentsBag$instance extends Pkcs12SafeBag {
    readonly SafeContents: Pkcs12SafeContents | undefined;
}


export const Pkcs12SafeContentsBag: {
    new(): Pkcs12SafeContentsBag;
};


export type Pkcs12SafeContentsBag = Pkcs12SafeContentsBag$instance;

export interface Pkcs12SecretBag$instance extends Pkcs12SafeBag {
    readonly SecretValue: ReadOnlyMemory<System_Internal.Byte>;
    GetSecretType(): Oid;
}


export const Pkcs12SecretBag: {
    new(): Pkcs12SecretBag;
};


export type Pkcs12SecretBag = Pkcs12SecretBag$instance;

export interface Pkcs12ShroudedKeyBag$instance extends Pkcs12SafeBag {
    readonly EncryptedPkcs8PrivateKey: ReadOnlyMemory<System_Internal.Byte>;
}


export const Pkcs12ShroudedKeyBag: {
    new(encryptedPkcs8PrivateKey: ReadOnlyMemory<System_Internal.Byte>, skipCopy: boolean): Pkcs12ShroudedKeyBag;
};


export type Pkcs12ShroudedKeyBag = Pkcs12ShroudedKeyBag$instance;

export interface Pkcs8PrivateKeyInfo$instance {
    readonly AlgorithmId: Oid;
    readonly AlgorithmParameters: Nullable<ReadOnlyMemory<System_Internal.Byte>>;
    readonly Attributes: CryptographicAttributeObjectCollection;
    readonly PrivateKeyBytes: ReadOnlyMemory<System_Internal.Byte>;
    Encode(): byte[];
    Encrypt(password: ReadOnlySpan<System_Internal.Char>, pbeParameters: PbeParameters): byte[];
    Encrypt(passwordBytes: ReadOnlySpan<System_Internal.Byte>, pbeParameters: PbeParameters): byte[];
    TryEncode(destination: Span<System_Internal.Byte>, bytesWritten: int): boolean;
    TryEncrypt(password: ReadOnlySpan<System_Internal.Char>, pbeParameters: PbeParameters, destination: Span<System_Internal.Byte>, bytesWritten: int): boolean;
    TryEncrypt(passwordBytes: ReadOnlySpan<System_Internal.Byte>, pbeParameters: PbeParameters, destination: Span<System_Internal.Byte>, bytesWritten: int): boolean;
}


export const Pkcs8PrivateKeyInfo: {
    new(algorithmId: Oid, algorithmParameters: Nullable<ReadOnlyMemory<System_Internal.Byte>>, privateKey: ReadOnlyMemory<System_Internal.Byte>, skipCopies: boolean): Pkcs8PrivateKeyInfo;
    Create(privateKey: AsymmetricAlgorithm): Pkcs8PrivateKeyInfo;
    Decode(source: ReadOnlyMemory<System_Internal.Byte>, bytesRead: int, skipCopy?: boolean): Pkcs8PrivateKeyInfo;
    DecryptAndDecode(passwordBytes: ReadOnlySpan<System_Internal.Byte>, source: ReadOnlyMemory<System_Internal.Byte>, bytesRead: int): Pkcs8PrivateKeyInfo;
    DecryptAndDecode(password: ReadOnlySpan<System_Internal.Char>, source: ReadOnlyMemory<System_Internal.Byte>, bytesRead: int): Pkcs8PrivateKeyInfo;
};


export type Pkcs8PrivateKeyInfo = Pkcs8PrivateKeyInfo$instance;

export interface Pkcs9AttributeObject$instance extends AsnEncodedData {
    readonly Oid: Oid | undefined;
    CopyFrom(asnEncodedData: AsnEncodedData): void;
}


export const Pkcs9AttributeObject: {
    new(): Pkcs9AttributeObject;
    new(oid: string, encodedData: byte[]): Pkcs9AttributeObject;
    new(oid: Oid, encodedData: byte[]): Pkcs9AttributeObject;
    new(asnEncodedData: AsnEncodedData): Pkcs9AttributeObject;
};


export type Pkcs9AttributeObject = Pkcs9AttributeObject$instance;

export interface Pkcs9ContentType$instance extends Pkcs9AttributeObject {
    readonly ContentType: Oid;
    CopyFrom(asnEncodedData: AsnEncodedData): void;
}


export const Pkcs9ContentType: {
    new(): Pkcs9ContentType;
};


export type Pkcs9ContentType = Pkcs9ContentType$instance;

export interface Pkcs9DocumentDescription$instance extends Pkcs9AttributeObject {
    readonly DocumentDescription: string;
    CopyFrom(asnEncodedData: AsnEncodedData): void;
}


export const Pkcs9DocumentDescription: {
    new(): Pkcs9DocumentDescription;
    new(documentDescription: string): Pkcs9DocumentDescription;
    new(encodedDocumentDescription: byte[]): Pkcs9DocumentDescription;
};


export type Pkcs9DocumentDescription = Pkcs9DocumentDescription$instance;

export interface Pkcs9DocumentName$instance extends Pkcs9AttributeObject {
    readonly DocumentName: string;
    CopyFrom(asnEncodedData: AsnEncodedData): void;
}


export const Pkcs9DocumentName: {
    new(): Pkcs9DocumentName;
    new(documentName: string): Pkcs9DocumentName;
    new(encodedDocumentName: byte[]): Pkcs9DocumentName;
};


export type Pkcs9DocumentName = Pkcs9DocumentName$instance;

export interface Pkcs9LocalKeyId$instance extends Pkcs9AttributeObject {
    readonly KeyId: ReadOnlyMemory<System_Internal.Byte>;
    CopyFrom(asnEncodedData: AsnEncodedData): void;
}


export const Pkcs9LocalKeyId: {
    new(): Pkcs9LocalKeyId;
    new(keyId: byte[]): Pkcs9LocalKeyId;
    new(keyId: ReadOnlySpan<System_Internal.Byte>): Pkcs9LocalKeyId;
};


export type Pkcs9LocalKeyId = Pkcs9LocalKeyId$instance;

export interface Pkcs9MessageDigest$instance extends Pkcs9AttributeObject {
    readonly MessageDigest: byte[];
    CopyFrom(asnEncodedData: AsnEncodedData): void;
}


export const Pkcs9MessageDigest: {
    new(): Pkcs9MessageDigest;
};


export type Pkcs9MessageDigest = Pkcs9MessageDigest$instance;

export interface Pkcs9SigningTime$instance extends Pkcs9AttributeObject {
    readonly SigningTime: DateTime;
    CopyFrom(asnEncodedData: AsnEncodedData): void;
}


export const Pkcs9SigningTime: {
    new(): Pkcs9SigningTime;
    new(signingTime: DateTime): Pkcs9SigningTime;
    new(encodedSigningTime: byte[]): Pkcs9SigningTime;
};


export type Pkcs9SigningTime = Pkcs9SigningTime$instance;

export interface PublicKeyInfo$instance {
    readonly Algorithm: AlgorithmIdentifier;
    readonly KeyValue: byte[];
}


export const PublicKeyInfo: {
    new(): PublicKeyInfo;
};


export type PublicKeyInfo = PublicKeyInfo$instance;

export interface RecipientInfo$instance {
    readonly EncryptedKey: byte[];
    readonly KeyEncryptionAlgorithm: AlgorithmIdentifier;
    readonly RecipientIdentifier: SubjectIdentifier;
    readonly Type: RecipientInfoType;
    readonly Version: int;
}


export const RecipientInfo: {
};


export type RecipientInfo = RecipientInfo$instance;

export interface RecipientInfoCollection$instance {
    readonly Count: int;
    readonly IsSynchronized: boolean;
    readonly Item: RecipientInfo;
    readonly SyncRoot: unknown;
    CopyTo(array: ClrArray, index: int): void;
    CopyTo(array: RecipientInfo[], index: int): void;
    GetEnumerator(): RecipientInfoEnumerator;
}


export const RecipientInfoCollection: {
    new(): RecipientInfoCollection;
};


export type RecipientInfoCollection = RecipientInfoCollection$instance;

export interface RecipientInfoEnumerator$instance {
    readonly Current: RecipientInfo;
    MoveNext(): boolean;
    Reset(): void;
}


export const RecipientInfoEnumerator: {
    new(): RecipientInfoEnumerator;
};


export type RecipientInfoEnumerator = RecipientInfoEnumerator$instance;

export interface Rfc3161TimestampRequest$instance {
    readonly HasExtensions: boolean;
    readonly HashAlgorithmId: Oid;
    readonly RequestedPolicyId: Oid | undefined;
    readonly RequestSignerCertificate: boolean;
    readonly Version: int;
    Encode(): byte[];
    GetExtensions(): X509ExtensionCollection;
    GetMessageHash(): ReadOnlyMemory<System_Internal.Byte>;
    GetNonce(): Nullable<ReadOnlyMemory<System_Internal.Byte>>;
    ProcessResponse(responseBytes: ReadOnlyMemory<System_Internal.Byte>, bytesConsumed: int): Rfc3161TimestampToken;
    TryEncode(destination: Span<System_Internal.Byte>, bytesWritten: int): boolean;
}


export const Rfc3161TimestampRequest: {
    new(): Rfc3161TimestampRequest;
    CreateFromData(data: ReadOnlySpan<System_Internal.Byte>, hashAlgorithm: HashAlgorithmName, requestedPolicyId?: Oid, nonce?: Nullable<ReadOnlyMemory<System_Internal.Byte>>, requestSignerCertificates?: boolean, extensions?: X509ExtensionCollection): Rfc3161TimestampRequest;
    CreateFromHash(hash: ReadOnlyMemory<System_Internal.Byte>, hashAlgorithm: HashAlgorithmName, requestedPolicyId?: Oid, nonce?: Nullable<ReadOnlyMemory<System_Internal.Byte>>, requestSignerCertificates?: boolean, extensions?: X509ExtensionCollection): Rfc3161TimestampRequest;
    CreateFromHash(hash: ReadOnlyMemory<System_Internal.Byte>, hashAlgorithmId: Oid, requestedPolicyId?: Oid, nonce?: Nullable<ReadOnlyMemory<System_Internal.Byte>>, requestSignerCertificates?: boolean, extensions?: X509ExtensionCollection): Rfc3161TimestampRequest;
    CreateFromSignerInfo(signerInfo: SignerInfo, hashAlgorithm: HashAlgorithmName, requestedPolicyId?: Oid, nonce?: Nullable<ReadOnlyMemory<System_Internal.Byte>>, requestSignerCertificates?: boolean, extensions?: X509ExtensionCollection): Rfc3161TimestampRequest;
    TryDecode(encodedBytes: ReadOnlyMemory<System_Internal.Byte>, request: Rfc3161TimestampRequest, bytesConsumed: int): boolean;
};


export type Rfc3161TimestampRequest = Rfc3161TimestampRequest$instance;

export interface Rfc3161TimestampToken$instance {
    readonly TokenInfo: Rfc3161TimestampTokenInfo;
    AsSignedCms(): SignedCms;
    VerifySignatureForData(data: ReadOnlySpan<System_Internal.Byte>, signerCertificate: X509Certificate2, extraCandidates?: X509Certificate2Collection): boolean;
    VerifySignatureForHash(hash: ReadOnlySpan<System_Internal.Byte>, hashAlgorithm: HashAlgorithmName, signerCertificate: X509Certificate2, extraCandidates?: X509Certificate2Collection): boolean;
    VerifySignatureForHash(hash: ReadOnlySpan<System_Internal.Byte>, hashAlgorithmId: Oid, signerCertificate: X509Certificate2, extraCandidates?: X509Certificate2Collection): boolean;
    VerifySignatureForSignerInfo(signerInfo: SignerInfo, signerCertificate: X509Certificate2, extraCandidates?: X509Certificate2Collection): boolean;
}


export const Rfc3161TimestampToken: {
    new(): Rfc3161TimestampToken;
    TryDecode(encodedBytes: ReadOnlyMemory<System_Internal.Byte>, token: Rfc3161TimestampToken, bytesConsumed: int): boolean;
};


export type Rfc3161TimestampToken = Rfc3161TimestampToken$instance;

export interface Rfc3161TimestampTokenInfo$instance {
    readonly AccuracyInMicroseconds: Nullable<System_Internal.Int64>;
    readonly HasExtensions: boolean;
    readonly HashAlgorithmId: Oid;
    readonly IsOrdering: boolean;
    readonly PolicyId: Oid;
    readonly Timestamp: DateTimeOffset;
    readonly Version: int;
    Encode(): byte[];
    GetExtensions(): X509ExtensionCollection;
    GetMessageHash(): ReadOnlyMemory<System_Internal.Byte>;
    GetNonce(): Nullable<ReadOnlyMemory<System_Internal.Byte>>;
    GetSerialNumber(): ReadOnlyMemory<System_Internal.Byte>;
    GetTimestampAuthorityName(): Nullable<ReadOnlyMemory<System_Internal.Byte>>;
    TryEncode(destination: Span<System_Internal.Byte>, bytesWritten: int): boolean;
}


export const Rfc3161TimestampTokenInfo: {
    new(policyId: Oid, hashAlgorithmId: Oid, messageHash: ReadOnlyMemory<System_Internal.Byte>, serialNumber: ReadOnlyMemory<System_Internal.Byte>, timestamp: DateTimeOffset, accuracyInMicroseconds: Nullable<System_Internal.Int64>, isOrdering: boolean, nonce: Nullable<ReadOnlyMemory<System_Internal.Byte>>, timestampAuthorityName: Nullable<ReadOnlyMemory<System_Internal.Byte>>, extensions: X509ExtensionCollection): Rfc3161TimestampTokenInfo;
    TryDecode(encodedBytes: ReadOnlyMemory<System_Internal.Byte>, timestampTokenInfo: Rfc3161TimestampTokenInfo, bytesConsumed: int): boolean;
};


export type Rfc3161TimestampTokenInfo = Rfc3161TimestampTokenInfo$instance;

export interface SignedCms$instance {
    readonly Certificates: X509Certificate2Collection;
    readonly ContentInfo: ContentInfo;
    readonly Detached: boolean;
    readonly SignerInfos: SignerInfoCollection;
    readonly Version: int;
    AddCertificate(certificate: X509Certificate2): void;
    CheckHash(): void;
    CheckSignature(verifySignatureOnly: boolean): void;
    CheckSignature(extraStore: X509Certificate2Collection, verifySignatureOnly: boolean): void;
    ComputeSignature(): void;
    ComputeSignature(signer: CmsSigner): void;
    ComputeSignature(signer: CmsSigner, silent: boolean): void;
    Decode(encodedMessage: byte[]): void;
    Decode(encodedMessage: ReadOnlySpan<System_Internal.Byte>): void;
    Encode(): byte[];
    RemoveCertificate(certificate: X509Certificate2): void;
    RemoveSignature(index: int): void;
    RemoveSignature(signerInfo: SignerInfo): void;
}


export const SignedCms: {
    new(signerIdentifierType: SubjectIdentifierType, contentInfo: ContentInfo, detached: boolean): SignedCms;
    new(): SignedCms;
    new(signerIdentifierType: SubjectIdentifierType): SignedCms;
    new(contentInfo: ContentInfo): SignedCms;
    new(signerIdentifierType: SubjectIdentifierType, contentInfo: ContentInfo): SignedCms;
    new(contentInfo: ContentInfo, detached: boolean): SignedCms;
};


export type SignedCms = SignedCms$instance;

export interface SignerInfo$instance {
    readonly Certificate: X509Certificate2;
    readonly CounterSignerInfos: SignerInfoCollection;
    readonly DigestAlgorithm: Oid;
    readonly SignatureAlgorithm: Oid;
    readonly SignedAttributes: CryptographicAttributeObjectCollection;
    readonly SignerIdentifier: SubjectIdentifier;
    readonly UnsignedAttributes: CryptographicAttributeObjectCollection;
    readonly Version: int;
    AddUnsignedAttribute(unsignedAttribute: AsnEncodedData): void;
    CheckHash(): void;
    CheckSignature(verifySignatureOnly: boolean): void;
    CheckSignature(extraStore: X509Certificate2Collection, verifySignatureOnly: boolean): void;
    ComputeCounterSignature(): void;
    ComputeCounterSignature(signer: CmsSigner): void;
    GetSignature(): byte[];
    RemoveCounterSignature(index: int): void;
    RemoveCounterSignature(counterSignerInfo: SignerInfo): void;
    RemoveUnsignedAttribute(unsignedAttribute: AsnEncodedData): void;
}


export const SignerInfo: {
    new(): SignerInfo;
};


export type SignerInfo = SignerInfo$instance;

export interface SignerInfoCollection$instance {
    readonly Count: int;
    readonly IsSynchronized: boolean;
    readonly Item: SignerInfo;
    readonly SyncRoot: unknown;
    CopyTo(array: ClrArray, index: int): void;
    CopyTo(array: SignerInfo[], index: int): void;
    GetEnumerator(): SignerInfoEnumerator;
}


export const SignerInfoCollection: {
    new(): SignerInfoCollection;
};


export type SignerInfoCollection = SignerInfoCollection$instance;

export interface SignerInfoEnumerator$instance {
    readonly Current: SignerInfo;
    MoveNext(): boolean;
    Reset(): void;
}


export const SignerInfoEnumerator: {
    new(): SignerInfoEnumerator;
};


export type SignerInfoEnumerator = SignerInfoEnumerator$instance;

export interface SubjectIdentifier$instance {
    readonly Type: SubjectIdentifierType;
    readonly Value: unknown;
    MatchesCertificate(certificate: X509Certificate2): boolean;
}


export const SubjectIdentifier: {
    new(): SubjectIdentifier;
};


export type SubjectIdentifier = SubjectIdentifier$instance;

export interface SubjectIdentifierOrKey$instance {
    readonly Type: SubjectIdentifierOrKeyType;
    readonly Value: unknown;
}


export const SubjectIdentifierOrKey: {
    new(): SubjectIdentifierOrKey;
};


export type SubjectIdentifierOrKey = SubjectIdentifierOrKey$instance;

