// Generated by tsbindgen - Architecture
// Namespace: System.Security.Cryptography.Pkcs
// Assembly: System.Security.Cryptography.Pkcs

// Primitive type aliases from @tsonic/core
import type { sbyte, byte, short, ushort, int, uint, long, ulong, int128, uint128, half, float, double, decimal, nint, nuint, char } from '@tsonic/core/types.js';

// Import support types from @tsonic/core
import type { ptr } from "@tsonic/core/types.js";

// Import types from other namespaces
import type { CryptographicAttributeObject, CryptographicAttributeObjectCollection } from "../../System.Security.Cryptography/internal/index.js";
import type { IEnumerable as IEnumerable__System_Collections_Generic } from "@tsonic/dotnet/System.Collections.Generic.js";
import * as System_Collections_Internal from "@tsonic/dotnet/System.Collections.js";
import type { ICollection, IEnumerable, IEnumerator } from "@tsonic/dotnet/System.Collections.js";
import type { ReadOnlyCollection } from "@tsonic/dotnet/System.Collections.ObjectModel.js";
import * as System_Internal from "@tsonic/dotnet/System.js";
import type { Array as ClrArray, Boolean as ClrBoolean, Byte, Char, DateTime, DateTimeOffset, Enum, IComparable, IConvertible, IFormattable, Int32, Int64, ISpanFormattable, Nullable, Object as ClrObject, ReadOnlyMemory, ReadOnlySpan, Span, String as ClrString, Void } from "@tsonic/dotnet/System.js";
import * as System_Security_Cryptography_Lib from "@tsonic/dotnet/System.Security.Cryptography.js";
import type { AsnEncodedData, AsymmetricAlgorithm, CompositeMLDsa, CspParameters, HashAlgorithmName, MLDsa, Oid, PbeParameters, RSA, RSAEncryptionPadding, RSASignaturePadding, SlhDsa } from "@tsonic/dotnet/System.Security.Cryptography.js";
import type { X509Certificate2, X509Certificate2Collection, X509ExtensionCollection, X509IncludeOption } from "@tsonic/dotnet/System.Security.Cryptography.X509Certificates.js";

export enum Pkcs12ConfidentialityMode {
    unknown_ = 0,
    none = 1,
    password = 2,
    publicKey = 3
}


export enum Pkcs12IntegrityMode {
    unknown_ = 0,
    none = 1,
    password = 2,
    publicKey = 3
}


export enum RecipientInfoType {
    unknown_ = 0,
    keyTransport = 1,
    keyAgreement = 2
}


export enum SubjectIdentifierOrKeyType {
    unknown_ = 0,
    issuerAndSerialNumber = 1,
    subjectKeyIdentifier = 2,
    publicKeyInfo = 3
}


export enum SubjectIdentifierType {
    unknown_ = 0,
    issuerAndSerialNumber = 1,
    subjectKeyIdentifier = 2,
    noSignature = 3
}


export interface AlgorithmIdentifier$instance {
    keyLength: int;
    oid: Oid;
    parameters: byte[];
}


export const AlgorithmIdentifier: {
    new(): AlgorithmIdentifier;
    new(oid: Oid): AlgorithmIdentifier;
    new(oid: Oid, keyLength: int): AlgorithmIdentifier;
};


export type AlgorithmIdentifier = AlgorithmIdentifier$instance;

export interface CmsRecipient$instance {
    readonly certificate: X509Certificate2;
    readonly recipientIdentifierType: SubjectIdentifierType;
    readonly rsaEncryptionPadding: RSAEncryptionPadding | undefined;
}


export const CmsRecipient: {
    new(certificate: X509Certificate2): CmsRecipient;
    new(certificate: X509Certificate2, rsaEncryptionPadding: RSAEncryptionPadding): CmsRecipient;
    new(recipientIdentifierType: SubjectIdentifierType, certificate: X509Certificate2, rsaEncryptionPadding: RSAEncryptionPadding): CmsRecipient;
    new(recipientIdentifierType: SubjectIdentifierType, certificate: X509Certificate2): CmsRecipient;
};


export type CmsRecipient = CmsRecipient$instance;

export interface CmsRecipientCollection$instance {
    readonly count: int;
    readonly isSynchronized: boolean;
    readonly item: CmsRecipient;
    readonly syncRoot: unknown;
    add(recipient: CmsRecipient): int;
    copyTo(array: ClrArray, index: int): void;
    copyTo(array: CmsRecipient[], index: int): void;
    getEnumerator(): CmsRecipientEnumerator;
    remove(recipient: CmsRecipient): void;
}


export const CmsRecipientCollection: {
    new(): CmsRecipientCollection;
    new(recipient: CmsRecipient): CmsRecipientCollection;
    new(recipientIdentifierType: SubjectIdentifierType, certificates: X509Certificate2Collection): CmsRecipientCollection;
};


export type CmsRecipientCollection = CmsRecipientCollection$instance;

export interface CmsRecipientEnumerator$instance {
    readonly current: CmsRecipient;
    moveNext(): boolean;
    reset(): void;
}


export const CmsRecipientEnumerator: {
    new(): CmsRecipientEnumerator;
};


export type CmsRecipientEnumerator = CmsRecipientEnumerator$instance;

export interface CmsSigner$instance {
    certificate: X509Certificate2;
    readonly certificates: X509Certificate2Collection;
    digestAlgorithm: Oid;
    includeOption: X509IncludeOption;
    get privateKey(): AsymmetricAlgorithm | undefined;
    set privateKey(value: AsymmetricAlgorithm);
    get signaturePadding(): RSASignaturePadding | undefined;
    set signaturePadding(value: RSASignaturePadding);
    readonly signedAttributes: CryptographicAttributeObjectCollection;
    signerIdentifierType: SubjectIdentifierType;
    readonly unsignedAttributes: CryptographicAttributeObjectCollection;
}


export const CmsSigner: {
    new(): CmsSigner;
    new(signerIdentifierType: SubjectIdentifierType): CmsSigner;
    new(certificate: X509Certificate2): CmsSigner;
    new(parameters: CspParameters): CmsSigner;
    new(signerIdentifierType: SubjectIdentifierType, certificate: X509Certificate2): CmsSigner;
    new(signerIdentifierType: SubjectIdentifierType, certificate: X509Certificate2, privateKey: AsymmetricAlgorithm): CmsSigner;
    new(signerIdentifierType: SubjectIdentifierType, certificate: X509Certificate2, privateKey: MLDsa): CmsSigner;
    new(signerIdentifierType: SubjectIdentifierType, certificate: X509Certificate2, privateKey: SlhDsa): CmsSigner;
    new(signerIdentifierType: SubjectIdentifierType, certificate: X509Certificate2, privateKey: CompositeMLDsa): CmsSigner;
    new(signerIdentifierType: SubjectIdentifierType, certificate: X509Certificate2, privateKey: RSA, signaturePadding: RSASignaturePadding): CmsSigner;
};


export type CmsSigner = CmsSigner$instance;

export interface ContentInfo$instance {
    readonly content: byte[];
    readonly contentType: Oid;
}


export const ContentInfo: {
    new(content: byte[]): ContentInfo;
    new(contentType: Oid, content: byte[]): ContentInfo;
    getContentType(encodedMessage: byte[]): Oid;
    getContentType(encodedMessage: ReadOnlySpan<System_Internal.Byte>): Oid;
};


export type ContentInfo = ContentInfo$instance;

export interface EnvelopedCms$instance {
    readonly certificates: X509Certificate2Collection;
    readonly contentEncryptionAlgorithm: AlgorithmIdentifier;
    readonly contentInfo: ContentInfo;
    readonly recipientInfos: RecipientInfoCollection;
    readonly unprotectedAttributes: CryptographicAttributeObjectCollection;
    readonly version: int;
    decode(encodedMessage: byte[]): void;
    decode(encodedMessage: ReadOnlySpan<System_Internal.Byte>): void;
    decrypt(): void;
    decrypt(recipientInfo: RecipientInfo): void;
    decrypt(recipientInfo: RecipientInfo, extraStore: X509Certificate2Collection): void;
    decrypt(extraStore: X509Certificate2Collection): void;
    decrypt(recipientInfo: RecipientInfo, privateKey: AsymmetricAlgorithm): void;
    encode(): byte[];
    encrypt(recipient: CmsRecipient): void;
    encrypt(recipients: CmsRecipientCollection): void;
}


export const EnvelopedCms: {
    new(): EnvelopedCms;
    new(contentInfo: ContentInfo): EnvelopedCms;
    new(contentInfo: ContentInfo, encryptionAlgorithm: AlgorithmIdentifier): EnvelopedCms;
};


export type EnvelopedCms = EnvelopedCms$instance;

export interface KeyAgreeRecipientInfo$instance extends RecipientInfo {
    readonly date: DateTime;
    readonly encryptedKey: byte[];
    readonly keyEncryptionAlgorithm: AlgorithmIdentifier;
    readonly originatorIdentifierOrKey: SubjectIdentifierOrKey;
    readonly otherKeyAttribute: CryptographicAttributeObject | undefined;
    readonly recipientIdentifier: SubjectIdentifier;
    readonly version: int;
}


export const KeyAgreeRecipientInfo: {
    new(): KeyAgreeRecipientInfo;
};


export type KeyAgreeRecipientInfo = KeyAgreeRecipientInfo$instance;

export interface KeyTransRecipientInfo$instance extends RecipientInfo {
    readonly encryptedKey: byte[];
    readonly keyEncryptionAlgorithm: AlgorithmIdentifier;
    readonly recipientIdentifier: SubjectIdentifier;
    readonly version: int;
}


export const KeyTransRecipientInfo: {
    new(): KeyTransRecipientInfo;
};


export type KeyTransRecipientInfo = KeyTransRecipientInfo$instance;

export interface Pkcs12Builder$instance {
    readonly isSealed: boolean;
    addSafeContentsEncrypted(safeContents: Pkcs12SafeContents, passwordBytes: byte[], pbeParameters: PbeParameters): void;
    addSafeContentsEncrypted(safeContents: Pkcs12SafeContents, passwordBytes: ReadOnlySpan<System_Internal.Byte>, pbeParameters: PbeParameters): void;
    addSafeContentsEncrypted(safeContents: Pkcs12SafeContents, password: string, pbeParameters: PbeParameters): void;
    addSafeContentsEncrypted(safeContents: Pkcs12SafeContents, password: ReadOnlySpan<System_Internal.Char>, pbeParameters: PbeParameters): void;
    addSafeContentsUnencrypted(safeContents: Pkcs12SafeContents): void;
    encode(): byte[];
    sealWithMac(password: string, hashAlgorithm: HashAlgorithmName, iterationCount: int): void;
    sealWithMac(password: ReadOnlySpan<System_Internal.Char>, hashAlgorithm: HashAlgorithmName, iterationCount: int): void;
    sealWithoutIntegrity(): void;
    tryEncode(destination: Span<System_Internal.Byte>, bytesWritten: int): boolean;
}


export const Pkcs12Builder: {
    new(): Pkcs12Builder;
};


export type Pkcs12Builder = Pkcs12Builder$instance;

export interface Pkcs12CertBag$instance extends Pkcs12SafeBag {
    readonly encodedCertificate: ReadOnlyMemory<System_Internal.Byte>;
    readonly isX509Certificate: boolean;
    getCertificate(): X509Certificate2;
    getCertificateType(): Oid;
}


export const Pkcs12CertBag: {
    new(certificateType: Oid, encodedCertificate: ReadOnlyMemory<System_Internal.Byte>): Pkcs12CertBag;
};


export type Pkcs12CertBag = Pkcs12CertBag$instance;

export interface Pkcs12Info$instance {
    readonly authenticatedSafe: ReadOnlyCollection<Pkcs12SafeContents>;
    readonly integrityMode: Pkcs12IntegrityMode;
    verifyMac(password: string): boolean;
    verifyMac(password: ReadOnlySpan<System_Internal.Char>): boolean;
}


export const Pkcs12Info: {
    new(): Pkcs12Info;
    decode(encodedBytes: ReadOnlyMemory<System_Internal.Byte>, bytesConsumed: int, skipCopy?: boolean): Pkcs12Info;
};


export type Pkcs12Info = Pkcs12Info$instance;

export interface Pkcs12KeyBag$instance extends Pkcs12SafeBag {
    readonly pkcs8PrivateKey: ReadOnlyMemory<System_Internal.Byte>;
}


export const Pkcs12KeyBag: {
    new(pkcs8PrivateKey: ReadOnlyMemory<System_Internal.Byte>, skipCopy: boolean): Pkcs12KeyBag;
};


export type Pkcs12KeyBag = Pkcs12KeyBag$instance;

export interface Pkcs12SafeBag$instance {
    readonly attributes: CryptographicAttributeObjectCollection;
    readonly encodedBagValue: ReadOnlyMemory<System_Internal.Byte>;
    encode(): byte[];
    getBagId(): Oid;
    tryEncode(destination: Span<System_Internal.Byte>, bytesWritten: int): boolean;
}


export const Pkcs12SafeBag: {
};


export type Pkcs12SafeBag = Pkcs12SafeBag$instance;

export interface Pkcs12SafeContents$instance {
    readonly confidentialityMode: Pkcs12ConfidentialityMode;
    readonly isReadOnly: boolean;
    addCertificate(certificate: X509Certificate2): Pkcs12CertBag;
    addKeyUnencrypted(key: AsymmetricAlgorithm): Pkcs12KeyBag;
    addNestedContents(safeContents: Pkcs12SafeContents): Pkcs12SafeContentsBag;
    addSafeBag(safeBag: Pkcs12SafeBag): void;
    addSecret(secretType: Oid, secretValue: ReadOnlyMemory<System_Internal.Byte>): Pkcs12SecretBag;
    addShroudedKey(key: AsymmetricAlgorithm, passwordBytes: byte[], pbeParameters: PbeParameters): Pkcs12ShroudedKeyBag;
    addShroudedKey(key: AsymmetricAlgorithm, passwordBytes: ReadOnlySpan<System_Internal.Byte>, pbeParameters: PbeParameters): Pkcs12ShroudedKeyBag;
    addShroudedKey(key: AsymmetricAlgorithm, password: string, pbeParameters: PbeParameters): Pkcs12ShroudedKeyBag;
    addShroudedKey(key: AsymmetricAlgorithm, password: ReadOnlySpan<System_Internal.Char>, pbeParameters: PbeParameters): Pkcs12ShroudedKeyBag;
    decrypt(passwordBytes: byte[]): void;
    decrypt(passwordBytes: ReadOnlySpan<System_Internal.Byte>): void;
    decrypt(password: string): void;
    decrypt(password: ReadOnlySpan<System_Internal.Char>): void;
    getBags(): IEnumerable__System_Collections_Generic<Pkcs12SafeBag>;
}


export const Pkcs12SafeContents: {
    new(): Pkcs12SafeContents;
};


export type Pkcs12SafeContents = Pkcs12SafeContents$instance;

export interface Pkcs12SafeContentsBag$instance extends Pkcs12SafeBag {
    readonly safeContents: Pkcs12SafeContents | undefined;
}


export const Pkcs12SafeContentsBag: {
    new(): Pkcs12SafeContentsBag;
};


export type Pkcs12SafeContentsBag = Pkcs12SafeContentsBag$instance;

export interface Pkcs12SecretBag$instance extends Pkcs12SafeBag {
    readonly secretValue: ReadOnlyMemory<System_Internal.Byte>;
    getSecretType(): Oid;
}


export const Pkcs12SecretBag: {
    new(): Pkcs12SecretBag;
};


export type Pkcs12SecretBag = Pkcs12SecretBag$instance;

export interface Pkcs12ShroudedKeyBag$instance extends Pkcs12SafeBag {
    readonly encryptedPkcs8PrivateKey: ReadOnlyMemory<System_Internal.Byte>;
}


export const Pkcs12ShroudedKeyBag: {
    new(encryptedPkcs8PrivateKey: ReadOnlyMemory<System_Internal.Byte>, skipCopy: boolean): Pkcs12ShroudedKeyBag;
};


export type Pkcs12ShroudedKeyBag = Pkcs12ShroudedKeyBag$instance;

export interface Pkcs8PrivateKeyInfo$instance {
    readonly algorithmId: Oid;
    readonly algorithmParameters: Nullable<ReadOnlyMemory<System_Internal.Byte>>;
    readonly attributes: CryptographicAttributeObjectCollection;
    readonly privateKeyBytes: ReadOnlyMemory<System_Internal.Byte>;
    encode(): byte[];
    encrypt(password: ReadOnlySpan<System_Internal.Char>, pbeParameters: PbeParameters): byte[];
    encrypt(passwordBytes: ReadOnlySpan<System_Internal.Byte>, pbeParameters: PbeParameters): byte[];
    tryEncode(destination: Span<System_Internal.Byte>, bytesWritten: int): boolean;
    tryEncrypt(password: ReadOnlySpan<System_Internal.Char>, pbeParameters: PbeParameters, destination: Span<System_Internal.Byte>, bytesWritten: int): boolean;
    tryEncrypt(passwordBytes: ReadOnlySpan<System_Internal.Byte>, pbeParameters: PbeParameters, destination: Span<System_Internal.Byte>, bytesWritten: int): boolean;
}


export const Pkcs8PrivateKeyInfo: {
    new(algorithmId: Oid, algorithmParameters: Nullable<ReadOnlyMemory<System_Internal.Byte>>, privateKey: ReadOnlyMemory<System_Internal.Byte>, skipCopies: boolean): Pkcs8PrivateKeyInfo;
    create(privateKey: AsymmetricAlgorithm): Pkcs8PrivateKeyInfo;
    decode(source: ReadOnlyMemory<System_Internal.Byte>, bytesRead: int, skipCopy?: boolean): Pkcs8PrivateKeyInfo;
    decryptAndDecode(passwordBytes: ReadOnlySpan<System_Internal.Byte>, source: ReadOnlyMemory<System_Internal.Byte>, bytesRead: int): Pkcs8PrivateKeyInfo;
    decryptAndDecode(password: ReadOnlySpan<System_Internal.Char>, source: ReadOnlyMemory<System_Internal.Byte>, bytesRead: int): Pkcs8PrivateKeyInfo;
};


export type Pkcs8PrivateKeyInfo = Pkcs8PrivateKeyInfo$instance;

export interface Pkcs9AttributeObject$instance extends AsnEncodedData {
    readonly oid: Oid | undefined;
    copyFrom(asnEncodedData: AsnEncodedData): void;
}


export const Pkcs9AttributeObject: {
    new(): Pkcs9AttributeObject;
    new(oid: string, encodedData: byte[]): Pkcs9AttributeObject;
    new(oid: Oid, encodedData: byte[]): Pkcs9AttributeObject;
    new(asnEncodedData: AsnEncodedData): Pkcs9AttributeObject;
};


export type Pkcs9AttributeObject = Pkcs9AttributeObject$instance;

export interface Pkcs9ContentType$instance extends Pkcs9AttributeObject {
    readonly contentType: Oid;
    copyFrom(asnEncodedData: AsnEncodedData): void;
}


export const Pkcs9ContentType: {
    new(): Pkcs9ContentType;
};


export type Pkcs9ContentType = Pkcs9ContentType$instance;

export interface Pkcs9DocumentDescription$instance extends Pkcs9AttributeObject {
    readonly documentDescription: string;
    copyFrom(asnEncodedData: AsnEncodedData): void;
}


export const Pkcs9DocumentDescription: {
    new(): Pkcs9DocumentDescription;
    new(documentDescription: string): Pkcs9DocumentDescription;
    new(encodedDocumentDescription: byte[]): Pkcs9DocumentDescription;
};


export type Pkcs9DocumentDescription = Pkcs9DocumentDescription$instance;

export interface Pkcs9DocumentName$instance extends Pkcs9AttributeObject {
    readonly documentName: string;
    copyFrom(asnEncodedData: AsnEncodedData): void;
}


export const Pkcs9DocumentName: {
    new(): Pkcs9DocumentName;
    new(documentName: string): Pkcs9DocumentName;
    new(encodedDocumentName: byte[]): Pkcs9DocumentName;
};


export type Pkcs9DocumentName = Pkcs9DocumentName$instance;

export interface Pkcs9LocalKeyId$instance extends Pkcs9AttributeObject {
    readonly keyId: ReadOnlyMemory<System_Internal.Byte>;
    copyFrom(asnEncodedData: AsnEncodedData): void;
}


export const Pkcs9LocalKeyId: {
    new(): Pkcs9LocalKeyId;
    new(keyId: byte[]): Pkcs9LocalKeyId;
    new(keyId: ReadOnlySpan<System_Internal.Byte>): Pkcs9LocalKeyId;
};


export type Pkcs9LocalKeyId = Pkcs9LocalKeyId$instance;

export interface Pkcs9MessageDigest$instance extends Pkcs9AttributeObject {
    readonly messageDigest: byte[];
    copyFrom(asnEncodedData: AsnEncodedData): void;
}


export const Pkcs9MessageDigest: {
    new(): Pkcs9MessageDigest;
};


export type Pkcs9MessageDigest = Pkcs9MessageDigest$instance;

export interface Pkcs9SigningTime$instance extends Pkcs9AttributeObject {
    readonly signingTime: DateTime;
    copyFrom(asnEncodedData: AsnEncodedData): void;
}


export const Pkcs9SigningTime: {
    new(): Pkcs9SigningTime;
    new(signingTime: DateTime): Pkcs9SigningTime;
    new(encodedSigningTime: byte[]): Pkcs9SigningTime;
};


export type Pkcs9SigningTime = Pkcs9SigningTime$instance;

export interface PublicKeyInfo$instance {
    readonly algorithm: AlgorithmIdentifier;
    readonly keyValue: byte[];
}


export const PublicKeyInfo: {
    new(): PublicKeyInfo;
};


export type PublicKeyInfo = PublicKeyInfo$instance;

export interface RecipientInfo$instance {
    readonly encryptedKey: byte[];
    readonly keyEncryptionAlgorithm: AlgorithmIdentifier;
    readonly recipientIdentifier: SubjectIdentifier;
    readonly type_: RecipientInfoType;
    readonly version: int;
}


export const RecipientInfo: {
};


export type RecipientInfo = RecipientInfo$instance;

export interface RecipientInfoCollection$instance {
    readonly count: int;
    readonly isSynchronized: boolean;
    readonly item: RecipientInfo;
    readonly syncRoot: unknown;
    copyTo(array: ClrArray, index: int): void;
    copyTo(array: RecipientInfo[], index: int): void;
    getEnumerator(): RecipientInfoEnumerator;
}


export const RecipientInfoCollection: {
    new(): RecipientInfoCollection;
};


export type RecipientInfoCollection = RecipientInfoCollection$instance;

export interface RecipientInfoEnumerator$instance {
    readonly current: RecipientInfo;
    moveNext(): boolean;
    reset(): void;
}


export const RecipientInfoEnumerator: {
    new(): RecipientInfoEnumerator;
};


export type RecipientInfoEnumerator = RecipientInfoEnumerator$instance;

export interface Rfc3161TimestampRequest$instance {
    readonly hasExtensions: boolean;
    readonly hashAlgorithmId: Oid;
    readonly requestedPolicyId: Oid | undefined;
    readonly requestSignerCertificate: boolean;
    readonly version: int;
    encode(): byte[];
    getExtensions(): X509ExtensionCollection;
    getMessageHash(): ReadOnlyMemory<System_Internal.Byte>;
    getNonce(): Nullable<ReadOnlyMemory<System_Internal.Byte>>;
    processResponse(responseBytes: ReadOnlyMemory<System_Internal.Byte>, bytesConsumed: int): Rfc3161TimestampToken;
    tryEncode(destination: Span<System_Internal.Byte>, bytesWritten: int): boolean;
}


export const Rfc3161TimestampRequest: {
    new(): Rfc3161TimestampRequest;
    createFromData(data: ReadOnlySpan<System_Internal.Byte>, hashAlgorithm: HashAlgorithmName, requestedPolicyId?: Oid, nonce?: Nullable<ReadOnlyMemory<System_Internal.Byte>>, requestSignerCertificates?: boolean, extensions?: X509ExtensionCollection): Rfc3161TimestampRequest;
    createFromHash(hash: ReadOnlyMemory<System_Internal.Byte>, hashAlgorithm: HashAlgorithmName, requestedPolicyId?: Oid, nonce?: Nullable<ReadOnlyMemory<System_Internal.Byte>>, requestSignerCertificates?: boolean, extensions?: X509ExtensionCollection): Rfc3161TimestampRequest;
    createFromHash(hash: ReadOnlyMemory<System_Internal.Byte>, hashAlgorithmId: Oid, requestedPolicyId?: Oid, nonce?: Nullable<ReadOnlyMemory<System_Internal.Byte>>, requestSignerCertificates?: boolean, extensions?: X509ExtensionCollection): Rfc3161TimestampRequest;
    createFromSignerInfo(signerInfo: SignerInfo, hashAlgorithm: HashAlgorithmName, requestedPolicyId?: Oid, nonce?: Nullable<ReadOnlyMemory<System_Internal.Byte>>, requestSignerCertificates?: boolean, extensions?: X509ExtensionCollection): Rfc3161TimestampRequest;
    tryDecode(encodedBytes: ReadOnlyMemory<System_Internal.Byte>, request: Rfc3161TimestampRequest, bytesConsumed: int): boolean;
};


export type Rfc3161TimestampRequest = Rfc3161TimestampRequest$instance;

export interface Rfc3161TimestampToken$instance {
    readonly tokenInfo: Rfc3161TimestampTokenInfo;
    asSignedCms(): SignedCms;
    verifySignatureForData(data: ReadOnlySpan<System_Internal.Byte>, signerCertificate: X509Certificate2, extraCandidates?: X509Certificate2Collection): boolean;
    verifySignatureForHash(hash: ReadOnlySpan<System_Internal.Byte>, hashAlgorithm: HashAlgorithmName, signerCertificate: X509Certificate2, extraCandidates?: X509Certificate2Collection): boolean;
    verifySignatureForHash(hash: ReadOnlySpan<System_Internal.Byte>, hashAlgorithmId: Oid, signerCertificate: X509Certificate2, extraCandidates?: X509Certificate2Collection): boolean;
    verifySignatureForSignerInfo(signerInfo: SignerInfo, signerCertificate: X509Certificate2, extraCandidates?: X509Certificate2Collection): boolean;
}


export const Rfc3161TimestampToken: {
    new(): Rfc3161TimestampToken;
    tryDecode(encodedBytes: ReadOnlyMemory<System_Internal.Byte>, token: Rfc3161TimestampToken, bytesConsumed: int): boolean;
};


export type Rfc3161TimestampToken = Rfc3161TimestampToken$instance;

export interface Rfc3161TimestampTokenInfo$instance {
    readonly accuracyInMicroseconds: Nullable<System_Internal.Int64>;
    readonly hasExtensions: boolean;
    readonly hashAlgorithmId: Oid;
    readonly isOrdering: boolean;
    readonly policyId: Oid;
    readonly timestamp: DateTimeOffset;
    readonly version: int;
    encode(): byte[];
    getExtensions(): X509ExtensionCollection;
    getMessageHash(): ReadOnlyMemory<System_Internal.Byte>;
    getNonce(): Nullable<ReadOnlyMemory<System_Internal.Byte>>;
    getSerialNumber(): ReadOnlyMemory<System_Internal.Byte>;
    getTimestampAuthorityName(): Nullable<ReadOnlyMemory<System_Internal.Byte>>;
    tryEncode(destination: Span<System_Internal.Byte>, bytesWritten: int): boolean;
}


export const Rfc3161TimestampTokenInfo: {
    new(policyId: Oid, hashAlgorithmId: Oid, messageHash: ReadOnlyMemory<System_Internal.Byte>, serialNumber: ReadOnlyMemory<System_Internal.Byte>, timestamp: DateTimeOffset, accuracyInMicroseconds: Nullable<System_Internal.Int64>, isOrdering: boolean, nonce: Nullable<ReadOnlyMemory<System_Internal.Byte>>, timestampAuthorityName: Nullable<ReadOnlyMemory<System_Internal.Byte>>, extensions: X509ExtensionCollection): Rfc3161TimestampTokenInfo;
    tryDecode(encodedBytes: ReadOnlyMemory<System_Internal.Byte>, timestampTokenInfo: Rfc3161TimestampTokenInfo, bytesConsumed: int): boolean;
};


export type Rfc3161TimestampTokenInfo = Rfc3161TimestampTokenInfo$instance;

export interface SignedCms$instance {
    readonly certificates: X509Certificate2Collection;
    readonly contentInfo: ContentInfo;
    readonly detached: boolean;
    readonly signerInfos: SignerInfoCollection;
    readonly version: int;
    addCertificate(certificate: X509Certificate2): void;
    checkHash(): void;
    checkSignature(verifySignatureOnly: boolean): void;
    checkSignature(extraStore: X509Certificate2Collection, verifySignatureOnly: boolean): void;
    computeSignature(): void;
    computeSignature(signer: CmsSigner): void;
    computeSignature(signer: CmsSigner, silent: boolean): void;
    decode(encodedMessage: byte[]): void;
    decode(encodedMessage: ReadOnlySpan<System_Internal.Byte>): void;
    encode(): byte[];
    removeCertificate(certificate: X509Certificate2): void;
    removeSignature(index: int): void;
    removeSignature(signerInfo: SignerInfo): void;
}


export const SignedCms: {
    new(signerIdentifierType: SubjectIdentifierType, contentInfo: ContentInfo, detached: boolean): SignedCms;
    new(): SignedCms;
    new(signerIdentifierType: SubjectIdentifierType): SignedCms;
    new(contentInfo: ContentInfo): SignedCms;
    new(signerIdentifierType: SubjectIdentifierType, contentInfo: ContentInfo): SignedCms;
    new(contentInfo: ContentInfo, detached: boolean): SignedCms;
};


export type SignedCms = SignedCms$instance;

export interface SignerInfo$instance {
    readonly certificate: X509Certificate2;
    readonly counterSignerInfos: SignerInfoCollection;
    readonly digestAlgorithm: Oid;
    readonly signatureAlgorithm: Oid;
    readonly signedAttributes: CryptographicAttributeObjectCollection;
    readonly signerIdentifier: SubjectIdentifier;
    readonly unsignedAttributes: CryptographicAttributeObjectCollection;
    readonly version: int;
    addUnsignedAttribute(unsignedAttribute: AsnEncodedData): void;
    checkHash(): void;
    checkSignature(verifySignatureOnly: boolean): void;
    checkSignature(extraStore: X509Certificate2Collection, verifySignatureOnly: boolean): void;
    computeCounterSignature(): void;
    computeCounterSignature(signer: CmsSigner): void;
    getSignature(): byte[];
    removeCounterSignature(index: int): void;
    removeCounterSignature(counterSignerInfo: SignerInfo): void;
    removeUnsignedAttribute(unsignedAttribute: AsnEncodedData): void;
}


export const SignerInfo: {
    new(): SignerInfo;
};


export type SignerInfo = SignerInfo$instance;

export interface SignerInfoCollection$instance {
    readonly count: int;
    readonly isSynchronized: boolean;
    readonly item: SignerInfo;
    readonly syncRoot: unknown;
    copyTo(array: ClrArray, index: int): void;
    copyTo(array: SignerInfo[], index: int): void;
    getEnumerator(): SignerInfoEnumerator;
}


export const SignerInfoCollection: {
    new(): SignerInfoCollection;
};


export type SignerInfoCollection = SignerInfoCollection$instance;

export interface SignerInfoEnumerator$instance {
    readonly current: SignerInfo;
    moveNext(): boolean;
    reset(): void;
}


export const SignerInfoEnumerator: {
    new(): SignerInfoEnumerator;
};


export type SignerInfoEnumerator = SignerInfoEnumerator$instance;

export interface SubjectIdentifier$instance {
    readonly type_: SubjectIdentifierType;
    readonly value: unknown;
    matchesCertificate(certificate: X509Certificate2): boolean;
}


export const SubjectIdentifier: {
    new(): SubjectIdentifier;
};


export type SubjectIdentifier = SubjectIdentifier$instance;

export interface SubjectIdentifierOrKey$instance {
    readonly type_: SubjectIdentifierOrKeyType;
    readonly value: unknown;
}


export const SubjectIdentifierOrKey: {
    new(): SubjectIdentifierOrKey;
};


export type SubjectIdentifierOrKey = SubjectIdentifierOrKey$instance;

