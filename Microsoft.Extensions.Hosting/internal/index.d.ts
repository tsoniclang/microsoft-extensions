// Generated by tsbindgen - Architecture
// Namespace: Microsoft.Extensions.Hosting
// Assembly: Microsoft.Extensions.Hosting, Microsoft.Extensions.Hosting.Abstractions

// Primitive type aliases from @tsonic/core
import type { sbyte, byte, short, ushort, int, uint, long, ulong, int128, uint128, half, float, double, decimal, nint, nuint, char } from '@tsonic/core/types.js';

// Import types from other namespaces
import type { ConfigurationManager, IConfiguration, IConfigurationBuilder, IConfigurationManager } from "../../Microsoft.Extensions.Configuration/internal/index.js";
import type { IServiceCollection, IServiceProviderFactory_1, ServiceProviderOptions } from "../../Microsoft.Extensions.DependencyInjection/internal/index.js";
import type { IMetricsBuilder } from "../../Microsoft.Extensions.Diagnostics.Metrics/internal/index.js";
import type { IFileProvider } from "../../Microsoft.Extensions.FileProviders/internal/index.js";
import type { ILoggingBuilder } from "../../Microsoft.Extensions.Logging/internal/index.js";
import type { IDictionary } from "@tsonic/dotnet/System.Collections.Generic.js";
import * as System_Internal from "@tsonic/dotnet/System.js";
import type { Action, Boolean as ClrBoolean, Enum, Exception, Func, IComparable, IConvertible, IDisposable, IFormattable, Int32, IServiceProvider, ISpanFormattable, Object as ClrObject, String as ClrString, TimeSpan, Void } from "@tsonic/dotnet/System.js";
import * as System_Runtime_Serialization_Internal from "@tsonic/dotnet/System.Runtime.Serialization.js";
import type { ISerializable } from "@tsonic/dotnet/System.Runtime.Serialization.js";
import type { CancellationToken } from "@tsonic/dotnet/System.Threading.js";
import type { Task } from "@tsonic/dotnet/System.Threading.Tasks.js";

export enum BackgroundServiceExceptionBehavior {
    stopHost = 0,
    ignore = 1
}


export interface IApplicationLifetime$instance {
    readonly applicationStarted: CancellationToken;
    readonly applicationStopping: CancellationToken;
    readonly applicationStopped: CancellationToken;
    stopApplication(): void;
}


export type IApplicationLifetime = IApplicationLifetime$instance;

export interface IHost$instance extends IDisposable {
    readonly services: IServiceProvider;
    startAsync(cancellationToken?: CancellationToken): Task;
}


export type IHost = IHost$instance;

export interface IHostApplicationBuilder$instance {
    readonly properties: IDictionary<unknown, unknown>;
    readonly configuration: IConfigurationManager;
    readonly environment: IHostEnvironment;
    readonly logging: ILoggingBuilder;
    readonly metrics: IMetricsBuilder;
    readonly services: IServiceCollection;
    configureContainer<TContainerBuilder>(factory: IServiceProviderFactory_1<TContainerBuilder>, configure?: Action<TContainerBuilder>): void;
}


export type IHostApplicationBuilder = IHostApplicationBuilder$instance;

export interface IHostApplicationLifetime$instance {
    readonly applicationStarted: CancellationToken;
    readonly applicationStopping: CancellationToken;
    readonly applicationStopped: CancellationToken;
    stopApplication(): void;
}


export type IHostApplicationLifetime = IHostApplicationLifetime$instance;

export interface IHostBuilder$instance {
    readonly properties: IDictionary<unknown, unknown>;
    build(): IHost;
    configureAppConfiguration(configureDelegate: Action<HostBuilderContext, IConfigurationBuilder>): IHostBuilder;
    configureHostConfiguration(configureDelegate: Action<IConfigurationBuilder>): IHostBuilder;
    useServiceProviderFactory<TContainerBuilder>(factory: Func<HostBuilderContext, IServiceProviderFactory_1<TContainerBuilder>>): IHostBuilder;
    useServiceProviderFactory<TContainerBuilder>(factory: IServiceProviderFactory_1<TContainerBuilder>): IHostBuilder;
}


export type IHostBuilder = IHostBuilder$instance;

export interface IHostedLifecycleService$instance extends IHostedService {
    startingAsync(cancellationToken: CancellationToken): Task;
    startAsync(cancellationToken: CancellationToken): Task;
}


export interface IHostedLifecycleService$instance extends IHostedService$instance {}

export type IHostedLifecycleService = IHostedLifecycleService$instance;

export interface IHostedService$instance {
    startAsync(cancellationToken: CancellationToken): Task;
}


export type IHostedService = IHostedService$instance;

export interface IHostEnvironment$instance {
    environmentName: string;
    applicationName: string;
    contentRootPath: string;
    contentRootFileProvider: IFileProvider;
}


export type IHostEnvironment = IHostEnvironment$instance;

export interface IHostingEnvironment$instance {
    environmentName: string;
    applicationName: string;
    contentRootPath: string;
    contentRootFileProvider: IFileProvider;
}


export type IHostingEnvironment = IHostingEnvironment$instance;

export interface IHostLifetime$instance {
    waitForStartAsync(cancellationToken: CancellationToken): Task;
}


export type IHostLifetime = IHostLifetime$instance;

export interface BackgroundService$instance {
    readonly executeTask: Task | undefined;
    dispose(): void;
    startAsync(cancellationToken: CancellationToken): Task;
    stopAsync(cancellationToken: CancellationToken): Task;
}


export const BackgroundService: {
};


export interface __BackgroundService$views {
    As_IHostedService(): IHostedService$instance;
}

export interface BackgroundService$instance extends IHostedService$instance {}

export type BackgroundService = BackgroundService$instance & __BackgroundService$views;


export interface ConsoleLifetimeOptions$instance {
    suppressStatusMessages: boolean;
}


export const ConsoleLifetimeOptions: {
    new(): ConsoleLifetimeOptions;
};


export type ConsoleLifetimeOptions = ConsoleLifetimeOptions$instance;

export interface HostAbortedException$instance extends Exception {
}


export const HostAbortedException: {
    new(): HostAbortedException;
    new(message: string): HostAbortedException;
    new(message: string, innerException: Exception): HostAbortedException;
};


export type HostAbortedException = HostAbortedException$instance;

export interface HostApplicationBuilder$instance {
    readonly configuration: ConfigurationManager;
    readonly environment: IHostEnvironment;
    readonly logging: ILoggingBuilder;
    readonly metrics: IMetricsBuilder;
    readonly services: IServiceCollection;
    build(): IHost;
    configureContainer<TContainerBuilder>(factory: IServiceProviderFactory_1<TContainerBuilder>, configure?: Action<TContainerBuilder>): void;
}


export const HostApplicationBuilder: {
    new(): HostApplicationBuilder;
    new(args: string[]): HostApplicationBuilder;
    new(settings: HostApplicationBuilderSettings): HostApplicationBuilder;
};


export interface __HostApplicationBuilder$views {
    As_IHostApplicationBuilder(): IHostApplicationBuilder$instance;
}

export type HostApplicationBuilder = HostApplicationBuilder$instance & __HostApplicationBuilder$views;


export interface HostApplicationBuilderSettings$instance {
    applicationName: string;
    args: string[];
    configuration: ConfigurationManager;
    contentRootPath: string;
    disableDefaults: boolean;
    environmentName: string;
}


export const HostApplicationBuilderSettings: {
    new(): HostApplicationBuilderSettings;
};


export type HostApplicationBuilderSettings = HostApplicationBuilderSettings$instance;

export interface HostBuilder$instance {
    readonly properties: IDictionary<unknown, unknown>;
    build(): IHost;
    configureAppConfiguration(configureDelegate: Action<HostBuilderContext, IConfigurationBuilder>): IHostBuilder;
    configureContainer<TContainerBuilder>(configureDelegate: Action<HostBuilderContext, TContainerBuilder>): IHostBuilder;
    configureHostConfiguration(configureDelegate: Action<IConfigurationBuilder>): IHostBuilder;
    configureServices(configureDelegate: Action<HostBuilderContext, IServiceCollection>): IHostBuilder;
    useServiceProviderFactory<TContainerBuilder>(factory: IServiceProviderFactory_1<TContainerBuilder>): IHostBuilder;
    useServiceProviderFactory<TContainerBuilder>(factory: Func<HostBuilderContext, IServiceProviderFactory_1<TContainerBuilder>>): IHostBuilder;
}


export const HostBuilder: {
    new(): HostBuilder;
};


export interface __HostBuilder$views {
    As_IHostBuilder(): IHostBuilder$instance;
}

export type HostBuilder = HostBuilder$instance & __HostBuilder$views;


export interface HostBuilderContext$instance {
    configuration: IConfiguration;
    hostingEnvironment: IHostEnvironment;
    readonly properties: IDictionary<unknown, unknown>;
}


export const HostBuilderContext: {
    new(properties: IDictionary<unknown, unknown>): HostBuilderContext;
};


export type HostBuilderContext = HostBuilderContext$instance;

export interface HostOptions$instance {
    backgroundServiceExceptionBehavior: BackgroundServiceExceptionBehavior;
    servicesStartConcurrently: boolean;
    servicesStopConcurrently: boolean;
    shutdownTimeout: TimeSpan;
    startupTimeout: TimeSpan;
}


export const HostOptions: {
    new(): HostOptions;
};


export type HostOptions = HostOptions$instance;

export abstract class EnvironmentName$instance {
    static readonly development: string;
    static readonly staging: string;
    static readonly production: string;
}


export type EnvironmentName = EnvironmentName$instance;

export abstract class Environments$instance {
    static readonly development: string;
    static readonly staging: string;
    static readonly production: string;
}


export type Environments = Environments$instance;

export abstract class Host$instance {
    static createApplicationBuilder(): HostApplicationBuilder;
    static createApplicationBuilder(settings: HostApplicationBuilderSettings): HostApplicationBuilder;
    static createApplicationBuilder(args: string[]): HostApplicationBuilder;
    static createDefaultBuilder(): IHostBuilder;
    static createDefaultBuilder(args: string[]): IHostBuilder;
    static createEmptyApplicationBuilder(settings: HostApplicationBuilderSettings): HostApplicationBuilder;
}


export type Host = Host$instance;

export abstract class HostDefaults$instance {
    static readonly applicationKey: string;
    static readonly environmentKey: string;
    static readonly contentRootKey: string;
}


export type HostDefaults = HostDefaults$instance;

export abstract class HostEnvironmentEnvExtensions$instance {
    static isDevelopment(hostEnvironment: IHostEnvironment): boolean;
    static isEnvironment(hostEnvironment: IHostEnvironment, environmentName: string): boolean;
    static isProduction(hostEnvironment: IHostEnvironment): boolean;
    static isStaging(hostEnvironment: IHostEnvironment): boolean;
}


export type HostEnvironmentEnvExtensions = HostEnvironmentEnvExtensions$instance;

export abstract class HostingAbstractionsHostBuilderExtensions$instance {
    static start(hostBuilder: IHostBuilder): IHost;
    static startAsync(hostBuilder: IHostBuilder, cancellationToken?: CancellationToken): Task<IHost>;
}


export type HostingAbstractionsHostBuilderExtensions = HostingAbstractionsHostBuilderExtensions$instance;

export abstract class HostingAbstractionsHostExtensions$instance {
    static run(host: IHost): void;
    static runAsync(host: IHost, token?: CancellationToken): Task;
    static start(host: IHost): void;
    static stopAsync(host: IHost, timeout: TimeSpan): Task;
    static waitForShutdown(host: IHost): void;
    static waitForShutdownAsync(host: IHost, token?: CancellationToken): Task;
}


export type HostingAbstractionsHostExtensions = HostingAbstractionsHostExtensions$instance;

export abstract class HostingEnvironmentExtensions$instance {
    static isDevelopment(hostingEnvironment: IHostingEnvironment): boolean;
    static isEnvironment(hostingEnvironment: IHostingEnvironment, environmentName: string): boolean;
    static isProduction(hostingEnvironment: IHostingEnvironment): boolean;
    static isStaging(hostingEnvironment: IHostingEnvironment): boolean;
}


export type HostingEnvironmentExtensions = HostingEnvironmentExtensions$instance;

export abstract class HostingHostBuilderExtensions$instance {
    static configureAppConfiguration(hostBuilder: IHostBuilder, configureDelegate: Action<IConfigurationBuilder>): IHostBuilder;
    static configureContainer<TContainerBuilder>(hostBuilder: IHostBuilder, configureDelegate: Action<TContainerBuilder>): IHostBuilder;
    static configureDefaults(builder: IHostBuilder, args: string[]): IHostBuilder;
    static configureHostOptions(hostBuilder: IHostBuilder, configureOptions: Action<HostOptions>): IHostBuilder;
    static configureHostOptions(hostBuilder: IHostBuilder, configureOptions: Action<HostBuilderContext, HostOptions>): IHostBuilder;
    static configureLogging(hostBuilder: IHostBuilder, configureLogging: Action<ILoggingBuilder>): IHostBuilder;
    static configureLogging(hostBuilder: IHostBuilder, configureLogging: Action<HostBuilderContext, ILoggingBuilder>): IHostBuilder;
    static configureMetrics(hostBuilder: IHostBuilder, configureMetrics: Action<IMetricsBuilder>): IHostBuilder;
    static configureMetrics(hostBuilder: IHostBuilder, configureMetrics: Action<HostBuilderContext, IMetricsBuilder>): IHostBuilder;
    static configureServices(hostBuilder: IHostBuilder, configureDelegate: Action<IServiceCollection>): IHostBuilder;
    static runConsoleAsync(hostBuilder: IHostBuilder, configureOptions: Action<ConsoleLifetimeOptions>, cancellationToken?: CancellationToken): Task;
    static runConsoleAsync(hostBuilder: IHostBuilder, cancellationToken?: CancellationToken): Task;
    static useConsoleLifetime(hostBuilder: IHostBuilder, configureOptions: Action<ConsoleLifetimeOptions>): IHostBuilder;
    static useConsoleLifetime(hostBuilder: IHostBuilder): IHostBuilder;
    static useContentRoot(hostBuilder: IHostBuilder, contentRoot: string): IHostBuilder;
    static useDefaultServiceProvider(hostBuilder: IHostBuilder, configure: Action<ServiceProviderOptions>): IHostBuilder;
    static useDefaultServiceProvider(hostBuilder: IHostBuilder, configure: Action<HostBuilderContext, ServiceProviderOptions>): IHostBuilder;
    static useEnvironment(hostBuilder: IHostBuilder, environment: string): IHostBuilder;
}


export type HostingHostBuilderExtensions = HostingHostBuilderExtensions$instance;

