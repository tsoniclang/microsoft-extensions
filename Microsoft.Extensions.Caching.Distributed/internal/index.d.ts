// Generated by tsbindgen - Architecture
// Namespace: Microsoft.Extensions.Caching.Distributed
// Assembly: Microsoft.Extensions.Caching.Abstractions, Microsoft.Extensions.Caching.Memory

// Primitive type aliases from @tsonic/core
import type { sbyte, byte, short, ushort, int, uint, long, ulong, int128, uint128, half, float, double, decimal, nint, nuint, char } from '@tsonic/core/types.js';

// Import types from other namespaces
import type { MemoryDistributedCacheOptions } from "../../Microsoft.Extensions.Caching.Memory/internal/index.js";
import type { ILoggerFactory } from "../../Microsoft.Extensions.Logging/internal/index.js";
import type { IOptions_1 } from "../../Microsoft.Extensions.Options/internal/index.js";
import type { IBufferWriter, ReadOnlySequence } from "@tsonic/dotnet/System.Buffers.js";
import * as System_Internal from "@tsonic/dotnet/System.js";
import type { Boolean as ClrBoolean, Byte, DateTimeOffset, Nullable, Object as ClrObject, String as ClrString, TimeSpan, Void } from "@tsonic/dotnet/System.js";
import type { CancellationToken } from "@tsonic/dotnet/System.Threading.js";
import type { Task, ValueTask } from "@tsonic/dotnet/System.Threading.Tasks.js";

export interface IBufferDistributedCache$instance extends IDistributedCache {
    Get(key: string): byte[];
    GetAsync(key: string, token?: CancellationToken): Task<byte[] | undefined>;
    Refresh(key: string): void;
    RefreshAsync(key: string, token?: CancellationToken): Task;
    Set(key: string, value: ReadOnlySequence<System_Internal.Byte>, options: DistributedCacheEntryOptions): void;
    Set(key: string, value: byte[], options: DistributedCacheEntryOptions): void;
    SetAsync(key: string, value: ReadOnlySequence<System_Internal.Byte>, options: DistributedCacheEntryOptions, token?: CancellationToken): ValueTask;
    SetAsync(key: string, value: byte[], options: DistributedCacheEntryOptions, token?: CancellationToken): Task;
    TryGet(key: string, destination: IBufferWriter<System_Internal.Byte>): boolean;
    TryGetAsync(key: string, destination: IBufferWriter<System_Internal.Byte>, token?: CancellationToken): ValueTask<System_Internal.Boolean>;
}


export type IBufferDistributedCache = IBufferDistributedCache$instance;

export interface IDistributedCache$instance {
    Get(key: string): byte[];
    GetAsync(key: string, token?: CancellationToken): Task<byte[] | undefined>;
    Refresh(key: string): void;
    RefreshAsync(key: string, token?: CancellationToken): Task;
    Set(key: string, value: byte[], options: DistributedCacheEntryOptions): void;
    SetAsync(key: string, value: byte[], options: DistributedCacheEntryOptions, token?: CancellationToken): Task;
}


export type IDistributedCache = IDistributedCache$instance;

export interface DistributedCacheEntryOptions$instance {
    AbsoluteExpiration: Nullable<DateTimeOffset>;
    AbsoluteExpirationRelativeToNow: Nullable<TimeSpan>;
    SlidingExpiration: Nullable<TimeSpan>;
}


export const DistributedCacheEntryOptions: {
    new(): DistributedCacheEntryOptions;
};


export type DistributedCacheEntryOptions = DistributedCacheEntryOptions$instance;

export interface MemoryDistributedCache$instance {
    Get(key: string): byte[];
    GetAsync(key: string, token?: CancellationToken): Task<byte[] | undefined>;
    Refresh(key: string): void;
    RefreshAsync(key: string, token?: CancellationToken): Task;
    Remove(key: string): void;
    RemoveAsync(key: string, token?: CancellationToken): Task;
    Set(key: string, value: byte[], options: DistributedCacheEntryOptions): void;
    SetAsync(key: string, value: byte[], options: DistributedCacheEntryOptions, token?: CancellationToken): Task;
}


export const MemoryDistributedCache: {
    new(optionsAccessor: IOptions_1<MemoryDistributedCacheOptions>): MemoryDistributedCache;
    new(optionsAccessor: IOptions_1<MemoryDistributedCacheOptions>, loggerFactory: ILoggerFactory): MemoryDistributedCache;
};


export interface __MemoryDistributedCache$views {
    As_IDistributedCache(): IDistributedCache$instance;
}

export interface MemoryDistributedCache$instance extends IDistributedCache$instance {}

export type MemoryDistributedCache = MemoryDistributedCache$instance & __MemoryDistributedCache$views;


export abstract class DistributedCacheEntryExtensions$instance {
    static SetAbsoluteExpiration(options: DistributedCacheEntryOptions, absolute: DateTimeOffset): DistributedCacheEntryOptions;
    static SetAbsoluteExpiration(options: DistributedCacheEntryOptions, relative: TimeSpan): DistributedCacheEntryOptions;
    static SetSlidingExpiration(options: DistributedCacheEntryOptions, offset: TimeSpan): DistributedCacheEntryOptions;
}


export type DistributedCacheEntryExtensions = DistributedCacheEntryExtensions$instance;

export abstract class DistributedCacheExtensions$instance {
    static GetString(cache: IDistributedCache, key: string): string | undefined;
    static GetStringAsync(cache: IDistributedCache, key: string, token?: CancellationToken): Task<string | undefined>;
    static Set(cache: IDistributedCache, key: string, value: byte[]): void;
    static SetAsync(cache: IDistributedCache, key: string, value: byte[], token?: CancellationToken): Task;
    static SetString(cache: IDistributedCache, key: string, value: string, options: DistributedCacheEntryOptions): void;
    static SetString(cache: IDistributedCache, key: string, value: string): void;
    static SetStringAsync(cache: IDistributedCache, key: string, value: string, options: DistributedCacheEntryOptions, token?: CancellationToken): Task;
    static SetStringAsync(cache: IDistributedCache, key: string, value: string, token?: CancellationToken): Task;
}


export type DistributedCacheExtensions = DistributedCacheExtensions$instance;

