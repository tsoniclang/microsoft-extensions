// Generated by tsbindgen - Architecture
// Namespace: Microsoft.Extensions.Diagnostics.Metrics
// Assembly: Microsoft.Extensions.Diagnostics, Microsoft.Extensions.Diagnostics.Abstractions

// Primitive type aliases from @tsonic/core
import type { sbyte, byte, short, ushort, int, uint, long, ulong, int128, uint128, half, float, double, decimal, nint, nuint, char } from '@tsonic/core/types.js';

// Import support types from @tsonic/core
import type { ptr } from "@tsonic/core/types.js";

// Import types from other namespaces
import type { IConfiguration } from "../../Microsoft.Extensions.Configuration/internal/index.js";
import type { IServiceCollection } from "../../Microsoft.Extensions.DependencyInjection/internal/index.js";
import type { IList } from "@tsonic/dotnet/System.Collections.Generic.js";
import type { Instrument, MeasurementCallback } from "@tsonic/dotnet/System.Diagnostics.Metrics.js";
import * as System_Internal from "@tsonic/dotnet/System.js";
import type { Boolean as ClrBoolean, Byte, Decimal, Double, Enum, IComparable, IConvertible, IFormattable, Int16, Int32, Int64, ISpanFormattable, Object as ClrObject, Single, String as ClrString, Void } from "@tsonic/dotnet/System.js";

export enum MeterScope {
    None = 0,
    Global = 1,
    Local = 2
}


export interface IMetricsBuilder$instance {
    readonly Services: IServiceCollection;
}


export type IMetricsBuilder = IMetricsBuilder$instance;

export interface IMetricsListener$instance {
    readonly Name: string;
    GetMeasurementHandlers(): MeasurementHandlers;
    Initialize(source: IObservableInstrumentsSource): void;
    InstrumentPublished(instrument: Instrument, userState: unknown): boolean;
    MeasurementsCompleted(instrument: Instrument, userState: unknown): void;
}


export type IMetricsListener = IMetricsListener$instance;

export interface IObservableInstrumentsSource$instance {
    RecordObservableInstruments(): void;
}


export type IObservableInstrumentsSource = IObservableInstrumentsSource$instance;

export interface InstrumentRule$instance {
    readonly Enable: boolean;
    readonly InstrumentName: string | undefined;
    readonly ListenerName: string | undefined;
    readonly MeterName: string | undefined;
    readonly Scopes: MeterScope;
}


export const InstrumentRule: {
    new(meterName: string, instrumentName: string, listenerName: string, scopes: MeterScope, enable: boolean): InstrumentRule;
};


export type InstrumentRule = InstrumentRule$instance;

export interface MeasurementHandlers$instance {
    get ByteHandler(): MeasurementCallback<System_Internal.Byte> | undefined;
    set ByteHandler(value: MeasurementCallback<System_Internal.Byte>);
    get DecimalHandler(): MeasurementCallback<System_Internal.Decimal> | undefined;
    set DecimalHandler(value: MeasurementCallback<System_Internal.Decimal>);
    get DoubleHandler(): MeasurementCallback<System_Internal.Double> | undefined;
    set DoubleHandler(value: MeasurementCallback<System_Internal.Double>);
    get FloatHandler(): MeasurementCallback<System_Internal.Single> | undefined;
    set FloatHandler(value: MeasurementCallback<System_Internal.Single>);
    get IntHandler(): MeasurementCallback<System_Internal.Int32> | undefined;
    set IntHandler(value: MeasurementCallback<System_Internal.Int32>);
    get LongHandler(): MeasurementCallback<System_Internal.Int64> | undefined;
    set LongHandler(value: MeasurementCallback<System_Internal.Int64>);
    get ShortHandler(): MeasurementCallback<System_Internal.Int16> | undefined;
    set ShortHandler(value: MeasurementCallback<System_Internal.Int16>);
}


export const MeasurementHandlers: {
    new(): MeasurementHandlers;
};


export type MeasurementHandlers = MeasurementHandlers$instance;

export interface MetricsOptions$instance {
    readonly Rules: IList<InstrumentRule>;
}


export const MetricsOptions: {
    new(): MetricsOptions;
};


export type MetricsOptions = MetricsOptions$instance;

export abstract class ConsoleMetrics$instance {
    static readonly DebugListenerName: string;
}


export type ConsoleMetrics = ConsoleMetrics$instance;

export abstract class MetricsBuilderConfigurationExtensions$instance {
    static AddConfiguration(builder: IMetricsBuilder, configuration: IConfiguration): IMetricsBuilder;
}


export type MetricsBuilderConfigurationExtensions = MetricsBuilderConfigurationExtensions$instance;

export abstract class MetricsBuilderConsoleExtensions$instance {
    static AddDebugConsole(builder: IMetricsBuilder): IMetricsBuilder;
}


export type MetricsBuilderConsoleExtensions = MetricsBuilderConsoleExtensions$instance;

export abstract class MetricsBuilderExtensions$instance {
    static AddListener(builder: IMetricsBuilder, listener: IMetricsListener): IMetricsBuilder;
    static AddListener<T extends IMetricsListener>(builder: IMetricsBuilder): IMetricsBuilder;
    static ClearListeners(builder: IMetricsBuilder): IMetricsBuilder;
    static DisableMetrics(builder: IMetricsBuilder, meterName: string, instrumentName?: string, listenerName?: string, scopes?: MeterScope): IMetricsBuilder;
    static DisableMetrics(builder: IMetricsBuilder, meterName: string): IMetricsBuilder;
    static DisableMetrics(options: MetricsOptions, meterName: string, instrumentName?: string, listenerName?: string, scopes?: MeterScope): MetricsOptions;
    static DisableMetrics(options: MetricsOptions, meterName: string): MetricsOptions;
    static EnableMetrics(builder: IMetricsBuilder, meterName: string, instrumentName?: string, listenerName?: string, scopes?: MeterScope): IMetricsBuilder;
    static EnableMetrics(builder: IMetricsBuilder, meterName: string): IMetricsBuilder;
    static EnableMetrics(options: MetricsOptions, meterName: string, instrumentName?: string, listenerName?: string, scopes?: MeterScope): MetricsOptions;
    static EnableMetrics(options: MetricsOptions, meterName: string): MetricsOptions;
}


export type MetricsBuilderExtensions = MetricsBuilderExtensions$instance;

