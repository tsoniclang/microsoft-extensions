// Generated by tsbindgen - Architecture
// Namespace: Microsoft.Extensions.Diagnostics.Metrics
// Assembly: Microsoft.Extensions.Diagnostics, Microsoft.Extensions.Diagnostics.Abstractions

// Primitive type aliases from @tsonic/core
import type { sbyte, byte, short, ushort, int, uint, long, ulong, int128, uint128, half, float, double, decimal, nint, nuint, char } from '@tsonic/core/types.js';

// Import support types from @tsonic/core
import type { ptr } from "@tsonic/core/types.js";

// Import types from other namespaces
import type { IConfiguration } from "../../Microsoft.Extensions.Configuration/internal/index.js";
import type { IServiceCollection } from "../../Microsoft.Extensions.DependencyInjection/internal/index.js";
import type { IList } from "@tsonic/dotnet/System.Collections.Generic.js";
import type { Instrument, MeasurementCallback } from "@tsonic/dotnet/System.Diagnostics.Metrics.js";
import * as System_Internal from "@tsonic/dotnet/System.js";
import type { Boolean as ClrBoolean, Byte, Decimal, Double, Enum, IComparable, IConvertible, IFormattable, Int16, Int32, Int64, ISpanFormattable, Object as ClrObject, Single, String as ClrString, Void } from "@tsonic/dotnet/System.js";

export enum MeterScope {
    none = 0,
    global = 1,
    local = 2
}


export interface IMetricsBuilder$instance {
    readonly services: IServiceCollection;
}


export type IMetricsBuilder = IMetricsBuilder$instance;

export interface IMetricsListener$instance {
    readonly name: string;
    getMeasurementHandlers(): MeasurementHandlers;
    initialize(source: IObservableInstrumentsSource): void;
    instrumentPublished(instrument: Instrument, userState: unknown): boolean;
    measurementsCompleted(instrument: Instrument, userState: unknown): void;
}


export type IMetricsListener = IMetricsListener$instance;

export interface IObservableInstrumentsSource$instance {
    recordObservableInstruments(): void;
}


export type IObservableInstrumentsSource = IObservableInstrumentsSource$instance;

export interface InstrumentRule$instance {
    readonly enable: boolean;
    readonly instrumentName: string | undefined;
    readonly listenerName: string | undefined;
    readonly meterName: string | undefined;
    readonly scopes: MeterScope;
}


export const InstrumentRule: {
    new(meterName: string, instrumentName: string, listenerName: string, scopes: MeterScope, enable: boolean): InstrumentRule;
};


export type InstrumentRule = InstrumentRule$instance;

export interface MeasurementHandlers$instance {
    get byteHandler(): MeasurementCallback<System_Internal.Byte> | undefined;
    set byteHandler(value: MeasurementCallback<System_Internal.Byte>);
    get decimalHandler(): MeasurementCallback<System_Internal.Decimal> | undefined;
    set decimalHandler(value: MeasurementCallback<System_Internal.Decimal>);
    get doubleHandler(): MeasurementCallback<System_Internal.Double> | undefined;
    set doubleHandler(value: MeasurementCallback<System_Internal.Double>);
    get floatHandler(): MeasurementCallback<System_Internal.Single> | undefined;
    set floatHandler(value: MeasurementCallback<System_Internal.Single>);
    get intHandler(): MeasurementCallback<System_Internal.Int32> | undefined;
    set intHandler(value: MeasurementCallback<System_Internal.Int32>);
    get longHandler(): MeasurementCallback<System_Internal.Int64> | undefined;
    set longHandler(value: MeasurementCallback<System_Internal.Int64>);
    get shortHandler(): MeasurementCallback<System_Internal.Int16> | undefined;
    set shortHandler(value: MeasurementCallback<System_Internal.Int16>);
}


export const MeasurementHandlers: {
    new(): MeasurementHandlers;
};


export type MeasurementHandlers = MeasurementHandlers$instance;

export interface MetricsOptions$instance {
    readonly rules: IList<InstrumentRule>;
}


export const MetricsOptions: {
    new(): MetricsOptions;
};


export type MetricsOptions = MetricsOptions$instance;

export abstract class ConsoleMetrics$instance {
    static readonly debugListenerName: string;
}


export type ConsoleMetrics = ConsoleMetrics$instance;

export abstract class MetricsBuilderConfigurationExtensions$instance {
    static addConfiguration(builder: IMetricsBuilder, configuration: IConfiguration): IMetricsBuilder;
}


export type MetricsBuilderConfigurationExtensions = MetricsBuilderConfigurationExtensions$instance;

export abstract class MetricsBuilderConsoleExtensions$instance {
    static addDebugConsole(builder: IMetricsBuilder): IMetricsBuilder;
}


export type MetricsBuilderConsoleExtensions = MetricsBuilderConsoleExtensions$instance;

export abstract class MetricsBuilderExtensions$instance {
    static addListener(builder: IMetricsBuilder, listener: IMetricsListener): IMetricsBuilder;
    static addListener<T extends IMetricsListener>(builder: IMetricsBuilder): IMetricsBuilder;
    static clearListeners(builder: IMetricsBuilder): IMetricsBuilder;
    static disableMetrics(builder: IMetricsBuilder, meterName: string, instrumentName?: string, listenerName?: string, scopes?: MeterScope): IMetricsBuilder;
    static disableMetrics(builder: IMetricsBuilder, meterName: string): IMetricsBuilder;
    static disableMetrics(options: MetricsOptions, meterName: string, instrumentName?: string, listenerName?: string, scopes?: MeterScope): MetricsOptions;
    static disableMetrics(options: MetricsOptions, meterName: string): MetricsOptions;
    static enableMetrics(builder: IMetricsBuilder, meterName: string, instrumentName?: string, listenerName?: string, scopes?: MeterScope): IMetricsBuilder;
    static enableMetrics(builder: IMetricsBuilder, meterName: string): IMetricsBuilder;
    static enableMetrics(options: MetricsOptions, meterName: string, instrumentName?: string, listenerName?: string, scopes?: MeterScope): MetricsOptions;
    static enableMetrics(options: MetricsOptions, meterName: string): MetricsOptions;
}


export type MetricsBuilderExtensions = MetricsBuilderExtensions$instance;

