// Generated by tsbindgen - Architecture
// Namespace: Microsoft.Extensions.FileSystemGlobbing.Internal
// Assembly: Microsoft.Extensions.FileSystemGlobbing

// Primitive type aliases from @tsonic/core
import type { sbyte, byte, short, ushort, int, uint, long, ulong, int128, uint128, half, float, double, decimal, nint, nuint, char } from '@tsonic/core/types.js';

// Import types from other namespaces
import type { DirectoryInfoBase, FileInfoBase } from "../../Microsoft.Extensions.FileSystemGlobbing.Abstractions/internal/index.js";
import type { PatternMatchingResult } from "../../Microsoft.Extensions.FileSystemGlobbing/internal/index.js";
import type { IEnumerable, IList } from "@tsonic/dotnet/System.Collections.Generic.js";
import * as System_Internal from "@tsonic/dotnet/System.js";
import type { Action, Boolean as ClrBoolean, Object as ClrObject, String as ClrString, StringComparison, ValueType, Void } from "@tsonic/dotnet/System.js";

export interface ILinearPattern$instance extends IPattern {
    readonly segments: IList<IPathSegment>;
    createPatternContextForInclude(): IPatternContext;
}


export interface ILinearPattern$instance extends IPattern$instance {}

export type ILinearPattern = ILinearPattern$instance;

export interface IPathSegment$instance {
    readonly canProduceStem: boolean;
    match(value: string): boolean;
}


export type IPathSegment = IPathSegment$instance;

export interface IPattern$instance {
    createPatternContextForInclude(): IPatternContext;
}


export type IPattern = IPattern$instance;

export interface IPatternContext$instance {
    declare_(onDeclare: Action<IPathSegment, System_Internal.Boolean>): void;
    popDirectory(): void;
    pushDirectory(directory: DirectoryInfoBase): void;
    test(directory: DirectoryInfoBase): boolean;
    test(file: FileInfoBase): PatternTestResult;
}


export type IPatternContext = IPatternContext$instance;

export interface IRaggedPattern$instance extends IPattern {
    readonly segments: IList<IPathSegment>;
    readonly startsWith: IList<IPathSegment>;
    readonly contains: IList<IList<IPathSegment>>;
    readonly endsWith: IList<IPathSegment>;
    createPatternContextForInclude(): IPatternContext;
}


export interface IRaggedPattern$instance extends IPattern$instance {}

export type IRaggedPattern = IRaggedPattern$instance;

export interface PatternTestResult$instance {
    readonly isSuccessful: boolean;
    readonly stem: string;
}


export const PatternTestResult: {
    new(): PatternTestResult;
    readonly failed: PatternTestResult;
    success(stem: string): PatternTestResult;
};


export type PatternTestResult = PatternTestResult$instance;

export interface MatcherContext$instance {
    execute(): PatternMatchingResult;
}


export const MatcherContext: {
    new(includePatterns: IEnumerable<IPattern>, excludePatterns: IEnumerable<IPattern>, directoryInfo: DirectoryInfoBase, comparison: StringComparison): MatcherContext;
};


export type MatcherContext = MatcherContext$instance;

