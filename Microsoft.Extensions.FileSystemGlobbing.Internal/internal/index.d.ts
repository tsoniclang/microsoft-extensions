// Generated by tsbindgen - Architecture
// Namespace: Microsoft.Extensions.FileSystemGlobbing.Internal
// Assembly: Microsoft.Extensions.FileSystemGlobbing

// Primitive type aliases from @tsonic/core
import type { sbyte, byte, short, ushort, int, uint, long, ulong, int128, uint128, half, float, double, decimal, nint, nuint, char } from '@tsonic/core/types.js';

// Import types from other namespaces
import type { DirectoryInfoBase, FileInfoBase } from "../../Microsoft.Extensions.FileSystemGlobbing.Abstractions/internal/index.js";
import type { PatternMatchingResult } from "../../Microsoft.Extensions.FileSystemGlobbing/internal/index.js";
import type { IEnumerable, IList } from "@tsonic/dotnet/System.Collections.Generic.js";
import * as System_Internal from "@tsonic/dotnet/System.js";
import type { Action, Boolean as ClrBoolean, Object as ClrObject, String as ClrString, StringComparison, ValueType, Void } from "@tsonic/dotnet/System.js";

export interface ILinearPattern$instance extends IPattern {
    readonly Segments: IList<IPathSegment>;
    CreatePatternContextForInclude(): IPatternContext;
}


export interface ILinearPattern$instance extends IPattern$instance {}

export type ILinearPattern = ILinearPattern$instance;

export interface IPathSegment$instance {
    readonly CanProduceStem: boolean;
    Match(value: string): boolean;
}


export type IPathSegment = IPathSegment$instance;

export interface IPattern$instance {
    CreatePatternContextForInclude(): IPatternContext;
}


export type IPattern = IPattern$instance;

export interface IPatternContext$instance {
    Declare(onDeclare: Action<IPathSegment, System_Internal.Boolean>): void;
    PopDirectory(): void;
    PushDirectory(directory: DirectoryInfoBase): void;
    Test(directory: DirectoryInfoBase): boolean;
    Test(file: FileInfoBase): PatternTestResult;
}


export type IPatternContext = IPatternContext$instance;

export interface IRaggedPattern$instance extends IPattern {
    readonly Segments: IList<IPathSegment>;
    readonly StartsWith: IList<IPathSegment>;
    readonly Contains: IList<IList<IPathSegment>>;
    readonly EndsWith: IList<IPathSegment>;
    CreatePatternContextForInclude(): IPatternContext;
}


export interface IRaggedPattern$instance extends IPattern$instance {}

export type IRaggedPattern = IRaggedPattern$instance;

export interface PatternTestResult$instance {
    readonly IsSuccessful: boolean;
    readonly Stem: string;
}


export const PatternTestResult: {
    new(): PatternTestResult;
    readonly Failed: PatternTestResult;
    Success(stem: string): PatternTestResult;
};


export type PatternTestResult = PatternTestResult$instance;

export interface MatcherContext$instance {
    Execute(): PatternMatchingResult;
}


export const MatcherContext: {
    new(includePatterns: IEnumerable<IPattern>, excludePatterns: IEnumerable<IPattern>, directoryInfo: DirectoryInfoBase, comparison: StringComparison): MatcherContext;
};


export type MatcherContext = MatcherContext$instance;

