// Generated by tsbindgen - Architecture
// Namespace: System.Diagnostics
// Assembly: System.Diagnostics.DiagnosticSource, System.Diagnostics.EventLog, System.Diagnostics.FileVersionInfo, System.Diagnostics.Process, System.Diagnostics.TextWriterTraceListener, System.Diagnostics.TraceSource, System.Private.CoreLib

// Primitive type aliases from @tsonic/core
import type { sbyte, byte, short, ushort, int, uint, long, ulong, int128, uint128, half, float, double, decimal, nint, nuint, char } from '@tsonic/core/types.js';

// Import types from other namespaces
import * as System_Collections_Internal from "@tsonic/dotnet/System.Collections.js";
import type { ICollection, IEnumerable, IEnumerator } from "@tsonic/dotnet/System.Collections.js";
import * as System_ComponentModel_Internal from "@tsonic/dotnet/System.ComponentModel.js";
import type { Component, IComponent, ISupportInitialize, ISynchronizeInvoke } from "@tsonic/dotnet/System.ComponentModel.js";
import * as System_Diagnostics_Internal from "@tsonic/dotnet/System.Diagnostics.js";
import type { TraceEventCache, TraceEventType, TraceListener } from "@tsonic/dotnet/System.Diagnostics.js";
import * as System_Internal from "@tsonic/dotnet/System.js";
import type { AsyncCallback, Boolean as ClrBoolean, Byte, DateTime, Enum, EventArgs, IAsyncResult, ICloneable, IComparable, IConvertible, IDisposable, IFormattable, Int16, Int32, Int64, IntPtr, ISpanFormattable, MulticastDelegate, Object as ClrObject, String as ClrString, Void } from "@tsonic/dotnet/System.js";
import * as System_Runtime_Serialization_Internal from "@tsonic/dotnet/System.Runtime.Serialization.js";
import type { ISerializable } from "@tsonic/dotnet/System.Runtime.Serialization.js";

export enum EventLogEntryType {
    Error = 1,
    Warning = 2,
    Information = 4,
    SuccessAudit = 8,
    FailureAudit = 16
}


export enum OverflowAction {
    DoNotOverwrite = -1,
    OverwriteAsNeeded = 0,
    OverwriteOlder = 1
}


export type EntryWrittenEventHandler = (sender: unknown, e: EntryWrittenEventArgs) => void;


export interface EntryWrittenEventArgs$instance extends EventArgs {
    readonly Entry: EventLogEntry;
}


export const EntryWrittenEventArgs: {
    new(): EntryWrittenEventArgs;
    new(entry: EventLogEntry): EntryWrittenEventArgs;
};


export type EntryWrittenEventArgs = EntryWrittenEventArgs$instance;

export interface EventInstance$instance {
    CategoryId: int;
    EntryType: EventLogEntryType;
    InstanceId: long;
}


export const EventInstance: {
    new(instanceId: long, categoryId: int): EventInstance;
    new(instanceId: long, categoryId: int, entryType: EventLogEntryType): EventInstance;
};


export type EventInstance = EventInstance$instance;

export abstract class EventLog$protected {
    protected Dispose(disposing: boolean): void;
}


export interface EventLog$instance extends EventLog$protected, Component {
    EnableRaisingEvents: boolean;
    readonly Entries: EventLogEntryCollection;
    Log: string;
    readonly LogDisplayName: string;
    get MachineName(): string | undefined;
    set MachineName(value: string);
    MaximumKilobytes: long;
    readonly MinimumRetentionDays: int;
    readonly OverflowAction: OverflowAction;
    Source: string;
    SynchronizingObject: ISynchronizeInvoke;
    BeginInit(): void;
    Clear(): void;
    Close(): void;
    EndInit(): void;
    ModifyOverflowPolicy(action: OverflowAction, retentionDays: int): void;
    RegisterDisplayName(resourceFile: string, resourceId: long): void;
    WriteEntry(message: string): void;
    WriteEntry(message: string, type: EventLogEntryType): void;
    WriteEntry(message: string, type: EventLogEntryType, eventID: int): void;
    WriteEntry(message: string, type: EventLogEntryType, eventID: int, category: short): void;
    WriteEntry(message: string, type: EventLogEntryType, eventID: int, category: short, rawData: byte[]): void;
    WriteEvent(instance: EventInstance, data: byte[], ...values: unknown[]): void;
    WriteEvent(instance: EventInstance, ...values: unknown[]): void;
}


export const EventLog: {
    new(): EventLog;
    new(logName: string): EventLog;
    new(logName: string, machineName: string): EventLog;
    new(logName: string, machineName: string, source: string): EventLog;
    CreateEventSource(sourceData: EventSourceCreationData): void;
    CreateEventSource(source: string, logName: string, machineName: string): void;
    CreateEventSource(source: string, logName: string): void;
    Delete(logName: string, machineName: string): void;
    Delete(logName: string): void;
    DeleteEventSource(source: string, machineName: string): void;
    DeleteEventSource(source: string): void;
    Exists(logName: string, machineName: string): boolean;
    Exists(logName: string): boolean;
    GetEventLogs(): EventLog[];
    GetEventLogs(machineName: string): EventLog[];
    LogNameFromSourceName(source: string, machineName: string): string;
    SourceExists(source: string, machineName: string): boolean;
    SourceExists(source: string): boolean;
    WriteEntry(source: string, message: string, type: EventLogEntryType, eventID: int, category: short, rawData: byte[]): void;
    WriteEntry(source: string, message: string, type: EventLogEntryType, eventID: int, category: short): void;
    WriteEntry(source: string, message: string, type: EventLogEntryType, eventID: int): void;
    WriteEntry(source: string, message: string, type: EventLogEntryType): void;
    WriteEntry(source: string, message: string): void;
    WriteEvent(source: string, instance: EventInstance, data: byte[], ...values: unknown[]): void;
    WriteEvent(source: string, instance: EventInstance, ...values: unknown[]): void;
};


export type EventLog = EventLog$instance;

export interface EventLogEntry$instance extends Component {
    readonly Category: string;
    readonly CategoryNumber: short;
    readonly Data: byte[];
    readonly EntryType: EventLogEntryType;
    readonly EventID: int;
    readonly Index: int;
    readonly InstanceId: long;
    readonly MachineName: string | undefined;
    readonly Message: string;
    readonly ReplacementStrings: string[];
    readonly Source: string;
    readonly TimeGenerated: DateTime;
    readonly TimeWritten: DateTime;
    readonly UserName: string;
    Equals(otherEntry: EventLogEntry): boolean;
}


export const EventLogEntry: {
    new(): EventLogEntry;
};


export type EventLogEntry = EventLogEntry$instance;

export interface EventLogEntryCollection$instance {
    readonly Count: int;
    readonly Item: EventLogEntry;
    CopyTo(entries: EventLogEntry[], index: int): void;
    GetEnumerator(): IEnumerator;
}


export const EventLogEntryCollection: {
    new(): EventLogEntryCollection;
};


export type EventLogEntryCollection = EventLogEntryCollection$instance;

export abstract class EventLogTraceListener$protected {
    protected Dispose(disposing: boolean): void;
}


export interface EventLogTraceListener$instance extends EventLogTraceListener$protected, TraceListener {
    EventLog: EventLog;
    Name: string;
    Close(): void;
    TraceData(eventCache: TraceEventCache, source: string, severity: TraceEventType, id: int, data: unknown): void;
    TraceData(eventCache: TraceEventCache, source: string, severity: TraceEventType, id: int, ...data: unknown[]): void;
    TraceEvent(eventCache: TraceEventCache, source: string, severity: TraceEventType, id: int, message: string): void;
    TraceEvent(eventCache: TraceEventCache, source: string, severity: TraceEventType, id: int, format: string, ...args: unknown[]): void;
    Write(message: string): void;
    WriteLine(message: string): void;
}


export const EventLogTraceListener: {
    new(): EventLogTraceListener;
    new(eventLog: EventLog): EventLogTraceListener;
    new(source: string): EventLogTraceListener;
};


export type EventLogTraceListener = EventLogTraceListener$instance;

export interface EventSourceCreationData$instance {
    CategoryCount: int;
    CategoryResourceFile: string;
    get LogName(): string | undefined;
    set LogName(value: string);
    get MachineName(): string | undefined;
    set MachineName(value: string);
    MessageResourceFile: string;
    ParameterResourceFile: string;
    Source: string;
}


export const EventSourceCreationData: {
    new(source: string, logName: string): EventSourceCreationData;
};


export type EventSourceCreationData = EventSourceCreationData$instance;

