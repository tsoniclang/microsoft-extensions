// Generated by tsbindgen - Architecture
// Namespace: System.Diagnostics
// Assembly: System.Diagnostics.DiagnosticSource, System.Diagnostics.EventLog, System.Diagnostics.FileVersionInfo, System.Diagnostics.Process, System.Diagnostics.TextWriterTraceListener, System.Diagnostics.TraceSource, System.Private.CoreLib

// Primitive type aliases from @tsonic/core
import type { sbyte, byte, short, ushort, int, uint, long, ulong, int128, uint128, half, float, double, decimal, nint, nuint, char } from '@tsonic/core/types.js';

// Import types from other namespaces
import * as System_Collections_Internal from "@tsonic/dotnet/System.Collections.js";
import type { ICollection, IEnumerable, IEnumerator } from "@tsonic/dotnet/System.Collections.js";
import * as System_ComponentModel_Internal from "@tsonic/dotnet/System.ComponentModel.js";
import type { Component, IComponent, ISupportInitialize, ISynchronizeInvoke } from "@tsonic/dotnet/System.ComponentModel.js";
import * as System_Diagnostics_Internal from "@tsonic/dotnet/System.Diagnostics.js";
import type { TraceEventCache, TraceEventType, TraceListener } from "@tsonic/dotnet/System.Diagnostics.js";
import * as System_Internal from "@tsonic/dotnet/System.js";
import type { AsyncCallback, Boolean as ClrBoolean, Byte, DateTime, Enum, EventArgs, IAsyncResult, ICloneable, IComparable, IConvertible, IDisposable, IFormattable, Int16, Int32, Int64, IntPtr, ISpanFormattable, MulticastDelegate, Object as ClrObject, String as ClrString, Void } from "@tsonic/dotnet/System.js";
import * as System_Runtime_Serialization_Internal from "@tsonic/dotnet/System.Runtime.Serialization.js";
import type { ISerializable } from "@tsonic/dotnet/System.Runtime.Serialization.js";

export enum EventLogEntryType {
    error = 1,
    warning = 2,
    information = 4,
    successAudit = 8,
    failureAudit = 16
}


export enum OverflowAction {
    doNotOverwrite = -1,
    overwriteAsNeeded = 0,
    overwriteOlder = 1
}


export type EntryWrittenEventHandler = (sender: unknown, e: EntryWrittenEventArgs) => void;


export interface EntryWrittenEventArgs$instance extends EventArgs {
    readonly entry: EventLogEntry;
}


export const EntryWrittenEventArgs: {
    new(): EntryWrittenEventArgs;
    new(entry: EventLogEntry): EntryWrittenEventArgs;
};


export type EntryWrittenEventArgs = EntryWrittenEventArgs$instance;

export interface EventInstance$instance {
    categoryId: int;
    entryType: EventLogEntryType;
    instanceId: long;
}


export const EventInstance: {
    new(instanceId: long, categoryId: int): EventInstance;
    new(instanceId: long, categoryId: int, entryType: EventLogEntryType): EventInstance;
};


export type EventInstance = EventInstance$instance;

export interface EventLog$instance extends Component {
    enableRaisingEvents: boolean;
    readonly entries: EventLogEntryCollection;
    log: string;
    readonly logDisplayName: string;
    get machineName(): string | undefined;
    set machineName(value: string);
    maximumKilobytes: long;
    readonly minimumRetentionDays: int;
    readonly overflowAction: OverflowAction;
    source: string;
    synchronizingObject: ISynchronizeInvoke;
    beginInit(): void;
    clear(): void;
    close(): void;
    endInit(): void;
    modifyOverflowPolicy(action: OverflowAction, retentionDays: int): void;
    registerDisplayName(resourceFile: string, resourceId: long): void;
    writeEntry(message: string): void;
    writeEntry(message: string, type_: EventLogEntryType): void;
    writeEntry(message: string, type_: EventLogEntryType, eventID: int): void;
    writeEntry(message: string, type_: EventLogEntryType, eventID: int, category: short): void;
    writeEntry(message: string, type_: EventLogEntryType, eventID: int, category: short, rawData: byte[]): void;
    writeEvent(instance: EventInstance, data: byte[], ...values: unknown[]): void;
    writeEvent(instance: EventInstance, ...values: unknown[]): void;
}


export const EventLog: {
    new(): EventLog;
    new(logName: string): EventLog;
    new(logName: string, machineName: string): EventLog;
    new(logName: string, machineName: string, source: string): EventLog;
    createEventSource(sourceData: EventSourceCreationData): void;
    createEventSource(source: string, logName: string, machineName: string): void;
    createEventSource(source: string, logName: string): void;
    delete_(logName: string, machineName: string): void;
    delete_(logName: string): void;
    deleteEventSource(source: string, machineName: string): void;
    deleteEventSource(source: string): void;
    exists(logName: string, machineName: string): boolean;
    exists(logName: string): boolean;
    getEventLogs(): EventLog[];
    getEventLogs(machineName: string): EventLog[];
    logNameFromSourceName(source: string, machineName: string): string;
    sourceExists(source: string, machineName: string): boolean;
    sourceExists(source: string): boolean;
    writeEntry(source: string, message: string, type_: EventLogEntryType, eventID: int, category: short, rawData: byte[]): void;
    writeEntry(source: string, message: string, type_: EventLogEntryType, eventID: int, category: short): void;
    writeEntry(source: string, message: string, type_: EventLogEntryType, eventID: int): void;
    writeEntry(source: string, message: string, type_: EventLogEntryType): void;
    writeEntry(source: string, message: string): void;
    writeEvent(source: string, instance: EventInstance, data: byte[], ...values: unknown[]): void;
    writeEvent(source: string, instance: EventInstance, ...values: unknown[]): void;
};


export type EventLog = EventLog$instance;

export interface EventLogEntry$instance extends Component {
    readonly category: string;
    readonly categoryNumber: short;
    readonly data: byte[];
    readonly entryType: EventLogEntryType;
    readonly eventID: int;
    readonly index: int;
    readonly instanceId: long;
    readonly machineName: string | undefined;
    readonly message: string;
    readonly replacementStrings: string[];
    readonly source: string;
    readonly timeGenerated: DateTime;
    readonly timeWritten: DateTime;
    readonly userName: string;
    equals(otherEntry: EventLogEntry): boolean;
}


export const EventLogEntry: {
    new(): EventLogEntry;
};


export type EventLogEntry = EventLogEntry$instance;

export interface EventLogEntryCollection$instance {
    readonly count: int;
    readonly item: EventLogEntry;
    copyTo(entries: EventLogEntry[], index: int): void;
    getEnumerator(): IEnumerator;
}


export const EventLogEntryCollection: {
    new(): EventLogEntryCollection;
};


export type EventLogEntryCollection = EventLogEntryCollection$instance;

export interface EventLogTraceListener$instance extends TraceListener {
    eventLog: EventLog;
    name: string;
    close(): void;
    traceData(eventCache: TraceEventCache, source: string, severity: TraceEventType, id: int, data: unknown): void;
    traceData(eventCache: TraceEventCache, source: string, severity: TraceEventType, id: int, ...data: unknown[]): void;
    traceEvent(eventCache: TraceEventCache, source: string, severity: TraceEventType, id: int, message: string): void;
    traceEvent(eventCache: TraceEventCache, source: string, severity: TraceEventType, id: int, format: string, ...args: unknown[]): void;
    write(message: string): void;
    writeLine(message: string): void;
}


export const EventLogTraceListener: {
    new(): EventLogTraceListener;
    new(eventLog: EventLog): EventLogTraceListener;
    new(source: string): EventLogTraceListener;
};


export type EventLogTraceListener = EventLogTraceListener$instance;

export interface EventSourceCreationData$instance {
    categoryCount: int;
    categoryResourceFile: string;
    get logName(): string | undefined;
    set logName(value: string);
    get machineName(): string | undefined;
    set machineName(value: string);
    messageResourceFile: string;
    parameterResourceFile: string;
    source: string;
}


export const EventSourceCreationData: {
    new(source: string, logName: string): EventSourceCreationData;
};


export type EventSourceCreationData = EventSourceCreationData$instance;

