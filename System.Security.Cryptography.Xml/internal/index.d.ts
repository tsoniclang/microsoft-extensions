// Generated by tsbindgen - Architecture
// Namespace: System.Security.Cryptography.Xml
// Assembly: System.Security.Cryptography.Pkcs, System.Security.Cryptography.Xml

// Primitive type aliases from @tsonic/core
import type { sbyte, byte, short, ushort, int, uint, long, ulong, int128, uint128, half, float, double, decimal, nint, nuint, char } from '@tsonic/core/types.js';

// Import support types from @tsonic/core
import type { ptr } from "@tsonic/core/types.js";

// Import types from other namespaces
import * as System_Collections_Internal from "@tsonic/dotnet/System.Collections.js";
import type { ArrayList, Hashtable, ICollection, IEnumerable, IEnumerator, IList } from "@tsonic/dotnet/System.Collections.js";
import type { Collection } from "@tsonic/dotnet/System.Collections.ObjectModel.js";
import type { Stream } from "@tsonic/dotnet/System.IO.js";
import * as System_Internal from "@tsonic/dotnet/System.js";
import type { Array as ClrArray, Boolean as ClrBoolean, Byte, Exception, Func, Int32, Object as ClrObject, String as ClrString, Type, ValueType, Void } from "@tsonic/dotnet/System.js";
import * as System_Runtime_Serialization_Internal from "@tsonic/dotnet/System.Runtime.Serialization.js";
import type { ISerializable } from "@tsonic/dotnet/System.Runtime.Serialization.js";
import type { AsymmetricAlgorithm, CipherMode, DSA, HashAlgorithm, KeyedHashAlgorithm, PaddingMode, RSA, SymmetricAlgorithm } from "@tsonic/dotnet/System.Security.Cryptography.js";
import type { X509Certificate, X509Certificate2, X509IncludeOption } from "@tsonic/dotnet/System.Security.Cryptography.X509Certificates.js";
import type { Evidence } from "@tsonic/dotnet/System.Security.Policy.js";
import type { Encoding } from "@tsonic/dotnet/System.Text.js";
import * as System_Xml_Internal from "@tsonic/dotnet/System.Xml.js";
import type { XmlDocument, XmlElement, XmlException, XmlNodeList, XmlResolver } from "@tsonic/dotnet/System.Xml.js";

export interface IRelDecryptor$instance {
    decrypt(encryptionMethod: EncryptionMethod, keyInfo: KeyInfo, toDecrypt: Stream): Stream;
}


export type IRelDecryptor = IRelDecryptor$instance;

export interface X509IssuerSerial$instance {
    issuerName: string;
    serialNumber: string;
}


export const X509IssuerSerial: {
    new(): X509IssuerSerial;
};


export type X509IssuerSerial = X509IssuerSerial$instance;

export interface CipherData$instance {
    get cipherReference(): CipherReference | undefined;
    set cipherReference(value: CipherReference);
    get cipherValue(): byte[] | undefined;
    set cipherValue(value: byte[]);
    getXml(): XmlElement;
    loadXml(value: XmlElement): void;
}


export const CipherData: {
    new(): CipherData;
    new(cipherValue: byte[]): CipherData;
    new(cipherReference: CipherReference): CipherData;
};


export type CipherData = CipherData$instance;

export interface CipherReference$instance extends EncryptedReference {
    getXml(): XmlElement;
    loadXml(value: XmlElement): void;
}


export const CipherReference: {
    new(): CipherReference;
    new(uri: string): CipherReference;
    new(uri: string, transformChain: TransformChain): CipherReference;
};


export type CipherReference = CipherReference$instance;

export interface CryptoSignedXmlRecursionException$instance extends XmlException {
}


export const CryptoSignedXmlRecursionException: {
    new(): CryptoSignedXmlRecursionException;
    new(message: string): CryptoSignedXmlRecursionException;
    new(message: string, inner: Exception): CryptoSignedXmlRecursionException;
};


export type CryptoSignedXmlRecursionException = CryptoSignedXmlRecursionException$instance;

export interface DataObject$instance {
    data: XmlNodeList;
    encoding: string;
    get id(): string | undefined;
    set id(value: string);
    get mimeType(): string | undefined;
    set mimeType(value: string);
    getXml(): XmlElement;
    loadXml(value: XmlElement): void;
}


export const DataObject: {
    new(): DataObject;
    new(id: string, mimeType: string, encoding: string, data: XmlElement): DataObject;
};


export type DataObject = DataObject$instance;

export interface DataReference$instance extends EncryptedReference {
}


export const DataReference: {
    new(): DataReference;
    new(uri: string): DataReference;
    new(uri: string, transformChain: TransformChain): DataReference;
};


export type DataReference = DataReference$instance;

export interface DSAKeyValue$instance extends KeyInfoClause {
    key: DSA;
    getXml(): XmlElement;
    loadXml(value: XmlElement): void;
}


export const DSAKeyValue: {
    new(): DSAKeyValue;
    new(key: DSA): DSAKeyValue;
};


export type DSAKeyValue = DSAKeyValue$instance;

export interface EncryptedData$instance extends EncryptedType {
    getXml(): XmlElement;
    loadXml(value: XmlElement): void;
}


export const EncryptedData: {
    new(): EncryptedData;
};


export type EncryptedData = EncryptedData$instance;

export interface EncryptedKey$instance extends EncryptedType {
    get carriedKeyName(): string | undefined;
    set carriedKeyName(value: string);
    recipient: string;
    readonly referenceList: ReferenceList;
    addReference(dataReference: DataReference): void;
    addReference(keyReference: KeyReference): void;
    getXml(): XmlElement;
    loadXml(value: XmlElement): void;
}


export const EncryptedKey: {
    new(): EncryptedKey;
};


export type EncryptedKey = EncryptedKey$instance;

export interface EncryptedReference$instance {
    transformChain: TransformChain;
    uri: string;
    addTransform(transform: Transform): void;
    getXml(): XmlElement;
    loadXml(value: XmlElement): void;
}


export const EncryptedReference: {
};


export type EncryptedReference = EncryptedReference$instance;

export interface EncryptedType$instance {
    cipherData: CipherData;
    encoding: string;
    get encryptionMethod(): EncryptionMethod | undefined;
    set encryptionMethod(value: EncryptionMethod);
    readonly encryptionProperties: EncryptionPropertyCollection;
    get id(): string | undefined;
    set id(value: string);
    keyInfo: KeyInfo;
    get mimeType(): string | undefined;
    set mimeType(value: string);
    get type(): string | undefined;
    set type(value: string);
    addProperty(ep: EncryptionProperty): void;
    getXml(): XmlElement;
    loadXml(value: XmlElement): void;
}


export const EncryptedType: {
};


export type EncryptedType = EncryptedType$instance;

export interface EncryptedXml$instance {
    get documentEvidence(): Evidence | undefined;
    set documentEvidence(value: Evidence);
    encoding: Encoding;
    mode: CipherMode;
    padding: PaddingMode;
    recipient: string;
    resolver: XmlResolver;
    xmlDSigSearchDepth: int;
    addKeyNameMapping(keyName: string, keyObject: unknown): void;
    clearKeyNameMappings(): void;
    decryptData(encryptedData: EncryptedData, symmetricAlgorithm: SymmetricAlgorithm): byte[];
    decryptDocument(): void;
    decryptEncryptedKey(encryptedKey: EncryptedKey): byte[] | undefined;
    encrypt(inputElement: XmlElement, certificate: X509Certificate2): EncryptedData;
    encrypt(inputElement: XmlElement, keyName: string): EncryptedData;
    encryptData(plaintext: byte[], symmetricAlgorithm: SymmetricAlgorithm): byte[];
    encryptData(inputElement: XmlElement, symmetricAlgorithm: SymmetricAlgorithm, content: boolean): byte[];
    getDecryptionIV(encryptedData: EncryptedData, symmetricAlgorithmUri: string): byte[];
    getDecryptionKey(encryptedData: EncryptedData, symmetricAlgorithmUri: string): SymmetricAlgorithm | undefined;
    getIdElement(document: XmlDocument, idValue: string): XmlElement | undefined;
    replaceData(inputElement: XmlElement, decryptedData: byte[]): void;
}


export const EncryptedXml: {
    new(): EncryptedXml;
    new(document: XmlDocument): EncryptedXml;
    new(document: XmlDocument, evidence: Evidence): EncryptedXml;
    readonly xmlEncNamespaceUrl: string;
    readonly xmlEncElementUrl: string;
    readonly xmlEncElementContentUrl: string;
    readonly xmlEncEncryptedKeyUrl: string;
    readonly xmlEncDESUrl: string;
    readonly xmlEncTripleDESUrl: string;
    readonly xmlEncAES128Url: string;
    readonly xmlEncAES256Url: string;
    readonly xmlEncAES192Url: string;
    readonly xmlEncRSA15Url: string;
    readonly xmlEncRSAOAEPUrl: string;
    readonly xmlEncTripleDESKeyWrapUrl: string;
    readonly xmlEncAES128KeyWrapUrl: string;
    readonly xmlEncAES256KeyWrapUrl: string;
    readonly xmlEncAES192KeyWrapUrl: string;
    readonly xmlEncSHA256Url: string;
    readonly xmlEncSHA512Url: string;
    decryptKey(keyData: byte[], rsa: RSA, useOAEP: boolean): byte[];
    decryptKey(keyData: byte[], symmetricAlgorithm: SymmetricAlgorithm): byte[];
    encryptKey(keyData: byte[], rsa: RSA, useOAEP: boolean): byte[];
    encryptKey(keyData: byte[], symmetricAlgorithm: SymmetricAlgorithm): byte[];
    replaceElement(inputElement: XmlElement, encryptedData: EncryptedData, content: boolean): void;
};


export type EncryptedXml = EncryptedXml$instance;

export interface EncryptionMethod$instance {
    get keyAlgorithm(): string | undefined;
    set keyAlgorithm(value: string);
    keySize: int;
    getXml(): XmlElement;
    loadXml(value: XmlElement): void;
}


export const EncryptionMethod: {
    new(): EncryptionMethod;
    new(algorithm: string): EncryptionMethod;
};


export type EncryptionMethod = EncryptionMethod$instance;

export interface EncryptionProperty$instance {
    readonly id: string | undefined;
    get propertyElement(): XmlElement | undefined;
    set propertyElement(value: XmlElement);
    readonly target: string | undefined;
    getXml(): XmlElement;
    loadXml(value: XmlElement): void;
}


export const EncryptionProperty: {
    new(): EncryptionProperty;
    new(elementProperty: XmlElement): EncryptionProperty;
};


export type EncryptionProperty = EncryptionProperty$instance;

export interface EncryptionPropertyCollection$instance {
    readonly count: int;
    readonly isFixedSize: boolean;
    readonly isReadOnly: boolean;
    readonly isSynchronized: boolean;
    itemOf: EncryptionProperty;
    readonly syncRoot: unknown;
    add(value: EncryptionProperty): int;
    clear(): void;
    contains(value: EncryptionProperty): boolean;
    copyTo(array: ClrArray, index: int): void;
    copyTo(array: EncryptionProperty[], index: int): void;
    getEnumerator(): IEnumerator;
    indexOf(value: EncryptionProperty): int;
    insert(index: int, value: EncryptionProperty): void;
    item(index: int): EncryptionProperty;
    remove(value: EncryptionProperty): void;
    removeAt(index: int): void;
}


export const EncryptionPropertyCollection: {
    new(): EncryptionPropertyCollection;
};


export type EncryptionPropertyCollection = EncryptionPropertyCollection$instance;

export interface KeyInfo$instance {
    readonly count: int;
    get id(): string | undefined;
    set id(value: string);
    addClause(clause: KeyInfoClause): void;
    getEnumerator(): IEnumerator;
    getEnumerator(requestedObjectType: Type): IEnumerator;
    getXml(): XmlElement;
    loadXml(value: XmlElement): void;
}


export const KeyInfo: {
    new(): KeyInfo;
};


export type KeyInfo = KeyInfo$instance;

export interface KeyInfoClause$instance {
    getXml(): XmlElement;
    loadXml(element: XmlElement): void;
}


export const KeyInfoClause: {
};


export type KeyInfoClause = KeyInfoClause$instance;

export interface KeyInfoEncryptedKey$instance extends KeyInfoClause {
    encryptedKey: EncryptedKey;
    getXml(): XmlElement;
    loadXml(value: XmlElement): void;
}


export const KeyInfoEncryptedKey: {
    new(): KeyInfoEncryptedKey;
    new(encryptedKey: EncryptedKey): KeyInfoEncryptedKey;
};


export type KeyInfoEncryptedKey = KeyInfoEncryptedKey$instance;

export interface KeyInfoName$instance extends KeyInfoClause {
    value: string;
    getXml(): XmlElement;
    loadXml(value: XmlElement): void;
}


export const KeyInfoName: {
    new(): KeyInfoName;
    new(keyName: string): KeyInfoName;
};


export type KeyInfoName = KeyInfoName$instance;

export interface KeyInfoNode$instance extends KeyInfoClause {
    value: XmlElement;
    getXml(): XmlElement;
    loadXml(value: XmlElement): void;
}


export const KeyInfoNode: {
    new(): KeyInfoNode;
    new(node: XmlElement): KeyInfoNode;
};


export type KeyInfoNode = KeyInfoNode$instance;

export interface KeyInfoRetrievalMethod$instance extends KeyInfoClause {
    get type(): string | undefined;
    set type(value: string);
    uri: string;
    getXml(): XmlElement;
    loadXml(value: XmlElement): void;
}


export const KeyInfoRetrievalMethod: {
    new(): KeyInfoRetrievalMethod;
    new(strUri: string): KeyInfoRetrievalMethod;
    new(strUri: string, typeName: string): KeyInfoRetrievalMethod;
};


export type KeyInfoRetrievalMethod = KeyInfoRetrievalMethod$instance;

export interface KeyInfoX509Data$instance extends KeyInfoClause {
    readonly certificates: ArrayList;
    get CRL(): byte[] | undefined;
    set CRL(value: byte[]);
    readonly issuerSerials: ArrayList | undefined;
    readonly subjectKeyIds: ArrayList | undefined;
    readonly subjectNames: ArrayList | undefined;
    addCertificate(certificate: X509Certificate): void;
    addIssuerSerial(issuerName: string, serialNumber: string): void;
    addSubjectKeyId(subjectKeyId: byte[]): void;
    addSubjectKeyId(subjectKeyId: string): void;
    addSubjectName(subjectName: string): void;
    getXml(): XmlElement;
    loadXml(element: XmlElement): void;
}


export const KeyInfoX509Data: {
    new(): KeyInfoX509Data;
    new(rgbCert: byte[]): KeyInfoX509Data;
    new(cert: X509Certificate): KeyInfoX509Data;
    new(cert: X509Certificate, includeOption: X509IncludeOption): KeyInfoX509Data;
};


export type KeyInfoX509Data = KeyInfoX509Data$instance;

export interface KeyReference$instance extends EncryptedReference {
}


export const KeyReference: {
    new(): KeyReference;
    new(uri: string): KeyReference;
    new(uri: string, transformChain: TransformChain): KeyReference;
};


export type KeyReference = KeyReference$instance;

export interface Reference$instance {
    digestMethod: string;
    get digestValue(): byte[] | undefined;
    set digestValue(value: byte[]);
    get id(): string | undefined;
    set id(value: string);
    transformChain: TransformChain;
    get type(): string | undefined;
    set type(value: string);
    uri: string;
    addTransform(transform: Transform): void;
    getXml(): XmlElement;
    loadXml(value: XmlElement): void;
}


export const Reference: {
    new(): Reference;
    new(stream: Stream): Reference;
    new(uri: string): Reference;
};


export type Reference = Reference$instance;

export interface ReferenceList$instance {
    readonly count: int;
    readonly isSynchronized: boolean;
    itemOf: EncryptedReference;
    readonly syncRoot: unknown;
    add(value: unknown): int;
    clear(): void;
    contains(value: unknown): boolean;
    copyTo(array: ClrArray, index: int): void;
    getEnumerator(): IEnumerator;
    indexOf(value: unknown): int;
    insert(index: int, value: unknown): void;
    item(index: int): EncryptedReference;
    remove(value: unknown): void;
    removeAt(index: int): void;
}


export const ReferenceList: {
    new(): ReferenceList;
};


export type ReferenceList = ReferenceList$instance;

export interface RSAKeyValue$instance extends KeyInfoClause {
    key: RSA;
    getXml(): XmlElement;
    loadXml(value: XmlElement): void;
}


export const RSAKeyValue: {
    new(): RSAKeyValue;
    new(key: RSA): RSAKeyValue;
};


export type RSAKeyValue = RSAKeyValue$instance;

export interface Signature$instance {
    get id(): string | undefined;
    set id(value: string);
    keyInfo: KeyInfo;
    objectList: IList;
    get signatureValue(): byte[] | undefined;
    set signatureValue(value: byte[]);
    get signedInfo(): SignedInfo | undefined;
    set signedInfo(value: SignedInfo);
    addObject(dataObject: DataObject): void;
    getXml(): XmlElement;
    loadXml(value: XmlElement): void;
}


export const Signature: {
    new(): Signature;
};


export type Signature = Signature$instance;

export interface SignedInfo$instance {
    canonicalizationMethod: string;
    readonly canonicalizationMethodObject: Transform;
    readonly count: int;
    get id(): string | undefined;
    set id(value: string);
    readonly isReadOnly: boolean;
    readonly isSynchronized: boolean;
    readonly references: ArrayList;
    get signatureLength(): string | undefined;
    set signatureLength(value: string);
    get signatureMethod(): string | undefined;
    set signatureMethod(value: string);
    readonly syncRoot: unknown;
    addReference(reference: Reference): void;
    copyTo(array: ClrArray, index: int): void;
    getEnumerator(): IEnumerator;
    getXml(): XmlElement;
    loadXml(value: XmlElement): void;
}


export const SignedInfo: {
    new(): SignedInfo;
};


export type SignedInfo = SignedInfo$instance;

export interface SignedXml$instance {
    encryptedXml: EncryptedXml;
    keyInfo: KeyInfo;
    resolver: XmlResolver;
    readonly safeCanonicalizationMethods: Collection<System_Internal.String>;
    readonly signature: Signature;
    signatureFormatValidator: Func<SignedXml, System_Internal.Boolean>;
    readonly signatureLength: string | undefined;
    readonly signatureMethod: string | undefined;
    readonly signatureValue: byte[] | undefined;
    readonly signedInfo: SignedInfo | undefined;
    get signingKey(): AsymmetricAlgorithm | undefined;
    set signingKey(value: AsymmetricAlgorithm);
    get signingKeyName(): string | undefined;
    set signingKeyName(value: string);
    addObject(dataObject: DataObject): void;
    addReference(reference: Reference): void;
    checkSignature(): boolean;
    checkSignature(key: AsymmetricAlgorithm): boolean;
    checkSignature(macAlg: KeyedHashAlgorithm): boolean;
    checkSignature(certificate: X509Certificate2, verifySignatureOnly: boolean): boolean;
    checkSignatureReturningKey(signingKey: AsymmetricAlgorithm): boolean;
    computeSignature(): void;
    computeSignature(macAlg: KeyedHashAlgorithm): void;
    getIdElement(document: XmlDocument, idValue: string): XmlElement | undefined;
    getXml(): XmlElement;
    loadXml(value: XmlElement): void;
}


export const SignedXml: {
    new(): SignedXml;
    new(document: XmlDocument): SignedXml;
    new(elem: XmlElement): SignedXml;
    readonly xmlDsigNamespaceUrl: string;
    readonly xmlDsigMinimalCanonicalizationUrl: string;
    readonly xmlDsigCanonicalizationUrl: string;
    readonly xmlDsigCanonicalizationWithCommentsUrl: string;
    readonly xmlDsigSHA1Url: string;
    readonly xmlDsigDSAUrl: string;
    readonly xmlDsigRSASHA1Url: string;
    readonly xmlDsigHMACSHA1Url: string;
    readonly xmlDsigSHA256Url: string;
    readonly xmlDsigRSASHA256Url: string;
    readonly xmlDsigSHA384Url: string;
    readonly xmlDsigRSASHA384Url: string;
    readonly xmlDsigSHA512Url: string;
    readonly xmlDsigRSASHA512Url: string;
    readonly xmlDsigC14NTransformUrl: string;
    readonly xmlDsigC14NWithCommentsTransformUrl: string;
    readonly xmlDsigExcC14NTransformUrl: string;
    readonly xmlDsigExcC14NWithCommentsTransformUrl: string;
    readonly xmlDsigBase64TransformUrl: string;
    readonly xmlDsigXPathTransformUrl: string;
    readonly xmlDsigXsltTransformUrl: string;
    readonly xmlDsigEnvelopedSignatureTransformUrl: string;
    readonly xmlDecryptionTransformUrl: string;
    readonly xmlLicenseTransformUrl: string;
};


export type SignedXml = SignedXml$instance;

export interface Transform$instance {
    algorithm: string;
    get context(): XmlElement | undefined;
    set context(value: XmlElement);
    readonly inputTypes: Type[];
    readonly outputTypes: Type[];
    readonly propagatedNamespaces: Hashtable;
    getDigestedOutput(hash: HashAlgorithm): byte[];
    getOutput(): unknown;
    getOutput(type: Type): unknown;
    getXml(): XmlElement;
    loadInnerXml(nodeList: XmlNodeList): void;
    loadInput(obj: unknown): void;
}


export const Transform: {
};


export type Transform = Transform$instance;

export interface TransformChain$instance {
    readonly count: int;
    readonly item: Transform;
    add(transform: Transform): void;
    getEnumerator(): IEnumerator;
}


export const TransformChain: {
    new(): TransformChain;
};


export type TransformChain = TransformChain$instance;

export interface XmlDecryptionTransform$instance extends Transform {
    encryptedXml: EncryptedXml;
    readonly inputTypes: Type[];
    readonly outputTypes: Type[];
    addExceptUri(uri: string): void;
    getOutput(): unknown;
    getOutput(type: Type): unknown;
    loadInnerXml(nodeList: XmlNodeList): void;
    loadInput(obj: unknown): void;
}


export const XmlDecryptionTransform: {
    new(): XmlDecryptionTransform;
};


export type XmlDecryptionTransform = XmlDecryptionTransform$instance;

export interface XmlDsigBase64Transform$instance extends Transform {
    readonly inputTypes: Type[];
    readonly outputTypes: Type[];
    getOutput(): unknown;
    getOutput(type: Type): unknown;
    loadInnerXml(nodeList: XmlNodeList): void;
    loadInput(obj: unknown): void;
}


export const XmlDsigBase64Transform: {
    new(): XmlDsigBase64Transform;
};


export type XmlDsigBase64Transform = XmlDsigBase64Transform$instance;

export interface XmlDsigC14NTransform$instance extends Transform {
    readonly inputTypes: Type[];
    readonly outputTypes: Type[];
    getDigestedOutput(hash: HashAlgorithm): byte[];
    getOutput(): unknown;
    getOutput(type: Type): unknown;
    loadInnerXml(nodeList: XmlNodeList): void;
    loadInput(obj: unknown): void;
}


export const XmlDsigC14NTransform: {
    new(): XmlDsigC14NTransform;
    new(includeComments: boolean): XmlDsigC14NTransform;
};


export type XmlDsigC14NTransform = XmlDsigC14NTransform$instance;

export interface XmlDsigC14NWithCommentsTransform$instance extends XmlDsigC14NTransform {
}


export const XmlDsigC14NWithCommentsTransform: {
    new(): XmlDsigC14NWithCommentsTransform;
};


export type XmlDsigC14NWithCommentsTransform = XmlDsigC14NWithCommentsTransform$instance;

export interface XmlDsigEnvelopedSignatureTransform$instance extends Transform {
    readonly inputTypes: Type[];
    readonly outputTypes: Type[];
    getOutput(): unknown;
    getOutput(type: Type): unknown;
    loadInnerXml(nodeList: XmlNodeList): void;
    loadInput(obj: unknown): void;
}


export const XmlDsigEnvelopedSignatureTransform: {
    new(): XmlDsigEnvelopedSignatureTransform;
    new(includeComments: boolean): XmlDsigEnvelopedSignatureTransform;
};


export type XmlDsigEnvelopedSignatureTransform = XmlDsigEnvelopedSignatureTransform$instance;

export interface XmlDsigExcC14NTransform$instance extends Transform {
    get inclusiveNamespacesPrefixList(): string | undefined;
    set inclusiveNamespacesPrefixList(value: string);
    readonly inputTypes: Type[];
    readonly outputTypes: Type[];
    getDigestedOutput(hash: HashAlgorithm): byte[];
    getOutput(): unknown;
    getOutput(type: Type): unknown;
    loadInnerXml(nodeList: XmlNodeList): void;
    loadInput(obj: unknown): void;
}


export const XmlDsigExcC14NTransform: {
    new(): XmlDsigExcC14NTransform;
    new(includeComments: boolean): XmlDsigExcC14NTransform;
    new(inclusiveNamespacesPrefixList: string): XmlDsigExcC14NTransform;
    new(includeComments: boolean, inclusiveNamespacesPrefixList: string): XmlDsigExcC14NTransform;
};


export type XmlDsigExcC14NTransform = XmlDsigExcC14NTransform$instance;

export interface XmlDsigExcC14NWithCommentsTransform$instance extends XmlDsigExcC14NTransform {
}


export const XmlDsigExcC14NWithCommentsTransform: {
    new(): XmlDsigExcC14NWithCommentsTransform;
    new(inclusiveNamespacesPrefixList: string): XmlDsigExcC14NWithCommentsTransform;
};


export type XmlDsigExcC14NWithCommentsTransform = XmlDsigExcC14NWithCommentsTransform$instance;

export interface XmlDsigXPathTransform$instance extends Transform {
    readonly inputTypes: Type[];
    readonly outputTypes: Type[];
    getOutput(): unknown;
    getOutput(type: Type): unknown;
    loadInnerXml(nodeList: XmlNodeList): void;
    loadInput(obj: unknown): void;
}


export const XmlDsigXPathTransform: {
    new(): XmlDsigXPathTransform;
};


export type XmlDsigXPathTransform = XmlDsigXPathTransform$instance;

export interface XmlDsigXsltTransform$instance extends Transform {
    readonly inputTypes: Type[];
    readonly outputTypes: Type[];
    getOutput(): unknown;
    getOutput(type: Type): unknown;
    loadInnerXml(nodeList: XmlNodeList): void;
    loadInput(obj: unknown): void;
}


export const XmlDsigXsltTransform: {
    new(): XmlDsigXsltTransform;
    new(includeComments: boolean): XmlDsigXsltTransform;
};


export type XmlDsigXsltTransform = XmlDsigXsltTransform$instance;

export interface XmlLicenseTransform$instance extends Transform {
    get decryptor(): IRelDecryptor | undefined;
    set decryptor(value: IRelDecryptor);
    readonly inputTypes: Type[];
    readonly outputTypes: Type[];
    getOutput(): unknown;
    getOutput(type: Type): unknown;
    loadInnerXml(nodeList: XmlNodeList): void;
    loadInput(obj: unknown): void;
}


export const XmlLicenseTransform: {
    new(): XmlLicenseTransform;
};


export type XmlLicenseTransform = XmlLicenseTransform$instance;

