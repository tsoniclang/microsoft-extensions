// Generated by tsbindgen - Architecture
// Namespace: System.Security.Cryptography.Xml
// Assembly: System.Security.Cryptography.Pkcs, System.Security.Cryptography.Xml

// Primitive type aliases from @tsonic/core
import type { sbyte, byte, short, ushort, int, uint, long, ulong, int128, uint128, half, float, double, decimal, nint, nuint, char } from '@tsonic/core/types.js';

// Import support types from @tsonic/core
import type { ptr } from "@tsonic/core/types.js";

// Import types from other namespaces
import * as System_Collections_Internal from "@tsonic/dotnet/System.Collections.js";
import type { ArrayList, Hashtable, ICollection, IEnumerable, IEnumerator, IList } from "@tsonic/dotnet/System.Collections.js";
import type { Collection } from "@tsonic/dotnet/System.Collections.ObjectModel.js";
import type { Stream } from "@tsonic/dotnet/System.IO.js";
import * as System_Internal from "@tsonic/dotnet/System.js";
import type { Array as ClrArray, Boolean as ClrBoolean, Byte, Exception, Func, Int32, Object as ClrObject, String as ClrString, Type, ValueType, Void } from "@tsonic/dotnet/System.js";
import * as System_Runtime_Serialization_Internal from "@tsonic/dotnet/System.Runtime.Serialization.js";
import type { ISerializable, SerializationInfo, StreamingContext } from "@tsonic/dotnet/System.Runtime.Serialization.js";
import type { AsymmetricAlgorithm, CipherMode, DSA, HashAlgorithm, KeyedHashAlgorithm, PaddingMode, RSA, SymmetricAlgorithm } from "@tsonic/dotnet/System.Security.Cryptography.js";
import type { X509Certificate, X509Certificate2, X509IncludeOption } from "@tsonic/dotnet/System.Security.Cryptography.X509Certificates.js";
import type { Evidence } from "@tsonic/dotnet/System.Security.Policy.js";
import type { Encoding } from "@tsonic/dotnet/System.Text.js";
import * as System_Xml_Internal from "@tsonic/dotnet/System.Xml.js";
import type { XmlDocument, XmlElement, XmlException, XmlNodeList, XmlResolver } from "@tsonic/dotnet/System.Xml.js";

export interface IRelDecryptor$instance {
    Decrypt(encryptionMethod: EncryptionMethod, keyInfo: KeyInfo, toDecrypt: Stream): Stream;
}


export type IRelDecryptor = IRelDecryptor$instance;

export interface X509IssuerSerial$instance {
    IssuerName: string;
    SerialNumber: string;
}


export const X509IssuerSerial: {
    new(): X509IssuerSerial;
};


export type X509IssuerSerial = X509IssuerSerial$instance;

export interface CipherData$instance {
    get CipherReference(): CipherReference | undefined;
    set CipherReference(value: CipherReference);
    get CipherValue(): byte[] | undefined;
    set CipherValue(value: byte[]);
    GetXml(): XmlElement;
    LoadXml(value: XmlElement): void;
}


export const CipherData: {
    new(): CipherData;
    new(cipherValue: byte[]): CipherData;
    new(cipherReference: CipherReference): CipherData;
};


export type CipherData = CipherData$instance;

export interface CipherReference$instance extends EncryptedReference {
    GetXml(): XmlElement;
    LoadXml(value: XmlElement): void;
}


export const CipherReference: {
    new(): CipherReference;
    new(uri: string): CipherReference;
    new(uri: string, transformChain: TransformChain): CipherReference;
};


export type CipherReference = CipherReference$instance;

export interface CryptoSignedXmlRecursionException$instance extends XmlException {
}


export const CryptoSignedXmlRecursionException: {
    new(): CryptoSignedXmlRecursionException;
    new(message: string): CryptoSignedXmlRecursionException;
    new(message: string, inner: Exception): CryptoSignedXmlRecursionException;
    new(info: SerializationInfo, context: StreamingContext): CryptoSignedXmlRecursionException;
};


export type CryptoSignedXmlRecursionException = CryptoSignedXmlRecursionException$instance;

export interface DataObject$instance {
    Data: XmlNodeList;
    Encoding: string;
    get Id(): string | undefined;
    set Id(value: string);
    get MimeType(): string | undefined;
    set MimeType(value: string);
    GetXml(): XmlElement;
    LoadXml(value: XmlElement): void;
}


export const DataObject: {
    new(): DataObject;
    new(id: string, mimeType: string, encoding: string, data: XmlElement): DataObject;
};


export type DataObject = DataObject$instance;

export interface DataReference$instance extends EncryptedReference {
}


export const DataReference: {
    new(): DataReference;
    new(uri: string): DataReference;
    new(uri: string, transformChain: TransformChain): DataReference;
};


export type DataReference = DataReference$instance;

export interface DSAKeyValue$instance extends KeyInfoClause {
    Key: DSA;
    GetXml(): XmlElement;
    LoadXml(value: XmlElement): void;
}


export const DSAKeyValue: {
    new(): DSAKeyValue;
    new(key: DSA): DSAKeyValue;
};


export type DSAKeyValue = DSAKeyValue$instance;

export interface EncryptedData$instance extends EncryptedType {
    GetXml(): XmlElement;
    LoadXml(value: XmlElement): void;
}


export const EncryptedData: {
    new(): EncryptedData;
};


export type EncryptedData = EncryptedData$instance;

export interface EncryptedKey$instance extends EncryptedType {
    get CarriedKeyName(): string | undefined;
    set CarriedKeyName(value: string);
    Recipient: string;
    readonly ReferenceList: ReferenceList;
    AddReference(dataReference: DataReference): void;
    AddReference(keyReference: KeyReference): void;
    GetXml(): XmlElement;
    LoadXml(value: XmlElement): void;
}


export const EncryptedKey: {
    new(): EncryptedKey;
};


export type EncryptedKey = EncryptedKey$instance;

export interface EncryptedReference$instance {
    TransformChain: TransformChain;
    Uri: string;
    AddTransform(transform: Transform): void;
    GetXml(): XmlElement;
    LoadXml(value: XmlElement): void;
}


export const EncryptedReference: {
    new(): EncryptedReference;
    new(uri: string): EncryptedReference;
    new(uri: string, transformChain: TransformChain): EncryptedReference;
};


export type EncryptedReference = EncryptedReference$instance;

export interface EncryptedType$instance {
    CipherData: CipherData;
    Encoding: string;
    get EncryptionMethod(): EncryptionMethod | undefined;
    set EncryptionMethod(value: EncryptionMethod);
    readonly EncryptionProperties: EncryptionPropertyCollection;
    get Id(): string | undefined;
    set Id(value: string);
    KeyInfo: KeyInfo;
    get MimeType(): string | undefined;
    set MimeType(value: string);
    get Type(): string | undefined;
    set Type(value: string);
    AddProperty(ep: EncryptionProperty): void;
    GetXml(): XmlElement;
    LoadXml(value: XmlElement): void;
}


export const EncryptedType: {
    new(): EncryptedType;
};


export type EncryptedType = EncryptedType$instance;

export interface EncryptedXml$instance {
    get DocumentEvidence(): Evidence | undefined;
    set DocumentEvidence(value: Evidence);
    Encoding: Encoding;
    Mode: CipherMode;
    Padding: PaddingMode;
    Recipient: string;
    Resolver: XmlResolver;
    XmlDSigSearchDepth: int;
    AddKeyNameMapping(keyName: string, keyObject: unknown): void;
    ClearKeyNameMappings(): void;
    DecryptData(encryptedData: EncryptedData, symmetricAlgorithm: SymmetricAlgorithm): byte[];
    DecryptDocument(): void;
    DecryptEncryptedKey(encryptedKey: EncryptedKey): byte[] | undefined;
    Encrypt(inputElement: XmlElement, certificate: X509Certificate2): EncryptedData;
    Encrypt(inputElement: XmlElement, keyName: string): EncryptedData;
    EncryptData(plaintext: byte[], symmetricAlgorithm: SymmetricAlgorithm): byte[];
    EncryptData(inputElement: XmlElement, symmetricAlgorithm: SymmetricAlgorithm, content: boolean): byte[];
    GetDecryptionIV(encryptedData: EncryptedData, symmetricAlgorithmUri: string): byte[];
    GetDecryptionKey(encryptedData: EncryptedData, symmetricAlgorithmUri: string): SymmetricAlgorithm | undefined;
    GetIdElement(document: XmlDocument, idValue: string): XmlElement | undefined;
    ReplaceData(inputElement: XmlElement, decryptedData: byte[]): void;
}


export const EncryptedXml: {
    new(): EncryptedXml;
    new(document: XmlDocument): EncryptedXml;
    new(document: XmlDocument, evidence: Evidence): EncryptedXml;
    readonly XmlEncNamespaceUrl: string;
    readonly XmlEncElementUrl: string;
    readonly XmlEncElementContentUrl: string;
    readonly XmlEncEncryptedKeyUrl: string;
    readonly XmlEncDESUrl: string;
    readonly XmlEncTripleDESUrl: string;
    readonly XmlEncAES128Url: string;
    readonly XmlEncAES256Url: string;
    readonly XmlEncAES192Url: string;
    readonly XmlEncRSA15Url: string;
    readonly XmlEncRSAOAEPUrl: string;
    readonly XmlEncTripleDESKeyWrapUrl: string;
    readonly XmlEncAES128KeyWrapUrl: string;
    readonly XmlEncAES256KeyWrapUrl: string;
    readonly XmlEncAES192KeyWrapUrl: string;
    readonly XmlEncSHA256Url: string;
    readonly XmlEncSHA512Url: string;
    DecryptKey(keyData: byte[], rsa: RSA, useOAEP: boolean): byte[];
    DecryptKey(keyData: byte[], symmetricAlgorithm: SymmetricAlgorithm): byte[];
    EncryptKey(keyData: byte[], rsa: RSA, useOAEP: boolean): byte[];
    EncryptKey(keyData: byte[], symmetricAlgorithm: SymmetricAlgorithm): byte[];
    ReplaceElement(inputElement: XmlElement, encryptedData: EncryptedData, content: boolean): void;
};


export type EncryptedXml = EncryptedXml$instance;

export interface EncryptionMethod$instance {
    get KeyAlgorithm(): string | undefined;
    set KeyAlgorithm(value: string);
    KeySize: int;
    GetXml(): XmlElement;
    LoadXml(value: XmlElement): void;
}


export const EncryptionMethod: {
    new(): EncryptionMethod;
    new(algorithm: string): EncryptionMethod;
};


export type EncryptionMethod = EncryptionMethod$instance;

export interface EncryptionProperty$instance {
    readonly Id: string | undefined;
    get PropertyElement(): XmlElement | undefined;
    set PropertyElement(value: XmlElement);
    readonly Target: string | undefined;
    GetXml(): XmlElement;
    LoadXml(value: XmlElement): void;
}


export const EncryptionProperty: {
    new(): EncryptionProperty;
    new(elementProperty: XmlElement): EncryptionProperty;
};


export type EncryptionProperty = EncryptionProperty$instance;

export interface EncryptionPropertyCollection$instance {
    readonly Count: int;
    readonly IsFixedSize: boolean;
    readonly IsReadOnly: boolean;
    readonly IsSynchronized: boolean;
    ItemOf: EncryptionProperty;
    readonly SyncRoot: unknown;
    Add(value: EncryptionProperty): int;
    Clear(): void;
    Contains(value: EncryptionProperty): boolean;
    CopyTo(array: ClrArray, index: int): void;
    CopyTo(array: EncryptionProperty[], index: int): void;
    GetEnumerator(): IEnumerator;
    IndexOf(value: EncryptionProperty): int;
    Insert(index: int, value: EncryptionProperty): void;
    Item(index: int): EncryptionProperty;
    Remove(value: EncryptionProperty): void;
    RemoveAt(index: int): void;
}


export const EncryptionPropertyCollection: {
    new(): EncryptionPropertyCollection;
};


export type EncryptionPropertyCollection = EncryptionPropertyCollection$instance;

export interface KeyInfo$instance {
    readonly Count: int;
    get Id(): string | undefined;
    set Id(value: string);
    AddClause(clause: KeyInfoClause): void;
    GetEnumerator(): IEnumerator;
    GetEnumerator(requestedObjectType: Type): IEnumerator;
    GetXml(): XmlElement;
    LoadXml(value: XmlElement): void;
}


export const KeyInfo: {
    new(): KeyInfo;
};


export type KeyInfo = KeyInfo$instance;

export interface KeyInfoClause$instance {
    GetXml(): XmlElement;
    LoadXml(element: XmlElement): void;
}


export const KeyInfoClause: {
    new(): KeyInfoClause;
};


export type KeyInfoClause = KeyInfoClause$instance;

export interface KeyInfoEncryptedKey$instance extends KeyInfoClause {
    EncryptedKey: EncryptedKey;
    GetXml(): XmlElement;
    LoadXml(value: XmlElement): void;
}


export const KeyInfoEncryptedKey: {
    new(): KeyInfoEncryptedKey;
    new(encryptedKey: EncryptedKey): KeyInfoEncryptedKey;
};


export type KeyInfoEncryptedKey = KeyInfoEncryptedKey$instance;

export interface KeyInfoName$instance extends KeyInfoClause {
    Value: string;
    GetXml(): XmlElement;
    LoadXml(value: XmlElement): void;
}


export const KeyInfoName: {
    new(): KeyInfoName;
    new(keyName: string): KeyInfoName;
};


export type KeyInfoName = KeyInfoName$instance;

export interface KeyInfoNode$instance extends KeyInfoClause {
    Value: XmlElement;
    GetXml(): XmlElement;
    LoadXml(value: XmlElement): void;
}


export const KeyInfoNode: {
    new(): KeyInfoNode;
    new(node: XmlElement): KeyInfoNode;
};


export type KeyInfoNode = KeyInfoNode$instance;

export interface KeyInfoRetrievalMethod$instance extends KeyInfoClause {
    get Type(): string | undefined;
    set Type(value: string);
    Uri: string;
    GetXml(): XmlElement;
    LoadXml(value: XmlElement): void;
}


export const KeyInfoRetrievalMethod: {
    new(): KeyInfoRetrievalMethod;
    new(strUri: string): KeyInfoRetrievalMethod;
    new(strUri: string, typeName: string): KeyInfoRetrievalMethod;
};


export type KeyInfoRetrievalMethod = KeyInfoRetrievalMethod$instance;

export interface KeyInfoX509Data$instance extends KeyInfoClause {
    readonly Certificates: ArrayList;
    get CRL(): byte[] | undefined;
    set CRL(value: byte[]);
    readonly IssuerSerials: ArrayList | undefined;
    readonly SubjectKeyIds: ArrayList | undefined;
    readonly SubjectNames: ArrayList | undefined;
    AddCertificate(certificate: X509Certificate): void;
    AddIssuerSerial(issuerName: string, serialNumber: string): void;
    AddSubjectKeyId(subjectKeyId: byte[]): void;
    AddSubjectKeyId(subjectKeyId: string): void;
    AddSubjectName(subjectName: string): void;
    GetXml(): XmlElement;
    LoadXml(element: XmlElement): void;
}


export const KeyInfoX509Data: {
    new(): KeyInfoX509Data;
    new(rgbCert: byte[]): KeyInfoX509Data;
    new(cert: X509Certificate): KeyInfoX509Data;
    new(cert: X509Certificate, includeOption: X509IncludeOption): KeyInfoX509Data;
};


export type KeyInfoX509Data = KeyInfoX509Data$instance;

export interface KeyReference$instance extends EncryptedReference {
}


export const KeyReference: {
    new(): KeyReference;
    new(uri: string): KeyReference;
    new(uri: string, transformChain: TransformChain): KeyReference;
};


export type KeyReference = KeyReference$instance;

export interface Reference$instance {
    DigestMethod: string;
    get DigestValue(): byte[] | undefined;
    set DigestValue(value: byte[]);
    get Id(): string | undefined;
    set Id(value: string);
    TransformChain: TransformChain;
    get Type(): string | undefined;
    set Type(value: string);
    Uri: string;
    AddTransform(transform: Transform): void;
    GetXml(): XmlElement;
    LoadXml(value: XmlElement): void;
}


export const Reference: {
    new(): Reference;
    new(stream: Stream): Reference;
    new(uri: string): Reference;
};


export type Reference = Reference$instance;

export interface ReferenceList$instance {
    readonly Count: int;
    readonly IsSynchronized: boolean;
    ItemOf: EncryptedReference;
    readonly SyncRoot: unknown;
    Add(value: unknown): int;
    Clear(): void;
    Contains(value: unknown): boolean;
    CopyTo(array: ClrArray, index: int): void;
    GetEnumerator(): IEnumerator;
    IndexOf(value: unknown): int;
    Insert(index: int, value: unknown): void;
    Item(index: int): EncryptedReference;
    Remove(value: unknown): void;
    RemoveAt(index: int): void;
}


export const ReferenceList: {
    new(): ReferenceList;
};


export type ReferenceList = ReferenceList$instance;

export interface RSAKeyValue$instance extends KeyInfoClause {
    Key: RSA;
    GetXml(): XmlElement;
    LoadXml(value: XmlElement): void;
}


export const RSAKeyValue: {
    new(): RSAKeyValue;
    new(key: RSA): RSAKeyValue;
};


export type RSAKeyValue = RSAKeyValue$instance;

export interface Signature$instance {
    get Id(): string | undefined;
    set Id(value: string);
    KeyInfo: KeyInfo;
    ObjectList: IList;
    get SignatureValue(): byte[] | undefined;
    set SignatureValue(value: byte[]);
    get SignedInfo(): SignedInfo | undefined;
    set SignedInfo(value: SignedInfo);
    AddObject(dataObject: DataObject): void;
    GetXml(): XmlElement;
    LoadXml(value: XmlElement): void;
}


export const Signature: {
    new(): Signature;
};


export type Signature = Signature$instance;

export interface SignedInfo$instance {
    CanonicalizationMethod: string;
    readonly CanonicalizationMethodObject: Transform;
    readonly Count: int;
    get Id(): string | undefined;
    set Id(value: string);
    readonly IsReadOnly: boolean;
    readonly IsSynchronized: boolean;
    readonly References: ArrayList;
    get SignatureLength(): string | undefined;
    set SignatureLength(value: string);
    get SignatureMethod(): string | undefined;
    set SignatureMethod(value: string);
    readonly SyncRoot: unknown;
    AddReference(reference: Reference): void;
    CopyTo(array: ClrArray, index: int): void;
    GetEnumerator(): IEnumerator;
    GetXml(): XmlElement;
    LoadXml(value: XmlElement): void;
}


export const SignedInfo: {
    new(): SignedInfo;
};


export type SignedInfo = SignedInfo$instance;

export abstract class SignedXml$protected {
    protected GetPublicKey(): AsymmetricAlgorithm | undefined;
}


export interface SignedXml$instance extends SignedXml$protected {
    EncryptedXml: EncryptedXml;
    KeyInfo: KeyInfo;
    Resolver: XmlResolver;
    readonly SafeCanonicalizationMethods: Collection<System_Internal.String>;
    readonly Signature: Signature;
    SignatureFormatValidator: Func<SignedXml, System_Internal.Boolean>;
    readonly SignatureLength: string | undefined;
    readonly SignatureMethod: string | undefined;
    readonly SignatureValue: byte[] | undefined;
    readonly SignedInfo: SignedInfo | undefined;
    get SigningKey(): AsymmetricAlgorithm | undefined;
    set SigningKey(value: AsymmetricAlgorithm);
    get SigningKeyName(): string | undefined;
    set SigningKeyName(value: string);
    AddObject(dataObject: DataObject): void;
    AddReference(reference: Reference): void;
    CheckSignature(): boolean;
    CheckSignature(key: AsymmetricAlgorithm): boolean;
    CheckSignature(macAlg: KeyedHashAlgorithm): boolean;
    CheckSignature(certificate: X509Certificate2, verifySignatureOnly: boolean): boolean;
    CheckSignatureReturningKey(signingKey: AsymmetricAlgorithm): boolean;
    ComputeSignature(): void;
    ComputeSignature(macAlg: KeyedHashAlgorithm): void;
    GetIdElement(document: XmlDocument, idValue: string): XmlElement | undefined;
    GetXml(): XmlElement;
    LoadXml(value: XmlElement): void;
}


export const SignedXml: {
    new(): SignedXml;
    new(document: XmlDocument): SignedXml;
    new(elem: XmlElement): SignedXml;
    readonly XmlDsigNamespaceUrl: string;
    readonly XmlDsigMinimalCanonicalizationUrl: string;
    readonly XmlDsigCanonicalizationUrl: string;
    readonly XmlDsigCanonicalizationWithCommentsUrl: string;
    readonly XmlDsigSHA1Url: string;
    readonly XmlDsigDSAUrl: string;
    readonly XmlDsigRSASHA1Url: string;
    readonly XmlDsigHMACSHA1Url: string;
    readonly XmlDsigSHA256Url: string;
    readonly XmlDsigRSASHA256Url: string;
    readonly XmlDsigSHA384Url: string;
    readonly XmlDsigRSASHA384Url: string;
    readonly XmlDsigSHA512Url: string;
    readonly XmlDsigRSASHA512Url: string;
    readonly XmlDsigC14NTransformUrl: string;
    readonly XmlDsigC14NWithCommentsTransformUrl: string;
    readonly XmlDsigExcC14NTransformUrl: string;
    readonly XmlDsigExcC14NWithCommentsTransformUrl: string;
    readonly XmlDsigBase64TransformUrl: string;
    readonly XmlDsigXPathTransformUrl: string;
    readonly XmlDsigXsltTransformUrl: string;
    readonly XmlDsigEnvelopedSignatureTransformUrl: string;
    readonly XmlDecryptionTransformUrl: string;
    readonly XmlLicenseTransformUrl: string;
};


export type SignedXml = SignedXml$instance;

export abstract class Transform$protected {
    protected abstract GetInnerXml(): XmlNodeList | undefined;
}


export interface Transform$instance extends Transform$protected {
    Algorithm: string;
    get Context(): XmlElement | undefined;
    set Context(value: XmlElement);
    readonly InputTypes: Type[];
    readonly OutputTypes: Type[];
    readonly PropagatedNamespaces: Hashtable;
    GetDigestedOutput(hash: HashAlgorithm): byte[];
    GetOutput(): unknown;
    GetOutput(type: Type): unknown;
    GetXml(): XmlElement;
    LoadInnerXml(nodeList: XmlNodeList): void;
    LoadInput(obj: unknown): void;
}


export const Transform: {
    new(): Transform;
};


export type Transform = Transform$instance;

export interface TransformChain$instance {
    readonly Count: int;
    readonly Item: Transform;
    Add(transform: Transform): void;
    GetEnumerator(): IEnumerator;
}


export const TransformChain: {
    new(): TransformChain;
};


export type TransformChain = TransformChain$instance;

export abstract class XmlDecryptionTransform$protected {
    protected GetInnerXml(): XmlNodeList | undefined;
    protected IsTargetElement(inputElement: XmlElement, idValue: string): boolean;
}


export interface XmlDecryptionTransform$instance extends XmlDecryptionTransform$protected, Transform {
    EncryptedXml: EncryptedXml;
    readonly InputTypes: Type[];
    readonly OutputTypes: Type[];
    AddExceptUri(uri: string): void;
    GetOutput(): unknown;
    GetOutput(type: Type): unknown;
    LoadInnerXml(nodeList: XmlNodeList): void;
    LoadInput(obj: unknown): void;
}


export const XmlDecryptionTransform: {
    new(): XmlDecryptionTransform;
};


export type XmlDecryptionTransform = XmlDecryptionTransform$instance;

export abstract class XmlDsigBase64Transform$protected {
    protected GetInnerXml(): XmlNodeList | undefined;
}


export interface XmlDsigBase64Transform$instance extends XmlDsigBase64Transform$protected, Transform {
    readonly InputTypes: Type[];
    readonly OutputTypes: Type[];
    GetOutput(): unknown;
    GetOutput(type: Type): unknown;
    LoadInnerXml(nodeList: XmlNodeList): void;
    LoadInput(obj: unknown): void;
}


export const XmlDsigBase64Transform: {
    new(): XmlDsigBase64Transform;
};


export type XmlDsigBase64Transform = XmlDsigBase64Transform$instance;

export abstract class XmlDsigC14NTransform$protected {
    protected GetInnerXml(): XmlNodeList | undefined;
}


export interface XmlDsigC14NTransform$instance extends XmlDsigC14NTransform$protected, Transform {
    readonly InputTypes: Type[];
    readonly OutputTypes: Type[];
    GetDigestedOutput(hash: HashAlgorithm): byte[];
    GetOutput(): unknown;
    GetOutput(type: Type): unknown;
    LoadInnerXml(nodeList: XmlNodeList): void;
    LoadInput(obj: unknown): void;
}


export const XmlDsigC14NTransform: {
    new(): XmlDsigC14NTransform;
    new(includeComments: boolean): XmlDsigC14NTransform;
};


export type XmlDsigC14NTransform = XmlDsigC14NTransform$instance;

export interface XmlDsigC14NWithCommentsTransform$instance extends XmlDsigC14NTransform {
}


export const XmlDsigC14NWithCommentsTransform: {
    new(): XmlDsigC14NWithCommentsTransform;
};


export type XmlDsigC14NWithCommentsTransform = XmlDsigC14NWithCommentsTransform$instance;

export abstract class XmlDsigEnvelopedSignatureTransform$protected {
    protected GetInnerXml(): XmlNodeList | undefined;
}


export interface XmlDsigEnvelopedSignatureTransform$instance extends XmlDsigEnvelopedSignatureTransform$protected, Transform {
    readonly InputTypes: Type[];
    readonly OutputTypes: Type[];
    GetOutput(): unknown;
    GetOutput(type: Type): unknown;
    LoadInnerXml(nodeList: XmlNodeList): void;
    LoadInput(obj: unknown): void;
}


export const XmlDsigEnvelopedSignatureTransform: {
    new(): XmlDsigEnvelopedSignatureTransform;
    new(includeComments: boolean): XmlDsigEnvelopedSignatureTransform;
};


export type XmlDsigEnvelopedSignatureTransform = XmlDsigEnvelopedSignatureTransform$instance;

export abstract class XmlDsigExcC14NTransform$protected {
    protected GetInnerXml(): XmlNodeList | undefined;
}


export interface XmlDsigExcC14NTransform$instance extends XmlDsigExcC14NTransform$protected, Transform {
    get InclusiveNamespacesPrefixList(): string | undefined;
    set InclusiveNamespacesPrefixList(value: string);
    readonly InputTypes: Type[];
    readonly OutputTypes: Type[];
    GetDigestedOutput(hash: HashAlgorithm): byte[];
    GetOutput(): unknown;
    GetOutput(type: Type): unknown;
    LoadInnerXml(nodeList: XmlNodeList): void;
    LoadInput(obj: unknown): void;
}


export const XmlDsigExcC14NTransform: {
    new(): XmlDsigExcC14NTransform;
    new(includeComments: boolean): XmlDsigExcC14NTransform;
    new(inclusiveNamespacesPrefixList: string): XmlDsigExcC14NTransform;
    new(includeComments: boolean, inclusiveNamespacesPrefixList: string): XmlDsigExcC14NTransform;
};


export type XmlDsigExcC14NTransform = XmlDsigExcC14NTransform$instance;

export interface XmlDsigExcC14NWithCommentsTransform$instance extends XmlDsigExcC14NTransform {
}


export const XmlDsigExcC14NWithCommentsTransform: {
    new(): XmlDsigExcC14NWithCommentsTransform;
    new(inclusiveNamespacesPrefixList: string): XmlDsigExcC14NWithCommentsTransform;
};


export type XmlDsigExcC14NWithCommentsTransform = XmlDsigExcC14NWithCommentsTransform$instance;

export abstract class XmlDsigXPathTransform$protected {
    protected GetInnerXml(): XmlNodeList | undefined;
}


export interface XmlDsigXPathTransform$instance extends XmlDsigXPathTransform$protected, Transform {
    readonly InputTypes: Type[];
    readonly OutputTypes: Type[];
    GetOutput(): unknown;
    GetOutput(type: Type): unknown;
    LoadInnerXml(nodeList: XmlNodeList): void;
    LoadInput(obj: unknown): void;
}


export const XmlDsigXPathTransform: {
    new(): XmlDsigXPathTransform;
};


export type XmlDsigXPathTransform = XmlDsigXPathTransform$instance;

export abstract class XmlDsigXsltTransform$protected {
    protected GetInnerXml(): XmlNodeList | undefined;
}


export interface XmlDsigXsltTransform$instance extends XmlDsigXsltTransform$protected, Transform {
    readonly InputTypes: Type[];
    readonly OutputTypes: Type[];
    GetOutput(): unknown;
    GetOutput(type: Type): unknown;
    LoadInnerXml(nodeList: XmlNodeList): void;
    LoadInput(obj: unknown): void;
}


export const XmlDsigXsltTransform: {
    new(): XmlDsigXsltTransform;
    new(includeComments: boolean): XmlDsigXsltTransform;
};


export type XmlDsigXsltTransform = XmlDsigXsltTransform$instance;

export abstract class XmlLicenseTransform$protected {
    protected GetInnerXml(): XmlNodeList | undefined;
}


export interface XmlLicenseTransform$instance extends XmlLicenseTransform$protected, Transform {
    get Decryptor(): IRelDecryptor | undefined;
    set Decryptor(value: IRelDecryptor);
    readonly InputTypes: Type[];
    readonly OutputTypes: Type[];
    GetOutput(): unknown;
    GetOutput(type: Type): unknown;
    LoadInnerXml(nodeList: XmlNodeList): void;
    LoadInput(obj: unknown): void;
}


export const XmlLicenseTransform: {
    new(): XmlLicenseTransform;
};


export type XmlLicenseTransform = XmlLicenseTransform$instance;

