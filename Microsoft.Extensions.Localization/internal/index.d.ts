// Generated by tsbindgen - Architecture
// Namespace: Microsoft.Extensions.Localization
// Assembly: Microsoft.Extensions.Localization, Microsoft.Extensions.Localization.Abstractions

// Primitive type aliases from @tsonic/core
import type { sbyte, byte, short, ushort, int, uint, long, ulong, int128, uint128, half, float, double, decimal, nint, nuint, char } from '@tsonic/core/types.js';

// Import types from other namespaces
import type { ILogger, ILoggerFactory } from "../../Microsoft.Extensions.Logging/internal/index.js";
import type { IOptions_1 } from "../../Microsoft.Extensions.Options/internal/index.js";
import type { IEnumerable, IList } from "@tsonic/dotnet/System.Collections.Generic.js";
import type { CultureInfo } from "@tsonic/dotnet/System.Globalization.js";
import * as System_Internal from "@tsonic/dotnet/System.js";
import type { Attribute, Boolean as ClrBoolean, Func, Object as ClrObject, String as ClrString, Type } from "@tsonic/dotnet/System.js";
import type { Assembly, TypeInfo } from "@tsonic/dotnet/System.Reflection.js";
import type { ResourceManager } from "@tsonic/dotnet/System.Resources.js";

export interface IResourceNamesCache$instance {
    GetOrAdd(name: string, valueFactory: Func<System_Internal.String, IList<System_Internal.String>>): IList<System_Internal.String> | undefined;
}


export type IResourceNamesCache = IResourceNamesCache$instance;

export interface IStringLocalizer$instance {
    get_Item2(name: string, ...arguments: unknown[]): LocalizedString;
    get_Item2(name: string): LocalizedString;
    GetAllStrings(includeParentCultures: boolean): IEnumerable<LocalizedString>;
}


export type IStringLocalizer = IStringLocalizer$instance;

export interface IStringLocalizer_1$instance<T> extends IStringLocalizer {
    get_Item2(name: string, ...arguments: unknown[]): LocalizedString;
    get_Item2(name: string): LocalizedString;
    GetAllStrings(includeParentCultures: boolean): IEnumerable<LocalizedString>;
    get_Item(name: string): LocalizedString;
}


export interface IStringLocalizer_1$instance<T> extends IStringLocalizer$instance {}

export type IStringLocalizer_1<T> = IStringLocalizer_1$instance<T>;

export interface IStringLocalizerFactory$instance {
    Create(baseName: string, location: string): IStringLocalizer;
    Create(resourceSource: Type): IStringLocalizer;
}


export type IStringLocalizerFactory = IStringLocalizerFactory$instance;

export interface LocalizationOptions$instance {
    ResourcesPath: string;
}


export const LocalizationOptions: {
    new(): LocalizationOptions;
};


export type LocalizationOptions = LocalizationOptions$instance;

export interface LocalizedString$instance {
    readonly Name: string;
    readonly ResourceNotFound: boolean;
    readonly SearchedLocation: string | undefined;
    readonly Value: string;
    ToString(): string;
}


export const LocalizedString: {
    new(name: string, value: string): LocalizedString;
    new(name: string, value: string, resourceNotFound: boolean): LocalizedString;
    new(name: string, value: string, resourceNotFound: boolean, searchedLocation: string): LocalizedString;
};


export type LocalizedString = LocalizedString$instance;

export interface ResourceLocationAttribute$instance extends Attribute {
    readonly ResourceLocation: string;
}


export const ResourceLocationAttribute: {
    new(resourceLocation: string): ResourceLocationAttribute;
};


export type ResourceLocationAttribute = ResourceLocationAttribute$instance;

export interface ResourceManagerStringLocalizer$instance {
    get_Item(name: string): LocalizedString;
    get_Item(name: string, ...arguments: unknown[]): LocalizedString;
    GetAllStrings(includeParentCultures: boolean): IEnumerable<LocalizedString>;
}


export const ResourceManagerStringLocalizer: {
    new(resourceManager: ResourceManager, resourceAssembly: Assembly, baseName: string, resourceNamesCache: IResourceNamesCache, logger: ILogger): ResourceManagerStringLocalizer;
};


export interface __ResourceManagerStringLocalizer$views {
    As_IStringLocalizer(): IStringLocalizer$instance;
}

export type ResourceManagerStringLocalizer = ResourceManagerStringLocalizer$instance & __ResourceManagerStringLocalizer$views;


export abstract class ResourceManagerStringLocalizerFactory$protected {
    protected CreateResourceManagerStringLocalizer(assembly: Assembly, baseName: string): ResourceManagerStringLocalizer;
    protected GetResourceLocationAttribute(assembly: Assembly): ResourceLocationAttribute | undefined;
    protected GetResourcePrefix(typeInfo: TypeInfo): string;
    protected GetResourcePrefix(baseResourceName: string, baseNamespace: string): string;
    protected GetResourcePrefix(typeInfo: TypeInfo, baseNamespace: string, resourcesRelativePath: string): string;
    protected GetResourcePrefix(location: string, baseName: string, resourceLocation: string): string;
    protected GetRootNamespaceAttribute(assembly: Assembly): RootNamespaceAttribute | undefined;
}


export interface ResourceManagerStringLocalizerFactory$instance extends ResourceManagerStringLocalizerFactory$protected {
    Create(resourceSource: Type): IStringLocalizer;
    Create(baseName: string, location: string): IStringLocalizer;
}


export const ResourceManagerStringLocalizerFactory: {
    new(localizationOptions: IOptions_1<LocalizationOptions>, loggerFactory: ILoggerFactory): ResourceManagerStringLocalizerFactory;
};


export interface __ResourceManagerStringLocalizerFactory$views {
    As_IStringLocalizerFactory(): IStringLocalizerFactory$instance;
}

export interface ResourceManagerStringLocalizerFactory$instance extends IStringLocalizerFactory$instance {}

export type ResourceManagerStringLocalizerFactory = ResourceManagerStringLocalizerFactory$instance & __ResourceManagerStringLocalizerFactory$views;


export interface ResourceNamesCache$instance {
    GetOrAdd(name: string, valueFactory: Func<System_Internal.String, IList<System_Internal.String>>): IList<System_Internal.String> | undefined;
}


export const ResourceNamesCache: {
    new(): ResourceNamesCache;
};


export interface __ResourceNamesCache$views {
    As_IResourceNamesCache(): IResourceNamesCache$instance;
}

export interface ResourceNamesCache$instance extends IResourceNamesCache$instance {}

export type ResourceNamesCache = ResourceNamesCache$instance & __ResourceNamesCache$views;


export interface RootNamespaceAttribute$instance extends Attribute {
    readonly RootNamespace: string;
}


export const RootNamespaceAttribute: {
    new(rootNamespace: string): RootNamespaceAttribute;
};


export type RootNamespaceAttribute = RootNamespaceAttribute$instance;

export interface StringLocalizer_1$instance<TResourceSource> extends IStringLocalizer_1<TResourceSource> {
    get_Item(name: string): LocalizedString;
    get_Item(name: string, ...arguments: unknown[]): LocalizedString;
    GetAllStrings(includeParentCultures: boolean): IEnumerable<LocalizedString>;
}


export const StringLocalizer_1: {
    new<TResourceSource>(factory: IStringLocalizerFactory): StringLocalizer_1<TResourceSource>;
};


export interface __StringLocalizer_1$views<TResourceSource> {
    As_IStringLocalizer(): IStringLocalizer$instance;
}

export type StringLocalizer_1<TResourceSource> = StringLocalizer_1$instance<TResourceSource> & __StringLocalizer_1$views<TResourceSource>;


export abstract class StringLocalizerExtensions$instance {
    static GetAllStrings(stringLocalizer: IStringLocalizer): IEnumerable<LocalizedString>;
    static GetString(stringLocalizer: IStringLocalizer, name: string, ...arguments: unknown[]): LocalizedString;
    static GetString(stringLocalizer: IStringLocalizer, name: string): LocalizedString;
}


export type StringLocalizerExtensions = StringLocalizerExtensions$instance;

