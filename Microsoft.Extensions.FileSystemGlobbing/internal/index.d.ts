// Generated by tsbindgen - Architecture
// Namespace: Microsoft.Extensions.FileSystemGlobbing
// Assembly: Microsoft.Extensions.FileSystemGlobbing

// Primitive type aliases from @tsonic/core
import type { sbyte, byte, short, ushort, int, uint, long, ulong, int128, uint128, half, float, double, decimal, nint, nuint, char } from '@tsonic/core/types.js';

// Import types from other namespaces
import * as Microsoft_Extensions_FileSystemGlobbing_Abstractions_Internal from "../../Microsoft.Extensions.FileSystemGlobbing.Abstractions/internal/index.js";
import type { DirectoryInfoBase, FileInfoBase, FileSystemInfoBase } from "../../Microsoft.Extensions.FileSystemGlobbing.Abstractions/internal/index.js";
import type { IEnumerable } from "@tsonic/dotnet/System.Collections.Generic.js";
import * as System_Internal from "@tsonic/dotnet/System.js";
import type { Boolean as ClrBoolean, IEquatable, Int32, Object as ClrObject, String as ClrString, StringComparison, ValueType, Void } from "@tsonic/dotnet/System.js";

export interface FilePatternMatch$instance {
    readonly Path: string;
    readonly Stem: string;
    Equals(other: FilePatternMatch): boolean;
    Equals(obj: unknown): boolean;
    GetHashCode(): int;
}


export const FilePatternMatch: {
    new(path: string, stem: string): FilePatternMatch;
};


export type FilePatternMatch = FilePatternMatch$instance;

export interface InMemoryDirectoryInfo$instance extends DirectoryInfoBase {
    readonly FullName: string;
    readonly Name: string;
    readonly ParentDirectory: DirectoryInfoBase | undefined;
    EnumerateFileSystemInfos(): IEnumerable<FileSystemInfoBase>;
    GetDirectory(path: string): DirectoryInfoBase;
    GetFile(path: string): FileInfoBase | undefined;
}


export const InMemoryDirectoryInfo: {
    new(rootDir: string, files: IEnumerable<System_Internal.String>): InMemoryDirectoryInfo;
};


export type InMemoryDirectoryInfo = InMemoryDirectoryInfo$instance;

export interface Matcher$instance {
    AddExclude(pattern: string): Matcher;
    AddInclude(pattern: string): Matcher;
    Execute(directoryInfo: DirectoryInfoBase): PatternMatchingResult;
}


export const Matcher: {
    new(): Matcher;
    new(comparisonType: StringComparison): Matcher;
    new(comparisonType: StringComparison, preserveFilterOrder: boolean): Matcher;
};


export type Matcher = Matcher$instance;

export interface PatternMatchingResult$instance {
    Files: IEnumerable<FilePatternMatch>;
    readonly HasMatches: boolean;
}


export const PatternMatchingResult: {
    new(files: IEnumerable<FilePatternMatch>): PatternMatchingResult;
    new(files: IEnumerable<FilePatternMatch>, hasMatches: boolean): PatternMatchingResult;
};


export type PatternMatchingResult = PatternMatchingResult$instance;

export abstract class MatcherExtensions$instance {
    static AddExcludePatterns(matcher: Matcher, ...excludePatternsGroups: IEnumerable<System_Internal.String>[]): void;
    static AddIncludePatterns(matcher: Matcher, ...includePatternsGroups: IEnumerable<System_Internal.String>[]): void;
    static GetResultsInFullPath(matcher: Matcher, directoryPath: string): IEnumerable<System_Internal.String>;
    static Match(matcher: Matcher, files: IEnumerable<System_Internal.String>): PatternMatchingResult;
    static Match(matcher: Matcher, rootDir: string, files: IEnumerable<System_Internal.String>): PatternMatchingResult;
    static Match(matcher: Matcher, rootDir: string, file: string): PatternMatchingResult;
    static Match(matcher: Matcher, file: string): PatternMatchingResult;
}


export type MatcherExtensions = MatcherExtensions$instance;

