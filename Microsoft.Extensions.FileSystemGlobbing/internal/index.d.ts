// Generated by tsbindgen - Architecture
// Namespace: Microsoft.Extensions.FileSystemGlobbing
// Assembly: Microsoft.Extensions.FileSystemGlobbing

// Primitive type aliases from @tsonic/core
import type { sbyte, byte, short, ushort, int, uint, long, ulong, int128, uint128, half, float, double, decimal, nint, nuint, char } from '@tsonic/core/types.js';

// Import types from other namespaces
import * as Microsoft_Extensions_FileSystemGlobbing_Abstractions_Internal from "../../Microsoft.Extensions.FileSystemGlobbing.Abstractions/internal/index.js";
import type { DirectoryInfoBase, FileInfoBase, FileSystemInfoBase } from "../../Microsoft.Extensions.FileSystemGlobbing.Abstractions/internal/index.js";
import type { IEnumerable } from "@tsonic/dotnet/System.Collections.Generic.js";
import * as System_Internal from "@tsonic/dotnet/System.js";
import type { Boolean as ClrBoolean, IEquatable, Int32, Object as ClrObject, String as ClrString, StringComparison, ValueType, Void } from "@tsonic/dotnet/System.js";

export interface FilePatternMatch$instance {
    readonly path: string;
    readonly stem: string;
    equals(other: FilePatternMatch): boolean;
    equals(obj: unknown): boolean;
    getHashCode(): int;
}


export const FilePatternMatch: {
    new(path: string, stem: string): FilePatternMatch;
};


export type FilePatternMatch = FilePatternMatch$instance;

export interface InMemoryDirectoryInfo$instance extends DirectoryInfoBase {
    readonly fullName: string;
    readonly name: string;
    readonly parentDirectory: DirectoryInfoBase | undefined;
    enumerateFileSystemInfos(): IEnumerable<FileSystemInfoBase>;
    getDirectory(path: string): DirectoryInfoBase;
    getFile(path: string): FileInfoBase | undefined;
}


export const InMemoryDirectoryInfo: {
    new(rootDir: string, files: IEnumerable<System_Internal.String>): InMemoryDirectoryInfo;
};


export type InMemoryDirectoryInfo = InMemoryDirectoryInfo$instance;

export interface Matcher$instance {
    addExclude(pattern: string): Matcher;
    addInclude(pattern: string): Matcher;
    execute(directoryInfo: DirectoryInfoBase): PatternMatchingResult;
}


export const Matcher: {
    new(): Matcher;
    new(comparisonType: StringComparison): Matcher;
    new(comparisonType: StringComparison, preserveFilterOrder: boolean): Matcher;
};


export type Matcher = Matcher$instance;

export interface PatternMatchingResult$instance {
    files: IEnumerable<FilePatternMatch>;
    readonly hasMatches: boolean;
}


export const PatternMatchingResult: {
    new(files: IEnumerable<FilePatternMatch>): PatternMatchingResult;
    new(files: IEnumerable<FilePatternMatch>, hasMatches: boolean): PatternMatchingResult;
};


export type PatternMatchingResult = PatternMatchingResult$instance;

export abstract class MatcherExtensions$instance {
    static addExcludePatterns(matcher: Matcher, ...excludePatternsGroups: IEnumerable<System_Internal.String>[]): void;
    static addIncludePatterns(matcher: Matcher, ...includePatternsGroups: IEnumerable<System_Internal.String>[]): void;
    static getResultsInFullPath(matcher: Matcher, directoryPath: string): IEnumerable<System_Internal.String>;
    static match(matcher: Matcher, files: IEnumerable<System_Internal.String>): PatternMatchingResult;
    static match(matcher: Matcher, rootDir: string, files: IEnumerable<System_Internal.String>): PatternMatchingResult;
    static match(matcher: Matcher, rootDir: string, file: string): PatternMatchingResult;
    static match(matcher: Matcher, file: string): PatternMatchingResult;
}


export type MatcherExtensions = MatcherExtensions$instance;

